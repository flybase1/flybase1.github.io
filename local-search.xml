<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Zookeeper安装使用</title>
    <link href="/post/194b14f1.html"/>
    <url>/post/194b14f1.html</url>
    
    <content type="html"><![CDATA[<h1 id="一-原生安装"><a href="#一-原生安装" class="headerlink" title="一. 原生安装"></a>一. 原生安装</h1><h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h1><p>必须要有java8以上版本</p><h1 id="2-下载Zookeeper"><a href="#2-下载Zookeeper" class="headerlink" title="2. 下载Zookeeper"></a>2. 下载Zookeeper</h1><p><a href="https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.5.10/apache-zookeeper-3.5.10.tar.gz">https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.5.10/apache-zookeeper-3.5.10.tar.gz</a></p><h1 id="3-上传Zookeeper到虚拟机"><a href="#3-上传Zookeeper到虚拟机" class="headerlink" title="3. 上传Zookeeper到虚拟机"></a>3. 上传Zookeeper到虚拟机</h1><h1 id="4-解压缩"><a href="#4-解压缩" class="headerlink" title="4. 解压缩"></a>4. 解压缩</h1><p>当前文件下创建一个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir zookeeper<br></code></pre></td></tr></table></figure><p>移动到zookeeper包里面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv apache-zookeeper-3.5.10.tar.gz /usr/local/src/zookeeper/<br></code></pre></td></tr></table></figure><p>解压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"> cd zookeeper<br>tar -zxvf apache-zookeeper-3.5.10.tar.gz <br></code></pre></td></tr></table></figure><h1 id="5-配置"><a href="#5-配置" class="headerlink" title="5. 配置"></a>5. 配置</h1><p>进入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd apache-zookeeper-3.5.10/<br>cd conf/<br></code></pre></td></tr></table></figure><p>原本的zoo_sample.cfg无法使用，需要创建一个zoo.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">The number of milliseconds of each tick</span><br>tickTime=2000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">The number of ticks that the initial</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">synchronization phase can take</span><br>initLimit=10<br><span class="hljs-meta prompt_"># </span><span class="language-bash">The number of ticks that can pass between</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">sending a request and getting an acknowledgement</span><br>syncLimit=5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">the directory <span class="hljs-built_in">where</span> the snapshot is stored.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">do</span> not use /tmp <span class="hljs-keyword">for</span> storage, /tmp here is just</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">example sakes.</span><br>dataDir=/tmp/zookeeper<br><span class="hljs-meta prompt_"># </span><span class="language-bash">the port at <span class="hljs-built_in">which</span> the clients will connect</span><br>clientPort=2181<br><span class="hljs-meta prompt_"># </span><span class="language-bash">the maximum number of client connections.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">increase this <span class="hljs-keyword">if</span> you need to handle more clients</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">maxClientCnxns=60</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Be sure to read the maintenance section of the</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">administrator guide before turning on autopurge.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># The number of snapshots to retain in dataDir</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">autopurge.snapRetainCount=3</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Purge task interval <span class="hljs-keyword">in</span> hours</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Set to <span class="hljs-string">&quot;0&quot;</span> to <span class="hljs-built_in">disable</span> auto purge feature</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">autopurge.purgeInterval=1</span><br></code></pre></td></tr></table></figure><p>需要改变dataDir<br>在当前目录创建zkdata目录，存放数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir zkdata<br></code></pre></td></tr></table></figure><p>dataDir改为&#x2F;usr&#x2F;local&#x2F;src&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.10&#x2F;conf&#x2F;zkdata<br>重新上传zoo.cfg</p><h1 id="6-启动zookeeper"><a href="#6-启动zookeeper" class="headerlink" title="6. 启动zookeeper"></a>6. 启动zookeeper</h1><p>进入zookeeper的bin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./zkServer.sh start<br></code></pre></td></tr></table></figure><p>启动成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 bin]# ./zkServer.sh start<br>/usr/bin/java<br>ZooKeeper JMX enabled by default<br>Using config: /usr/local/src/zookeeper/apache-zookeeper-3.5.10/bin/../conf/zoo.cfg<br>Starting zookeeper ... STARTED<br></code></pre></td></tr></table></figure><p>查看状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./zkServer.sh status<br></code></pre></td></tr></table></figure><p>关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./zkServer.sh stop<br></code></pre></td></tr></table></figure><h1 id="2-Docker安装"><a href="#2-Docker安装" class="headerlink" title="2. Docker安装"></a>2. Docker安装</h1><h1 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h1><p>java8以上，docker</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><p>查看zookeeper版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search zookeeper<br></code></pre></td></tr></table></figure><p>下载最新版本，可以指定版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull zookeeper:latest<br></code></pre></td></tr></table></figure><p>创建挂载数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /root/docker/zookeeper/data<br></code></pre></td></tr></table></figure><h1 id="3-启动容器"><a href="#3-启动容器" class="headerlink" title="3. 启动容器"></a>3. 启动容器</h1><p>查看zookeeper镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 2181:2181 -v /root/docker/zookeeper/data:/data/ --name zookeeper --privileged 36c607e7b14d<br></code></pre></td></tr></table></figure><p>参数说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">-d # 表示在一直在后台运行容器<br>-p 2181:2181 # 对端口进行映射，将本地2181端口映射到容器内部的2181端口<br>--name # 设置创建的容器名称<br>-v # 将本地目录挂载到容器指定目录；<br>--privileged  # 镜像id或者镜像名称也可以 <br></code></pre></td></tr></table></figure><h1 id="4-查看启动"><a href="#4-查看启动" class="headerlink" title="4. 查看启动"></a>4. 查看启动</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps<br></code></pre></td></tr></table></figure><h1 id="5-进入容器"><a href="#5-进入容器" class="headerlink" title="5. 进入容器"></a>5. 进入容器</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it 069a2219323c /bin/bash<br></code></pre></td></tr></table></figure><p>中间id是容器id</p><p>进入bin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd bin<br><br></code></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./zkCli.sh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
      <tag>安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC远程调用</title>
    <link href="/post/56a27354.html"/>
    <url>/post/56a27354.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-RPC的作用？"><a href="#1-RPC的作用？" class="headerlink" title="1. RPC的作用？"></a>1. RPC的作用？</h1><p>调用远程方法像调用本地方法一样。<br>RPC向服务器发送请求不一定要使用HTTP协议，比如TCP&#x2F;IP等等。<br><img src="/images/rpcycdy-1.png" alt="img.png"></p><h1 id="2-RPC实现框架"><a href="#2-RPC实现框架" class="headerlink" title="2. RPC实现框架"></a>2. RPC实现框架</h1><p>Dubbo(阿里，推荐，整合好)<br>GRPC(谷歌)<br>TRPC(腾讯)<br>Motan(新浪)</p><h1 id="3-Dubbo文档"><a href="#3-Dubbo文档" class="headerlink" title="3. Dubbo文档"></a>3. Dubbo文档</h1><p><a href="https://cn.dubbo.apache.org/zh-cn/overview/quickstart/">https://cn.dubbo.apache.org/zh-cn/overview/quickstart/</a></p><h1 id="4-Dubbo使用"><a href="#4-Dubbo使用" class="headerlink" title="4. Dubbo使用"></a>4. Dubbo使用</h1><p>需要新建三个项目<br><img src="/images/rpcycdy-2.png" alt="img.png"><br>分别是调用方consumer，被调用方provider，接口interface<br>先引入官方demo查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/apache/dubbo-samples.git<br></code></pre></td></tr></table></figure><p>需要先启动zookeeper<br>进入bin目录 .&#x2F;zkServer.sh start</p><h1 id="5-自定义Dubbo-nacos"><a href="#5-自定义Dubbo-nacos" class="headerlink" title="5. 自定义Dubbo+nacos"></a>5. 自定义Dubbo+nacos</h1><p>为什么不使用，使用zookeeper需要添加额外的配置，一般是使用3个，这里我只使用一个注册中心，使用Nacos完全足够<br>需要安装nacos<br>nacos在windows单机启动命令startup.cmd -m standalone</p><p>客户端服务端都需要引入依赖，一定要引入guava的包，否则会报错</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.nacos<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加配置,服务端，客户端都一样的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo-api-platform-backend-provider</span><br>  <span class="hljs-attr">protocol:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">-1</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">id:</span> <span class="hljs-string">nacos-registry</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">nacos://localhost:8848</span><br></code></pre></td></tr></table></figure><p>启动类上都要添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableDubbo</span><br></code></pre></td></tr></table></figure><p>写一个通用接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DemoService</span> &#123;<br><br>    String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>;<br><br>    String <span class="hljs-title function_">sayHello2</span><span class="hljs-params">(String name)</span>;<br><br>    <span class="hljs-keyword">default</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">sayHelloAsync</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(sayHello(name));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现接口服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DemoService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + name + <span class="hljs-string">&quot;, request from consumer: &quot;</span> + RpcContext.getContext().getRemoteAddress());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello2</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fly&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableDubbo</span><br><span class="hljs-comment">// 禁用数据库</span><br><span class="hljs-meta">@SpringBootApplication( exclude = &#123;</span><br><span class="hljs-meta">        DataSourceAutoConfiguration.class,</span><br><span class="hljs-meta">        DataSourceTransactionManagerAutoConfiguration.class,</span><br><span class="hljs-meta">        HibernateJpaAutoConfiguration.class</span><br><span class="hljs-meta">&#125; )</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyApiGatewayApplication</span> &#123;<br>    <span class="hljs-meta">@DubboReference</span><br>    <span class="hljs-keyword">private</span> DemoService demoService;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(FlyApiGatewayApplication.class, args);<br>        <span class="hljs-type">FlyApiGatewayApplication</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> context.getBean(FlyApiGatewayApplication.class);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> application.doSayHello(<span class="hljs-string">&quot;world&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> application.doSayHello2(<span class="hljs-string">&quot;world&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + result);<br>        System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + result2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doSayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> demoService.sayHello(name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doSayHello2</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> demoService.sayHello2(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动项目<br>服务端<br><img src="/images/rpcycdy-4.png" alt="img_1.png"><br>客户端<br><img src="/images/rpcycdy-5.png" alt="img_2.png"></p>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloudGateway全局过滤器</title>
    <link href="/post/c8b4bc85.html"/>
    <url>/post/c8b4bc85.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Api整合网关步骤"><a href="#1-Api整合网关步骤" class="headerlink" title="1. Api整合网关步骤"></a>1. Api整合网关步骤</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">default-filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddResponseHeader=source,fly</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">api_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:7530</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/**</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 用户发送请求到API网关</span><br><span class="hljs-comment">// yml 已经配置好了</span><br><span class="hljs-comment">// 2. 请求日志</span><br><span class="hljs-comment">// 3. 黑白名单</span><br><span class="hljs-comment">// 4. 用户鉴权</span><br><span class="hljs-comment">// 5. 请求模拟接口是否存在</span><br><span class="hljs-comment">// 6. 响应日志</span><br><span class="hljs-comment">// 7. 调用成功，接口调用次数+1</span><br><span class="hljs-comment">// 8. 调用失败，错误码</span><br></code></pre></td></tr></table></figure><h1 id="1-先引入官方过滤器"><a href="#1-先引入官方过滤器" class="headerlink" title="1. 先引入官方过滤器"></a>1. 先引入官方过滤器</h1><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#global-filters">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#global-filters</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;custom global filter&quot;</span>);<br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-全局日志"><a href="#2-全局日志" class="headerlink" title="2. 全局日志"></a>2. 全局日志</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>log.info(<span class="hljs-string">&quot;请求唯一标识=&gt;&quot;</span> + request.getId());<br>log.info(<span class="hljs-string">&quot;请求方法=&gt;&quot;</span> + request.getMethod());<br>log.info(<span class="hljs-string">&quot;请求来源地址=&gt;&quot;</span> + request.getLocalAddress().getHostString());<br>log.info(<span class="hljs-string">&quot;请求参数=&gt;&quot;</span> + request.getQueryParams());<br>log.info(<span class="hljs-string">&quot;请求路径&quot;</span> + request.getPath().value());<br><span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br></code></pre></td></tr></table></figure><h1 id="3-黑白名单"><a href="#3-黑白名单" class="headerlink" title="3. 黑白名单"></a>3. 黑白名单</h1><p>首先需要定义一个白名单范围<br>0:0:0:0:0:0:0:1代表localhost</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; WHIT_LIST = Arrays.asList(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;0:0:0:0:0:0:0:1&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> request.getLocalAddress().getHostString();<br>      <span class="hljs-keyword">if</span> (!WHIT_LIST.contains(address))&#123;<br>          response.setStatusCode(HttpStatus.FORBIDDEN);<br>          <span class="hljs-comment">// 结束任务</span><br>          <span class="hljs-keyword">return</span> response.setComplete();<br>      &#125;<br></code></pre></td></tr></table></figure><h1 id="4-用户鉴权"><a href="#4-用户鉴权" class="headerlink" title="4. 用户鉴权"></a>4. 用户鉴权</h1><p>这里面的的SignUtils在API自定义stater里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> request.getHeaders();<br><span class="hljs-type">String</span> <span class="hljs-variable">accessKey</span> <span class="hljs-operator">=</span> headers.getFirst(<span class="hljs-string">&quot;accessKey&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">nonce</span> <span class="hljs-operator">=</span> headers.getFirst(<span class="hljs-string">&quot;nonce&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> headers.getFirst(<span class="hljs-string">&quot;timestamp&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> headers.getFirst(<span class="hljs-string">&quot;sign&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> headers.getFirst(<span class="hljs-string">&quot;body&quot;</span>);<br><br><span class="hljs-comment">// 1. todo 使用数据库查询时候是有这个用户</span><br><span class="hljs-keyword">if</span> (!Objects.equals(accessKey, <span class="hljs-string">&quot;5a8bd83a0019aea1b4caa846bac07426&quot;</span>)) &#123;<br>    <span class="hljs-keyword">return</span> handlerNoAuth(response);<br>&#125;<br><br><span class="hljs-comment">//  2. todo 随机数，采用hashmap或者redis进行存储</span><br><span class="hljs-keyword">if</span> (nonce == <span class="hljs-literal">null</span> || Long.parseLong(nonce) &gt; <span class="hljs-number">100000</span>) &#123;<br>    <span class="hljs-keyword">return</span> handlerNoAuth(response);<br>&#125;<br><br><span class="hljs-comment">// 3. todo 校验时间不能超过5min</span><br><span class="hljs-keyword">if</span> (timestamp != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis() / <span class="hljs-number">1000</span> - Long.parseLong(timestamp);<br>    <span class="hljs-keyword">if</span> (time / <span class="hljs-number">1000</span> &gt; FIVE_MINUTES) &#123;<br>        <span class="hljs-keyword">return</span> handlerNoAuth(response);<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> handlerNoAuth(response);<br>&#125;<br><br><span class="hljs-comment">// 4. todo 校验body,实际请求是从数据库获取的</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">signServer</span> <span class="hljs-operator">=</span> SignUtils.genSign(body, <span class="hljs-string">&quot;b55db76db7b87adac5df9215dc0afcb8&quot;</span>);<br><span class="hljs-keyword">if</span> (!Objects.equals(sign, signServer)) &#123;<br>    <span class="hljs-keyword">return</span> handlerNoAuth(response);<br>&#125;<br><span class="hljs-comment">// todo 调用次数+1</span><br><br></code></pre></td></tr></table></figure><h1 id="5-调用失败"><a href="#5-调用失败" class="headerlink" title="5. 调用失败"></a>5. 调用失败</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (response.getStatusCode() != HttpStatus.OK) &#123;<br>     <span class="hljs-keyword">return</span> handlerInvokeError(response);<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="6-现在存在的问题"><a href="#6-现在存在的问题" class="headerlink" title="6. 现在存在的问题"></a>6. 现在存在的问题</h1><p>由于Mono是异步的，原本是需要经过调用完成模拟接口，才会响应，统计次数，但是chain.filter立即返回了，直到filter返回了才调用接口。</p><h1 id="7-解决方案"><a href="#7-解决方案" class="headerlink" title="7. 解决方案"></a>7. 解决方案</h1><p>通过response装饰者模式增强原有能力<br>相应日志，需要的时候就查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Mono&lt;Void&gt; <span class="hljs-title function_">handleResponse</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain, <span class="hljs-type">long</span> interfaceInfoId, <span class="hljs-type">long</span> userId)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 从交换机拿到原始response</span><br>            <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">originalResponse</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>            <span class="hljs-comment">// 缓冲区工厂 拿到缓存数据</span><br>            <span class="hljs-type">DataBufferFactory</span> <span class="hljs-variable">bufferFactory</span> <span class="hljs-operator">=</span> originalResponse.bufferFactory();<br>            <span class="hljs-comment">// 拿到状态码</span><br>            <span class="hljs-type">HttpStatus</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> originalResponse.getStatusCode();<br>            <span class="hljs-keyword">if</span> (statusCode == HttpStatus.OK) &#123;<br>                <span class="hljs-comment">// 装饰，增强能力</span><br>                <span class="hljs-type">ServerHttpResponseDecorator</span> <span class="hljs-variable">decoratedResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerHttpResponseDecorator</span>(originalResponse) &#123;<br>                    <span class="hljs-comment">// 等调用完转发的接口后才会执行</span><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">writeWith</span><span class="hljs-params">(Publisher&lt;? extends DataBuffer&gt; body)</span> &#123;<br>                        log.info(<span class="hljs-string">&quot;body instanceof Flux: &#123;&#125;&quot;</span>, (body <span class="hljs-keyword">instanceof</span> Flux));<br>                        <span class="hljs-comment">// 对象是响应式的</span><br>                        <span class="hljs-keyword">if</span> (body <span class="hljs-keyword">instanceof</span> Flux) &#123;<br>                            <span class="hljs-comment">// 我们拿到真正的body</span><br>                            Flux&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DataBuffer</span>&gt; fluxBody = Flux.from(body);<br>                            <span class="hljs-comment">// 往返回值里面写数据</span><br>                            <span class="hljs-comment">// 拼接字符串</span><br>                            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.writeWith(fluxBody.map(dataBuffer -&gt; &#123;<br>                                <span class="hljs-comment">// todo 7. 调用成功，接口调用次数+1</span><br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-comment">//innerUserInterfaceInfoService.invokeCount(interfaceInfoId, userId);</span><br>                                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                                    log.error(<span class="hljs-string">&quot;invoke count error&quot;</span>, e);<br>                                &#125;<br>                                <span class="hljs-comment">// data从这个content中读取</span><br>                                <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[dataBuffer.readableByteCount()];<br>                                dataBuffer.read(content);<br>                                DataBufferUtils.release(dataBuffer);<span class="hljs-comment">// 释放掉内存</span><br>                                <span class="hljs-comment">// 6.构建日志</span><br>                                List&lt;Object&gt; rspArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                                rspArgs.add(originalResponse.getStatusCode());<br>                                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content, StandardCharsets.UTF_8);<span class="hljs-comment">// data</span><br>                                rspArgs.add(data);<br>                                log.info(<span class="hljs-string">&quot;&lt;--- status:&#123;&#125; data:&#123;&#125;&quot;</span><span class="hljs-comment">// data</span><br>                                        , rspArgs.toArray());<span class="hljs-comment">// log.info(&quot;&lt;-- &#123;&#125; &#123;&#125;&quot;, originalResponse.getStatusCode(), data);</span><br>                                log.info(<span class="hljs-string">&quot;响应结果&quot;</span> + data);<br>                                <span class="hljs-keyword">return</span> bufferFactory.wrap(content);<br>                            &#125;));<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">// 8.调用失败返回错误状态码</span><br>                            log.error(<span class="hljs-string">&quot;&lt;--- &#123;&#125; 响应code异常&quot;</span>, getStatusCode());<br>                        &#125;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.writeWith(body);<br>                    &#125;<br>                &#125;;<br>                <span class="hljs-comment">// 设置 response 对象为装饰过的</span><br>                <span class="hljs-keyword">return</span> chain.filter(exchange.mutate().response(decoratedResponse).build());<br>            &#125;<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<span class="hljs-comment">// 降级处理返回数据</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;gateway log exception.\n&quot;</span> + e);<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br></code></pre></td></tr></table></figure><h1 id="8-总体"><a href="#8-总体" class="headerlink" title="8. 总体"></a>8. 总体</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br>    <span class="hljs-comment">// 白名单</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; WHIT_LIST = Arrays.asList(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-string">&quot;0:0:0:0:0:0:0:1&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span> <span class="hljs-variable">FIVE_MINUTES</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">5L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 响应交互</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chain    过滤链</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Mono</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br><br>        <span class="hljs-comment">// 1. 用户发送请求到API网关</span><br>        <span class="hljs-comment">// yml 已经配置好了</span><br><br>        <span class="hljs-comment">// 2. 请求日志</span><br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>        log.info(<span class="hljs-string">&quot;请求唯一标识=&gt;&quot;</span> + request.getId());<br>        log.info(<span class="hljs-string">&quot;请求方法=&gt;&quot;</span> + request.getMethod());<br>        log.info(<span class="hljs-string">&quot;请求来源地址=&gt;&quot;</span> + Objects.requireNonNull(request.getLocalAddress()).getHostString());<br>        log.info(<span class="hljs-string">&quot;请求参数=&gt;&quot;</span> + request.getQueryParams());<br>        log.info(<span class="hljs-string">&quot;请求路径&quot;</span> + request.getPath().value());<br>        <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>        <span class="hljs-comment">// 3. 黑白名单</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> request.getLocalAddress().getHostString();<br>        <span class="hljs-keyword">if</span> (!WHIT_LIST.contains(address)) &#123;<br>            response.setStatusCode(HttpStatus.FORBIDDEN);<br>            <span class="hljs-comment">// 结束任务</span><br>            <span class="hljs-keyword">return</span> response.setComplete();<br>        &#125;<br><br>        <span class="hljs-comment">// 4. 用户鉴权</span><br>        <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> request.getHeaders();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">accessKey</span> <span class="hljs-operator">=</span> headers.getFirst(<span class="hljs-string">&quot;accessKey&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">nonce</span> <span class="hljs-operator">=</span> headers.getFirst(<span class="hljs-string">&quot;nonce&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> headers.getFirst(<span class="hljs-string">&quot;timestamp&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> headers.getFirst(<span class="hljs-string">&quot;sign&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> headers.getFirst(<span class="hljs-string">&quot;body&quot;</span>);<br><br>        <span class="hljs-comment">// 1. todo 使用数据库查询时候是有这个用户</span><br>        <span class="hljs-keyword">if</span> (!Objects.equals(accessKey, <span class="hljs-string">&quot;5a8bd83a0019aea1b4caa846bac07426&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> handlerNoAuth(response);<br>        &#125;<br><br>        <span class="hljs-comment">//  2. todo 随机数，采用hashmap或者redis进行存储</span><br>        <span class="hljs-keyword">if</span> (nonce == <span class="hljs-literal">null</span> || Long.parseLong(nonce) &gt; <span class="hljs-number">100000</span>) &#123;<br>            <span class="hljs-keyword">return</span> handlerNoAuth(response);<br>        &#125;<br><br>        <span class="hljs-comment">// 3. todo 校验时间不能超过5min</span><br>        <span class="hljs-keyword">if</span> (timestamp != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis() / <span class="hljs-number">1000</span> - Long.parseLong(timestamp);<br>            <span class="hljs-keyword">if</span> (time / <span class="hljs-number">1000</span> &gt; FIVE_MINUTES) &#123;<br>                <span class="hljs-keyword">return</span> handlerNoAuth(response);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> handlerNoAuth(response);<br>        &#125;<br><br>        <span class="hljs-comment">// 4. todo 校验body,实际请求是从数据库获取的</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">signServer</span> <span class="hljs-operator">=</span> SignUtils.genSign(body, <span class="hljs-string">&quot;b55db76db7b87adac5df9215dc0afcb8&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!Objects.equals(sign, signServer)) &#123;<br>            <span class="hljs-keyword">return</span> handlerNoAuth(response);<br>        &#125;<br>        <span class="hljs-comment">// todo 调用次数+1</span><br><br><br>        <span class="hljs-comment">// 5. 请求模拟接口是否存在</span><br>        <span class="hljs-comment">// todo 数据库查询模拟接口是否存在，检验请求参数，方法是否一致</span><br><br>        <span class="hljs-comment">// 6. 响应日志</span><br>        log.info(<span class="hljs-string">&quot;响应码=&gt;&quot;</span> + response.getStatusCode());<br>        <span class="hljs-keyword">return</span>  handleResponse(exchange,chain);<br>        <span class="hljs-comment">// 7. 调用成功，接口调用次数+1</span><br>        <span class="hljs-comment">// todo 调用接口</span><br><br><br>        <span class="hljs-comment">// 8. 调用失败，错误码</span><br><span class="hljs-comment">//        if (response.getStatusCode() != HttpStatus.OK) &#123;</span><br><span class="hljs-comment">//            return handlerInvokeError(response);</span><br><span class="hljs-comment">//        &#125;</span><br><br><span class="hljs-comment">//        log.info(&quot;custom global filter&quot;);</span><br><span class="hljs-comment">//        return chain.filter(exchange);</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理异常，判断是否有权限</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">handlerNoAuth</span><span class="hljs-params">(ServerHttpResponse response)</span> &#123;<br>        response.setStatusCode(HttpStatus.FORBIDDEN);<br>        <span class="hljs-keyword">return</span> response.setComplete();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用接口失败</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">handlerInvokeError</span><span class="hljs-params">(ServerHttpResponse response)</span> &#123;<br>        response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);<br>        <span class="hljs-keyword">return</span> response.setComplete();<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> Mono&lt;Void&gt; <span class="hljs-title function_">handleResponse</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 从交换机拿到原始response</span><br>            <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">originalResponse</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>            <span class="hljs-comment">// 缓冲区工厂 拿到缓存数据</span><br>            <span class="hljs-type">DataBufferFactory</span> <span class="hljs-variable">bufferFactory</span> <span class="hljs-operator">=</span> originalResponse.bufferFactory();<br>            <span class="hljs-comment">// 拿到状态码</span><br>            <span class="hljs-type">HttpStatus</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> originalResponse.getStatusCode();<br>            <span class="hljs-keyword">if</span> (statusCode == HttpStatus.OK) &#123;<br>                <span class="hljs-comment">// 装饰，增强能力</span><br>                <span class="hljs-type">ServerHttpResponseDecorator</span> <span class="hljs-variable">decoratedResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerHttpResponseDecorator</span>(originalResponse) &#123;<br>                    <span class="hljs-comment">// 等调用完转发的接口后才会执行</span><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">writeWith</span><span class="hljs-params">(Publisher&lt;? extends DataBuffer&gt; body)</span> &#123;<br>                        log.info(<span class="hljs-string">&quot;body instanceof Flux: &#123;&#125;&quot;</span>, (body <span class="hljs-keyword">instanceof</span> Flux));<br>                        <span class="hljs-comment">// 对象是响应式的</span><br>                        <span class="hljs-keyword">if</span> (body <span class="hljs-keyword">instanceof</span> Flux) &#123;<br>                            <span class="hljs-comment">// 我们拿到真正的body</span><br>                            Flux&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DataBuffer</span>&gt; fluxBody = Flux.from(body);<br>                            <span class="hljs-comment">// 往返回值里面写数据</span><br>                            <span class="hljs-comment">// 拼接字符串</span><br>                            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.writeWith(fluxBody.map(dataBuffer -&gt; &#123;<br>                                <span class="hljs-comment">// todo 7. 调用成功，接口调用次数+1</span><br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-comment">//innerUserInterfaceInfoService.invokeCount(interfaceInfoId, userId);</span><br>                                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                                    log.error(<span class="hljs-string">&quot;invoke count error&quot;</span>, e);<br>                                &#125;<br>                                <span class="hljs-comment">// data从这个content中读取</span><br>                                <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[dataBuffer.readableByteCount()];<br>                                dataBuffer.read(content);<br>                                DataBufferUtils.release(dataBuffer);<span class="hljs-comment">// 释放掉内存</span><br>                                <span class="hljs-comment">// 6.构建日志</span><br>                                List&lt;Object&gt; rspArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                                rspArgs.add(originalResponse.getStatusCode());<br>                                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content, StandardCharsets.UTF_8);<span class="hljs-comment">// data</span><br>                                rspArgs.add(data);<br>                                log.info(<span class="hljs-string">&quot;&lt;--- status:&#123;&#125; data:&#123;&#125;&quot;</span><span class="hljs-comment">// data</span><br>                                        , rspArgs.toArray());<span class="hljs-comment">// log.info(&quot;&lt;-- &#123;&#125; &#123;&#125;&quot;, originalResponse.getStatusCode(), data);</span><br>                                log.info(<span class="hljs-string">&quot;响应结果&quot;</span> + data);<br>                                <span class="hljs-keyword">return</span> bufferFactory.wrap(content);<br>                            &#125;));<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">// 8.调用失败返回错误状态码</span><br>                            log.error(<span class="hljs-string">&quot;&lt;--- &#123;&#125; 响应code异常&quot;</span>, getStatusCode());<br>                        &#125;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.writeWith(body);<br>                    &#125;<br>                &#125;;<br>                <span class="hljs-comment">// 设置 response 对象为装饰过的</span><br>                <span class="hljs-keyword">return</span> chain.filter(exchange.mutate().response(decoratedResponse).build());<br>            &#125;<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<span class="hljs-comment">// 降级处理返回数据</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;gateway log exception.\n&quot;</span> + e);<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringCloudGateway</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloudGateway</tag>
      
      <tag>Api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis面试题-1</title>
    <link href="/post/93a5a64.html"/>
    <url>/post/93a5a64.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-和-区别"><a href="#1-和-区别" class="headerlink" title="1. #{}和${}区别"></a>1. #{}和${}区别</h1><p>${}是Properties文件的变量占位符，静态文本替换，容易出现sql注入<br>\ #{}是sql的参数占位符，将参数替换为?，可以防止sql注入。sql执行前会使用PreparedStatement，使用反射从参数对象获取item的相关值</p><h1 id="2-XML映射文件，除了常见的select，insert，update，delete，还有哪些标签。"><a href="#2-XML映射文件，除了常见的select，insert，update，delete，还有哪些标签。" class="headerlink" title="2. XML映射文件，除了常见的select，insert，update，delete，还有哪些标签。"></a>2. XML映射文件，除了常见的select，insert，update，delete，还有哪些标签。</h1><ol><li><ResultMap></ResultMap></li><li><ParamaterMap></ParamaterMap></li><li><sql> sql的片段标签</sql></li><li><include> 标签引入sql片段</include></li><li><selectKey> 为不支持自增的主键生成策略标签</selectKey></li><li>动态sql：trim|where|set|foreach|if|when|choose|otherwise|bind</li></ol><h1 id="3-Dao的工作原理是什么？Dao接口里面的方法，参数不同时，方法能够重载吗？"><a href="#3-Dao的工作原理是什么？Dao接口里面的方法，参数不同时，方法能够重载吗？" class="headerlink" title="3. Dao的工作原理是什么？Dao接口里面的方法，参数不同时，方法能够重载吗？"></a>3. Dao的工作原理是什么？Dao接口里面的方法，参数不同时，方法能够重载吗？</h1><ul><li>通常一个xml映射文件，都会写一个dao接口与之对应，就是常说的mapper。</li><li>接口的全限名就是映射文件的namespace的值</li><li>接口的方法就是映射文件里面的MappedStatement的id值</li><li>接口内的参数就是传递给sql的参数。</li><li>mapper接口是没有实现类的，调用接口方法时，接口全限名+方法名拼接字符串作为key的值，可以定位到唯一的mappedstatement。</li></ul><p>Mybatis的Dao可以重载方法，但是多个接口对应的映射文件只能有一个。<br>仅有一个有参，无参。多个有参，参数必须一致使用@Param</p><p>Dao的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象会拦截接口方法，执行MappedStatement里面对应的sql，返回sql结果。</p><h1 id="4-MyBatis是如何进行分页的？分页插件原理是什么？"><a href="#4-MyBatis是如何进行分页的？分页插件原理是什么？" class="headerlink" title="4. MyBatis是如何进行分页的？分页插件原理是什么？"></a>4. MyBatis是如何进行分页的？分页插件原理是什么？</h1><ol><li>使用RowBounds对象进行分页，针对ResultSet结果集执行的内存分页，而不是物理分页。</li><li>sql内直接写带有物理分页的参数</li><li>分页插件<br>原理：Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截等待执行的sql，然后重写sql，添加对应的分页语句和物理分页参数</li></ol><h1 id="5-Mybatis的插件运行原理？"><a href="#5-Mybatis的插件运行原理？" class="headerlink" title="5. Mybatis的插件运行原理？"></a>5. Mybatis的插件运行原理？</h1><p>Mybatis使用的JDK动态代理，为需要拦截的接口生成代理对象以及拦截方法，当执行四种接口（三个Handler，Executor）指定的方法时候，就会进入拦截方法，调用invoke方法<br>编写插件方法：实现Mybatis的Interceptor接口并复写intercept方法，指定拦截哪些接口的方法。</p><h1 id="6-Mybatis是否支持延迟加载？"><a href="#6-Mybatis是否支持延迟加载？" class="headerlink" title="6. Mybatis是否支持延迟加载？"></a>6. Mybatis是否支持延迟加载？</h1><p>Mybatis仅支持association（一对一）关联对象和collection（一对多）关联集合对象的延迟加载。Mybatis配置中，可以使用lazyLoadingEnabled开启延迟加载。<br>原理是：使用CGLIB创建目标对象的代理对象，调用方法，进入拦截器方法，比如调用a.getB().getName(), 如果a.getB()是null，那么就会单独发送实现保存好的查询关联B的对象的sql，然后调用a.setB(b), 然后再查询。<br>总结：使用到数据的时候才开始查询</p><h1 id="7-Mybatis都有哪些Executor执行器，区别是什么？"><a href="#7-Mybatis都有哪些Executor执行器，区别是什么？" class="headerlink" title="7. Mybatis都有哪些Executor执行器，区别是什么？"></a>7. Mybatis都有哪些Executor执行器，区别是什么？</h1><ol><li>SimpleExecutor: 每执行一次update，select语句，开启一个statement对象，用完立即关闭statement对象</li><li>ReuseExecutor：执行update，select，将sql作为key，查找statement对象，如果不存在，就创建，存在就调用之前的，不会关闭statement对象，存储在map里面</li><li>BatchExecutor：执行update语句，将所有的sql都添加到批处理中，等待统一执行，缓存了多个statement对象</li></ol><h1 id="8-为什么Mybatis是半自动ORM映射工具？和全自动的区别在哪里？"><a href="#8-为什么Mybatis是半自动ORM映射工具？和全自动的区别在哪里？" class="headerlink" title="8. 为什么Mybatis是半自动ORM映射工具？和全自动的区别在哪里？"></a>8. 为什么Mybatis是半自动ORM映射工具？和全自动的区别在哪里？</h1><p>Hibernate 是全自动ORM工具，使用Hibernate查询关联对象，可以根据对象模型直接获取，所以是全自动的。<br>Mybatis查询关联对象的时候，需要手动编写sql语句来执行。</p><h1 id="9-Mybatis的xml映射文件和Mybatis内部数据结构之间的映射关系。"><a href="#9-Mybatis的xml映射文件和Mybatis内部数据结构之间的映射关系。" class="headerlink" title="9. Mybatis的xml映射文件和Mybatis内部数据结构之间的映射关系。"></a>9. Mybatis的xml映射文件和Mybatis内部数据结构之间的映射关系。</h1><p>mybatis会将所有的xml信息分装到All-in-One重量级对象Configuration内部。<br>在xml映射文件中，会将<parameterMap>解析成为ParameterMap对象，每个子对象都会被解析成ParameterMapping对象。<br><resultMap>解析为ResultMap对象，每个子对象都会被解析成ResultMapping对象。<br>每一个<select><update><delete><insert>都会被解析成为MappedStatement对象，标签内的sql都会被解析成为BoundSql对象。</insert></delete></update></select></resultMap></parameterMap></p><h1 id="10-Mybatis是否可以映射枚举类？"><a href="#10-Mybatis是否可以映射枚举类？" class="headerlink" title="10. Mybatis是否可以映射枚举类？"></a>10. Mybatis是否可以映射枚举类？</h1><p>可以，Mybatis可以映射任何对象到表的一列上。<br>映射方式为自定义一个TypeHandler，实现setParameter()和getResult()接口方法。<br>TypeHandler的作用：</p><ol><li>完成javaType到jdbcType转换</li><li>jdbcType到javaType的转换</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloudGateway使用</title>
    <link href="/post/b4aab894.html"/>
    <url>/post/b4aab894.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-官网"><a href="#1-官网" class="headerlink" title="1. 官网"></a>1. 官网</h1><p><a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></p><h1 id="2-引入依赖"><a href="#2-引入依赖" class="headerlink" title="2. 引入依赖"></a>2. 引入依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--gateway--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--lombok--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="4-查看文档"><a href="#4-查看文档" class="headerlink" title="4. 查看文档"></a>4. 查看文档</h1><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/</a><br>yml开启所有等级的日志</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">org:</span><br>      <span class="hljs-attr">springframework:</span><br>        <span class="hljs-attr">cloud:</span><br>          <span class="hljs-attr">gateway:</span> <span class="hljs-string">trace</span><br></code></pre></td></tr></table></figure><h1 id="5-核心概念"><a href="#5-核心概念" class="headerlink" title="5. 核心概念"></a>5. 核心概念</h1><h2 id="1-路由-route"><a href="#1-路由-route" class="headerlink" title="1. 路由 route"></a>1. 路由 route</h2><p>根据什么断言条件转发到哪里</p><h2 id="2-断言-Predicate"><a href="#2-断言-Predicate" class="headerlink" title="2. 断言 Predicate"></a>2. 断言 Predicate</h2><p>一组规则，条件如何转发路由</p><h2 id="3-过滤-filter"><a href="#3-过滤-filter" class="headerlink" title="3. 过滤 filter"></a>3. 过滤 filter</h2><p>对请求集中处理</p><p><img src="/images/scgwu-1.png" alt="img.png"></p><ol><li>客户端发送请求</li><li>Handler Mapping：根据断言转发请求</li><li>Web Handler： 实际处理请求（经过过滤器）</li><li>Service：调用服务</li></ol><p>方式</p><ol><li>配置式（推荐）<ol><li>简化版： shortcut</li><li>完全版： Fully</li></ol></li><li>编程式</li></ol><h1 id="5-使用"><a href="#5-使用" class="headerlink" title="5. 使用"></a>5. 使用</h1><h2 id="5-1-断言Predicate"><a href="#5-1-断言Predicate" class="headerlink" title="5.1 断言Predicate"></a>5.1 断言Predicate</h2><p>After Route&#x2F;Before Route<br>5.1.1当前请求的时间在指定日期之后&#x2F;之前</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">after_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">https://www.baidu.com</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">After=2023-07-29T17:42:47.789-07:00[Asia/Shanghai]</span><br></code></pre></td></tr></table></figure><p><img src="/images/scgwu-2.png" alt="img.png"></p><p>5.1.2 Between 在一段时间内</p><p>5.1.3 Method route 拦截相应的方法，比如get</p><p>5.1.4 cookie route 请求cookie</p><p>5.1.5 Header route 请求头</p><p>5.1.6 Path route  路由断言</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>  <span class="hljs-attr">uri:</span> <span class="hljs-string">https://www.baidu.com</span><br>  <span class="hljs-attr">predicates:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/**,</span><br></code></pre></td></tr></table></figure><p>5.1.7 Weight route 权重断言 （灰度发布）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">weight_high</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://weighthigh.org</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Weight=group1,</span> <span class="hljs-number">8</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">weight_low</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://weightlow.org</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Weight=group1,</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>5.1.8 RemoteAddr route 根据远程地址转发</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">remoteaddr_route</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">RemoteAddr=192.168.1.1/24</span><br></code></pre></td></tr></table></figure><h2 id="5-2-拦截器"><a href="#5-2-拦截器" class="headerlink" title="5.2 拦截器"></a>5.2 拦截器</h2><p>5.2.1 添加请求头 AddRequestHeader<br>添加一个新项目接口，添加request请求头,当前端口7530，请求路径&#x2F;api</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping( &quot;/name&quot; )</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NameController</span> &#123;<br><br>   <span class="hljs-meta">@GetMapping( &quot;/&quot; )</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByGet</span><span class="hljs-params">(String name, HttpServletRequest request)</span> &#123;<br>      System.out.println(request.getHeader(<span class="hljs-string">&quot;fly&quot;</span>));<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;get your name=&gt;&quot;</span> + name;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置xml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">add_header</span><br>  <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:7530</span><br>  <span class="hljs-attr">predicates:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">Path=</span> <span class="hljs-string">/api/**</span><br>  <span class="hljs-attr">filters:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=fly,swag</span><br></code></pre></td></tr></table></figure><p><img src="/images/scgwu-3.png" alt="img_1.png"></p><p>5.2.2 AddRequestParameter 添加参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">add_header</span><br>  <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:7530</span><br>  <span class="hljs-attr">predicates:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Path=</span> <span class="hljs-string">/api/name/**</span><br>  <span class="hljs-attr">filters:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=fly,swag</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestParameter=name,</span> <span class="hljs-string">fly1</span><br></code></pre></td></tr></table></figure><p><img src="/images/scgwu-4.png" alt="img_2.png"></p><p>5.2.3 CircuitBreaker 断路器，降级<br>当一个接口离线了，可以请求其他接口<br>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-circuitbreaker-reactor-resilience4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">add_header</span><br>  <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:7530</span><br>  <span class="hljs-attr">predicates:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">Path=</span> <span class="hljs-string">/api/name/**</span><br>  <span class="hljs-attr">filters:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=fly,swag</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestParameter=name,</span> <span class="hljs-string">fly1</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CircuitBreaker</span><br>       <span class="hljs-attr">args:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">fetchIngredients</span><br>          <span class="hljs-attr">fallbackUri:</span> <span class="hljs-string">forward:/fallback</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">ingredients-fallback</span><br>  <span class="hljs-attr">uri:</span> <span class="hljs-string">https://www.baidu.com</span><br>  <span class="hljs-attr">predicates:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/fallback</span><br><br></code></pre></td></tr></table></figure><p>5.2.4 限流 RequestRateLimiter （推荐redis限流）<br>令牌桶算法，漏斗，redis限流器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">requestratelimiter_route</span><br>    <span class="hljs-attr">uri:</span> <span class="hljs-string">https://www.baidu.com</span><br>    <span class="hljs-attr">filters:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">RequestRateLimiter</span><br>        <span class="hljs-attr">args:</span><br>          <span class="hljs-attr">redis-rate-limiter.replenishRate:</span> <span class="hljs-number">10</span><br>          <span class="hljs-attr">redis-rate-limiter.burstCapacity:</span> <span class="hljs-number">20</span><br>          <span class="hljs-attr">redis-rate-limiter.requestedTokens:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>5.2.5 限制请求头 RequestHeaderSize </p><p>5.2.6  StripPrefix 去除部分接口部分，例如&#x2F;name&#x2F;user&#x2F;red,去除两个部分变成&#x2F;red</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">nameRoot</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://nameservice</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/name/**</span><br>        <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=2</span><br></code></pre></td></tr></table></figure><p>主要功能：对请求头，请求参数，响应头的增删改查</p><p>5.2.7 Retry  重试</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>   <span class="hljs-attr">cloud:</span><br>      <span class="hljs-attr">gateway:</span><br>         <span class="hljs-attr">routes:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">retry_test</span><br>              <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8080/flakey</span><br>              <span class="hljs-attr">predicates:</span><br>                 <span class="hljs-bullet">-</span> <span class="hljs-string">Host=*.retry.com</span><br>              <span class="hljs-attr">filters:</span><br>                 <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Retry</span><br>                   <span class="hljs-attr">args:</span><br>                      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span><br>                      <span class="hljs-attr">statuses:</span> <span class="hljs-string">BAD_GATEWAY</span><br>                      <span class="hljs-attr">methods:</span> <span class="hljs-string">GET,POST</span><br>                      <span class="hljs-attr">backoff:</span><br>                         <span class="hljs-attr">firstBackoff:</span> <span class="hljs-string">10ms</span><br>                         <span class="hljs-attr">maxBackoff:</span> <span class="hljs-string">50ms</span><br>                         <span class="hljs-attr">factor:</span> <span class="hljs-number">2</span><br>                         <span class="hljs-attr">basedOnPreviousValue:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>5.2.8 default filters 全局过滤器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">default-filters:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AddResponseHeader=X-Response-Default-Red,</span> <span class="hljs-string">Default-Blue</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PrefixPath=/httpbin</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringCloudGateway</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloudGateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网关的作用</title>
    <link href="/post/ca5906c9.html"/>
    <url>/post/ca5906c9.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h1><ol><li>路由</li><li>鉴权</li><li>缓存</li><li>跨域</li><li>流量染色</li><li>访问控制</li><li>统一业务处理</li><li>负载均衡</li><li>发布控制</li><li>统一日志</li><li>统一文档</li><li>业务保护<ol><li>限制请求</li><li>信息脱敏</li><li>降级（熔断）</li><li>限流</li><li>超时时间</li></ol></li></ol><h1 id="2-路由"><a href="#2-路由" class="headerlink" title="2. 路由"></a>2. 路由</h1><p>起到转发作用，将请求转发到对应的接口、服务器、集群</p><h1 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3. 负载均衡"></a>3. 负载均衡</h1><p>在路由的基础上，可以随机转发到某一台机器。</p><h1 id="4-鉴权"><a href="#4-鉴权" class="headerlink" title="4. 鉴权"></a>4. 鉴权</h1><p>判断用户是否有权限进行操作，无论访问什么接口，都能够统一判断。</p><h1 id="5-统一处理跨域"><a href="#5-统一处理跨域" class="headerlink" title="5. 统一处理跨域"></a>5. 统一处理跨域</h1><p>统一处理跨域，不用再某个项目里面单独写。</p><h1 id="6-统一业务处理"><a href="#6-统一业务处理" class="headerlink" title="6. 统一业务处理"></a>6. 统一业务处理</h1><p>统一处理业务，把每个项目都要用到的通用逻辑都放到上层里面去统一处理，比如调用次数</p><h1 id="7-访问控制"><a href="#7-访问控制" class="headerlink" title="7. 访问控制"></a>7. 访问控制</h1><p>黑白名单，比如限制DDOs IP</p><h1 id="8-发布控制"><a href="#8-发布控制" class="headerlink" title="8. 发布控制"></a>8. 发布控制</h1><p>局部试错，比如添加了新接口，给老接口分配80%流量，新接口20%，然后逐步过渡到新接口<br>Weight route</p><h1 id="9-流量染色"><a href="#9-流量染色" class="headerlink" title="9. 流量染色"></a>9. 流量染色</h1><p>区分用户的来源，判断用户是否从网关来的<br>给请求添加一些标识，一般是设置请求头<br>AddRequest header</p><h1 id="10-接口保护"><a href="#10-接口保护" class="headerlink" title="10. 接口保护"></a>10. 接口保护</h1><ol><li>限制请求</li><li>信息脱敏</li><li>降级（熔断）</li><li>限流</li><li>超时时间</li></ol><h1 id="11-统一日志"><a href="#11-统一日志" class="headerlink" title="11. 统一日志"></a>11. 统一日志</h1><p>统一的请求响应信息记录</p><h1 id="12-统一文档"><a href="#12-统一文档" class="headerlink" title="12. 统一文档"></a>12. 统一文档</h1><p>将下游项目的文档进行聚合，在同一个界面进行查看</p><h1 id="13-网关分类"><a href="#13-网关分类" class="headerlink" title="13. 网关分类"></a>13. 网关分类</h1><ol><li>业务网关（微服务网关）：负载均衡</li><li>全局网关（层级更高）：将一些业务逻辑，将一些请求转发到不同的接口&#x2F;业务&#x2F;服务器</li></ol><h1 id="14-实现"><a href="#14-实现" class="headerlink" title="14. 实现"></a>14. 实现</h1><ol><li>nginx、kong（API服务）</li><li>Spring cloud gateway<br><a href="https://blog.csdn.net/qq_21040559/article/details/122961395">https://blog.csdn.net/qq_21040559/article/details/122961395</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>网关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法通关村——双指针的妙用</title>
    <link href="/post/ed7b56c1.html"/>
    <url>/post/ed7b56c1.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-移除元素"><a href="#1-移除元素" class="headerlink" title="1. 移除元素"></a>1. 移除元素</h1><p><a href="https://leetcode.cn/problems/remove-element/description/">移除元素</a><br>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h2 id="1-2-分析"><a href="#1-2-分析" class="headerlink" title="1.2 分析"></a>1.2 分析</h2><h3 id="1-2-1-双指针法"><a href="#1-2-1-双指针法" class="headerlink" title="1.2.1 双指针法"></a>1.2.1 双指针法</h3><p>设置slow，fast指针，使得指针slow之前的数据都是不包含val的，fast一直向后走，如果不是val，slow位置写入fast的值。前半部分有效，后半部分无效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; fast&lt;nums.length; fast++)&#123;<br>           <span class="hljs-keyword">if</span>(nums[fast]!=val)&#123;<br>               nums[slow] = nums[fast];<br>               slow++;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> slow;<br>   &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n) 遍历了一个数组的长度<br>空间复杂度：O（1）就使用了slow记录数组长度</p><h3 id="1-2-2-对撞双指针"><a href="#1-2-2-对撞双指针" class="headerlink" title="1.2.2 对撞双指针"></a>1.2.2 对撞双指针</h3><p>设置左右两个指针，找到右边不是val的值来替代左边是val的情况，也是左边的元素都是有效的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(left =<span class="hljs-number">0</span>;left&lt;=right;)&#123;<br>        <span class="hljs-keyword">if</span>(nums[right]!=val &amp;&amp; nums[left] == val)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right]=temp;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(nums[left]!=val) left++;<br>        <span class="hljs-keyword">if</span>(nums[right]==val) right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O（n）遍历了数组的长度<br>空间复杂度：O（1）</p><h3 id="1-2-3-对撞双指针-覆盖"><a href="#1-2-3-对撞双指针-覆盖" class="headerlink" title="1.2.3 对撞双指针+覆盖"></a>1.2.3 对撞双指针+覆盖</h3><p>依然是采用对撞双指针，但是这时候不是交换左右数组元素了，而是直接将右边的元素覆盖左边的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;left&lt;=right;)&#123;<br>        <span class="hljs-keyword">if</span>(nums[left] == val)&#123;<br>            nums[left] = nums[right];<br>            right--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-删除有序数组中的重复项"><a href="#2-删除有序数组中的重复项" class="headerlink" title="2. 删除有序数组中的重复项"></a>2. 删除有序数组中的重复项</h1><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">删除有序数组中的重复项</a><br>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。</p><p>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：</p><p>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。<br>返回 k 。</p><h2 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h2><h3 id="2-1-1-使用快慢双指针"><a href="#2-1-1-使用快慢双指针" class="headerlink" title="2.1.1 使用快慢双指针"></a>2.1.1 使用快慢双指针</h3><p>依然设置快慢指针，只有快指针和慢指针不相同的时候才能将慢指针进行替换，然后慢指针再次自增。有个小的优化点就是一开始的slow&#x3D;0不需要处理，因为如果后面有元素和0索引一样，只需要换掉后面的元素就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; fast&lt;nums.length;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast]!=nums[slow-<span class="hljs-number">1</span>])&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O（n)<br>空间复杂度：O（1）</p><h1 id="3-元素奇偶移动专题"><a href="#3-元素奇偶移动专题" class="headerlink" title="3. 元素奇偶移动专题"></a>3. 元素奇偶移动专题</h1><h2 id="3-1-按奇偶排序数组"><a href="#3-1-按奇偶排序数组" class="headerlink" title="3.1 按奇偶排序数组"></a>3.1 按奇偶排序数组</h2><p><a href="https://leetcode.cn/problems/sort-array-by-parity/description/">按奇偶排序数组</a><br>给你一个整数数组 nums，将 nums 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。<br>返回满足此条件的 任一数组 作为答案。</p><h3 id="3-1-1-左右指针"><a href="#3-1-1-左右指针" class="headerlink" title="3.1.1 左右指针"></a>3.1.1 左右指针</h3><p>第一反应就是只需要将偶数都放在左边，奇数都放在右边，可以采用两个指针，一个在最左边，一个在最右边，同时向中间移动，需要判断left元素是不是偶数，如果是奇数，并且right元素是偶数就交换位置，但是如果left元素是偶数，那么left自增就可以，但是如果right元素是奇数，满足，right自减少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArrayByParity(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(left&lt;right &amp;&amp; nums[left] % <span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left&lt;right &amp;&amp; nums[right]%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[left] %<span class="hljs-number">2</span>!=<span class="hljs-number">0</span> &amp;&amp; nums[right] %<span class="hljs-number">2</span>==<span class="hljs-number">0</span> )&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>                nums[left] = nums[right];<br>                nums[right]=temp;<br>                left++;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h1 id="4-数组轮转问题"><a href="#4-数组轮转问题" class="headerlink" title="4 数组轮转问题"></a>4 数组轮转问题</h1><h2 id="4-1-轮转数组"><a href="#4-1-轮转数组" class="headerlink" title="4.1 轮转数组"></a>4.1 轮转数组</h2><p><a href="https://leetcode.cn/problems/rotate-array/">轮转数组</a><br>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p><h3 id="4-1-1-反转"><a href="#4-1-1-反转" class="headerlink" title="4.1.1 反转"></a>4.1.1 反转</h3><p>第一个想法是将数组一个一个进行反转，将最后的元素依次插到最前面。但是这个情况优点复杂，考虑的东西比较多。于是采用反转，先将所有元素反转，然后将k元素之前的元素再反转，k后面的元素也反转。这里需要将k转换成下标，也就是k-1位置的元素。<br><img src="/images/szzdmy-1.png" alt="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>       k = k% nums.length;<br>       reverse(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);<br>       reverse(nums,<span class="hljs-number">0</span>,k-<span class="hljs-number">1</span>);<br>       reverse(nums,k,nums.length-<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>       <span class="hljs-keyword">while</span>(start &lt;end)&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[start];<br>           nums[start] = nums[end];<br>           nums[end] = temp;<br>           start+=<span class="hljs-number">1</span>;<br>           end-=<span class="hljs-number">1</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(N)第一次反转是O(N),第二次是O(k),第三次是O(N-k)<br>空间复杂度：O(1)</p><h1 id="5-数组的区间专题"><a href="#5-数组的区间专题" class="headerlink" title="5. 数组的区间专题"></a>5. 数组的区间专题</h1><h2 id="5-1-汇总区间"><a href="#5-1-汇总区间" class="headerlink" title="5.1 汇总区间"></a>5.1 汇总区间</h2><p><a href="https://leetcode.cn/problems/summary-ranges/description/">汇总区间</a><br>给定一个  无重复元素 的 有序 整数数组 nums 。<br>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。<br>列表中的每个区间范围 [a,b] 应该按如下格式输出：<br>“a-&gt;b” ，如果 a !&#x3D; b<br>“a” ，如果 a &#x3D;&#x3D; b</p><h3 id="5-1-1-快慢指针"><a href="#5-1-1-快慢指针" class="headerlink" title="5.1.1 快慢指针"></a>5.1.1 快慢指针</h3><p>先让快指针一直走，当快指针后面元素和当前元素不连续的时候，返回开始元素和快指针元素的字符串，然后这时候的慢指针就要跳转到快指针的后一个元素位置，作为下一次的初始位置。中间需要判断当前快慢指针是否在同一个位置，如果在，表示只有一个元素。<br><img src="/images/szzdmy-2.png" alt="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">summaryRanges</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;fast&lt;nums.length;fast++)&#123;<br>            <span class="hljs-comment">//fast 向后遍历，不满足条件nums[fast]+1=nums[fast+1],就是不连续的</span><br>          <span class="hljs-keyword">if</span>(fast+<span class="hljs-number">1</span> ==nums.length || nums[fast] +<span class="hljs-number">1</span> !=nums[fast+<span class="hljs-number">1</span>])&#123;<br>              <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>              <span class="hljs-comment">// 记录下开始元素</span><br>              sb.append(nums[slow]);<br>              <span class="hljs-keyword">if</span>(slow!=fast)&#123;<br>                  <span class="hljs-comment">// 记录结束元素</span><br>                  sb.append(<span class="hljs-string">&quot;-&gt;&quot;</span>).append(nums[fast]);<br>              &#125;<br>              list.add(sb.toString());<br>              <span class="hljs-comment">// 下一个区间起始位置</span><br>              slow =fast+<span class="hljs-number">1</span>;<br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O（N）<br>空间复杂度：O（1）</p><h2 id="5-2-缺失的空间"><a href="#5-2-缺失的空间" class="headerlink" title="5.2 缺失的空间"></a>5.2 缺失的空间</h2><p>力扣 163，需要会员。<br>大体上和3.1一样，不过现在是获取缺失的空间<br>例如:   nums[0,1,3,50,75] ,lower&#x3D;0,upper&#x3D;99<br>结果是：  [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”]</p><h3 id="5-2-1-快慢指针"><a href="#5-2-1-快慢指针" class="headerlink" title="5.2.1 快慢指针"></a>5.2.1 快慢指针</h3><p>首先这一题一样采用，让快指针移动直到不连续，但是现在不需要慢指针了，只需要记录这个快指针元素和下一个位置元素的之间的空间输出即可，不过需要判断当前的元素是否超过lower和upper的范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">findNonContiguousSpaces</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper)</span> &#123;<br>      List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><br>      <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &gt; lower) &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> lower;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>          list.add(start + <span class="hljs-string">&quot;-&gt;&quot;</span> + end);<br>      &#125;<br><br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; fast &lt; n - <span class="hljs-number">1</span>; fast++) &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> nums[fast] + <span class="hljs-number">1</span>;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nums[fast + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>          list.add(prev + <span class="hljs-string">&quot;-&gt;&quot;</span> + cur);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (nums[n - <span class="hljs-number">1</span>] &lt; upper) &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> upper;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> nums[n - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>          list.add(start + <span class="hljs-string">&quot;-&gt;&quot;</span> + end);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> list;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h1 id="6-字符串替换空格"><a href="#6-字符串替换空格" class="headerlink" title="6. 字符串替换空格"></a>6. 字符串替换空格</h1><h2 id="6-1-替换空格"><a href="#6-1-替换空格" class="headerlink" title="6.1 替换空格"></a>6.1 替换空格</h2><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/description/">替换空格</a><br>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><h3 id="6-1-1-字符串截取"><a href="#6-1-1-字符串截取" class="headerlink" title="6.1.1 字符串截取"></a>6.1.1 字符串截取</h3><p>新建一个String，将字符串使用char保存里面每一个字符，如果这个字符为空的话，就拼接”%20”，如果不是就直接拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                rep+=<span class="hljs-string">&quot;%20&quot;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                rep+=c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rep;<br>    &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O（N^2)主要是遍历字符串和再次拼接字符串。<br><img src="/images/szzdmy-3.png" alt="img.png"><br>很显然，时间空间效率比较低。</p><h3 id="6-1-2-快慢指针"><a href="#6-1-2-快慢指针" class="headerlink" title="6.1.2 快慢指针"></a>6.1.2 快慢指针</h3><p>首先先计算出有多少个空格，添加一个%20,占用三个字节，而一个空格占用一个字节，所有最后多出来的长度就是2个字节，总共多出来2*n个字节，然后将stringbuffer的长度扩大，将慢指针放在新的字符串最后，快指针放在原字符串最后，当快指针遇到空格的时候，这时候需要使用三个字符替代一个空格，然后slow移动三个位置，而fast移动一个位置，直到fast到达开始位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>       StringBuffer str= <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(s);<br>       <span class="hljs-keyword">if</span>(str ==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">blankCount</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> str.length();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>           <span class="hljs-keyword">if</span>(str.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>               blankCount++;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-type">int</span> <span class="hljs-variable">newLength</span> <span class="hljs-operator">=</span> len+<span class="hljs-number">2</span>*blankCount;<br>       str.setLength(newLength);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> newLength-<span class="hljs-number">1</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> len-<span class="hljs-number">1</span>;<br><br>       <span class="hljs-keyword">while</span>(fast&gt;=<span class="hljs-number">0</span> &amp;&amp; slow!=fast)&#123;<br>           <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(fast);<br>           <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>               fast--;<br>               str.setCharAt(slow--,<span class="hljs-string">&#x27;0&#x27;</span>);<br>               str.setCharAt(slow--,<span class="hljs-string">&#x27;2&#x27;</span>);<br>               str.setCharAt(slow--,<span class="hljs-string">&#x27;%&#x27;</span>);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               str.setCharAt(slow,c);<br>               fast--;<br>               slow--;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> str.toString();<br>       &#125;<br></code></pre></td></tr></table></figure><p><img src="/images/szzdmy-4.png" alt="img.png"><br>可以看出时间还是很快的。<br>时间复杂度：O（n），先遍历一次字符串，找到空格个数，然后对新的字符串进行扩充</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot面试题-2</title>
    <link href="/post/ceb4123b.html"/>
    <url>/post/ceb4123b.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Spring-boot内置Tomcat启动原理？"><a href="#1-Spring-boot内置Tomcat启动原理？" class="headerlink" title="1. Spring boot内置Tomcat启动原理？"></a>1. Spring boot内置Tomcat启动原理？</h1><ol><li>自动配置类中启动内嵌tomcat，配置tomcat服务工程</li><li>spring boot 启动，会创建spring容器</li><li>调用refresh方法，加载ioc容器</li><li>解析自动配置类</li><li>获得tomcat的工厂</li><li>getWebServer启动tomcat</li></ol><h1 id="2-Spring-boot外部Tomcat启动原理？"><a href="#2-Spring-boot外部Tomcat启动原理？" class="headerlink" title="2. Spring boot外部Tomcat启动原理？"></a>2. Spring boot外部Tomcat启动原理？</h1><p>打包外部服务器，将jar换成war，然后排除spring boot里面的tomcat，创建类继承SpringBootServerInitializer, 重写configure</p><h1 id="3-自己定义stater？大概实现过程。"><a href="#3-自己定义stater？大概实现过程。" class="headerlink" title="3. 自己定义stater？大概实现过程。"></a>3. 自己定义stater？大概实现过程。</h1><ol><li>删除build</li><li>引入processor依赖</li><li>删除stater</li><li>新建META-INF&#x2F;spring.factories</li><li>org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;配置文件地址</li></ol><h1 id="4-Spring-Boot读取配置文件的原理？加载顺序是什么？"><a href="#4-Spring-Boot读取配置文件的原理？加载顺序是什么？" class="headerlink" title="4. Spring Boot读取配置文件的原理？加载顺序是什么？"></a>4. Spring Boot读取配置文件的原理？加载顺序是什么？</h1><p>通过事件监听读取配置文件：ConfigFileApplicationListener<br>顺序：</p><ol><li>file: .&#x2F;config</li><li>file: .&#x2F;config&#x2F;{@literal *}</li><li>file: .</li><li>classpath: config</li><li>classpath:<br>高优先级覆盖低优先级。</li></ol><h1 id="5-Spring-Boot默认日志实现框架？怎么切换成其他框架。"><a href="#5-Spring-Boot默认日志实现框架？怎么切换成其他框架。" class="headerlink" title="5. Spring Boot默认日志实现框架？怎么切换成其他框架。"></a>5. Spring Boot默认日志实现框架？怎么切换成其他框架。</h1><p>默认logback<br>添加sl4j桥接器和适配器<br>只需要将logback排除依赖</p><h1 id="6-如何提高spring-boot加载速度？"><a href="#6-如何提高spring-boot加载速度？" class="headerlink" title="6. 如何提高spring boot加载速度？"></a>6. 如何提高spring boot加载速度？</h1><ol><li>开启懒加载   spring.main.lazy-initialization:true,能够快速1-2s</li><li>创建扫描索引，spring-context-indexer, 启动类上加入@Index</li><li>jdk17&#x2F;Spring boot3</li></ol>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot面试题-1</title>
    <link href="/post/57bd4381.html"/>
    <url>/post/57bd4381.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Spring-boot可以同时处理多少个请求？"><a href="#1-Spring-boot可以同时处理多少个请求？" class="headerlink" title="1. Spring boot可以同时处理多少个请求？"></a>1. Spring boot可以同时处理多少个请求？</h1><p>有最大连接数：max-connections（8192）和最大等待数 accept-count （100）之和.<br>里面还有两个参数threads.min-spare（最小线程工作数），和threads.max(最大线程工作数)</p><h1 id="2-Spring-boot有哪些特性。"><a href="#2-Spring-boot有哪些特性。" class="headerlink" title="2. Spring boot有哪些特性。"></a>2. Spring boot有哪些特性。</h1><p>快速开发spring应用的脚手架，简化应用初始搭建以及开发过程</p><ol><li>内置stater结合自动配置</li><li>简化开发，xml配置少了</li><li>内置web容器无需依赖外部服务器</li><li>管理常用第三方依赖</li><li>自带监控</li></ol><h1 id="3-Spring-boot的-SpringBootApplication-注解？"><a href="#3-Spring-boot的-SpringBootApplication-注解？" class="headerlink" title="3. Spring boot的@SpringBootApplication 注解？"></a>3. Spring boot的@SpringBootApplication 注解？</h1><p>核心部分</p><ol><li>EnableAutoConfiguration: 启动spring boot的自动配置机制。</li><li>ComponentScan：扫描被@Componet注解的bean，扫描包下所有的类。</li><li>Configuration：允许上下文注册额外的bean或者导入其他的配置类。</li></ol><h1 id="4-什么是Spring-boot自动装配？"><a href="#4-什么是Spring-boot自动装配？" class="headerlink" title="4. 什么是Spring boot自动装配？"></a>4. 什么是Spring boot自动装配？</h1><p>Spring Boot定义了一套配置文件：Spring boot 启动时会自动扫描jar里面的META-InF&#x2F;spring.factories文件，然后将信息加载到Spring容器，执行类中操作。<br>简单来说：就是通过注解或者简单的配置就能在Spring boot的帮助下实现某块功能。</p><h1 id="5-Spring-boot是如何实现自动装配的？"><a href="#5-Spring-boot是如何实现自动装配的？" class="headerlink" title="5. Spring boot是如何实现自动装配的？"></a>5. Spring boot是如何实现自动装配的？</h1><p>总结：</p><ol><li>首先通过@SpringBootConfiguration引入@EnableAutoConfiguration(自动配置功能)</li><li>@EnableAutoConfiguration引入@Import</li><li>Spring 容器启动时候会解析@Import</li><li>@Import导入DeferredImportSelector，使得spring boot自动配置类的顺序在最后，方便扩展。</li><li>读出META-INF里面的spring.factories文件</li><li>过滤出所有的AutoConfigurationClass类型的类</li><li>通过@ConditionOnxxx排除无效的自动配置类</li></ol><h1 id="6-spring-factories每次启动都需要进行加载吗？"><a href="#6-spring-factories每次启动都需要进行加载吗？" class="headerlink" title="6. spring.factories每次启动都需要进行加载吗？"></a>6. spring.factories每次启动都需要进行加载吗？</h1><p>只有满足@ConditionalOnxxx的所有条件，该类才会生效。</p><h1 id="7-为什么Spring-boot的jar可以直接运行？"><a href="#7-为什么Spring-boot的jar可以直接运行？" class="headerlink" title="7. 为什么Spring boot的jar可以直接运行？"></a>7. 为什么Spring boot的jar可以直接运行？</h1><ol><li>Spring boot提供了一个插件spring-boot-maven-plugin用于打包程序为一个jar文件</li><li>打包之后会生成Fat jar，包含应用依赖的jar包和Spring Boot loader相关的类。</li><li>java -jar会找到jar里面的mainfest文件，找到里面的真正启动类。</li><li>Fat jar 的启动Main函数是JarLauncher,负责创建LaunchedURLClassLoader来加载boot-lib里面的jar，已新线程启动应用的启动类的Main函数（找到mainfest里面的stater-class）。</li></ol><h1 id="8-Spring-boot的启动原理？"><a href="#8-Spring-boot的启动原理？" class="headerlink" title="8. Spring boot的启动原理？"></a>8. Spring boot的启动原理？</h1><ol><li>运行main方法，初始化SpringApplication，从spring.factories读取listener，ApplicationContextInitializlizer</li><li>运行run方法</li><li>读取环境变量，配置信息</li><li>创建springApplication上下文：ServletWebServerApplicationContext</li><li>预初始化上下文：读取启动类</li><li>调用refresh加载ioc容器，加载自动配置类，创建servlet容器</li><li>这个过程springboot会调用很多的监听器对外扩展。</li></ol>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>API项目开发自定义stater</title>
    <link href="/post/97accc07.html"/>
    <url>/post/97accc07.html</url>
    
    <content type="html"><![CDATA[<h2 id="现在的缺点"><a href="#现在的缺点" class="headerlink" title="现在的缺点"></a>现在的缺点</h2><p>每次都要写getHeader方法，用户调用者并不关心这个是如何生成的，用户只关心使用ak,sk，参数,所以需要创建stater来便于调用</p><h2 id="开发stater好处"><a href="#开发stater好处" class="headerlink" title="开发stater好处"></a>开发stater好处</h2><ol><li>引入这一直接在application.yml里面写入ak,sk直接调用创建客户端</li></ol><h2 id="开发stater"><a href="#开发stater" class="headerlink" title="开发stater"></a>开发stater</h2><ol><li><p>新建spring-boot项目</p></li><li><p>删除pom.xml里面的build</p></li><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <br>        <span class="hljs-comment">&lt;!--自定生成yml提示--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>核心依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">      <span class="hljs-comment">&lt;!--自定生成yml提示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>删除原来项目的stater</p></li><li><p>新建一个Config</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">// 读取配置</span><br><span class="hljs-meta">@ConfigurationProperties( &quot;flyapi.client&quot; )</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyAPIClientConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> String assessKey;<br>    <span class="hljs-keyword">private</span> String secretKey;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FlyApiClient <span class="hljs-title function_">flyApiClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyApiClient</span>(assessKey, secretKey);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将之前的User和FlyApiClient,signUtils复制到当前项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用第三方接口客户端</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fly</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyApiClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HTTP_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://localhost:7530/api&quot;</span>;<br>    <span class="hljs-keyword">private</span> String accessKey;<br>    <span class="hljs-keyword">private</span> String secretKey;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FlyApiClient</span><span class="hljs-params">(String accessKey, String secretKey)</span> &#123;<br>        <span class="hljs-built_in">this</span>.accessKey = accessKey;<br>        <span class="hljs-built_in">this</span>.secretKey = secretKey;<br>    &#125;<br><br>    <span class="hljs-comment">// get</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByGet</span><span class="hljs-params">(String name)</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, name);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> HttpUtil.get(HTTP_URL + <span class="hljs-string">&quot;/name/&quot;</span>, map);<br>        System.out.println(<span class="hljs-string">&quot;get=&gt;&quot;</span> + result);<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// post传参</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByPost</span><span class="hljs-params">(String name)</span> &#123;<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, name);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> HttpUtil.post(HTTP_URL + <span class="hljs-string">&quot;/name/&quot;</span>, map);<br>        System.out.println(<span class="hljs-string">&quot;post_param=&gt;&quot;</span> + result);<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title function_">getHeaders</span><span class="hljs-params">(String body)</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;accessKey&quot;</span>, accessKey);<br>        <span class="hljs-comment">// 不能直接发送给后端</span><br><span class="hljs-comment">//        map.put(&quot;secretKey&quot;, secretKey);</span><br>        map.put(<span class="hljs-string">&quot;nonce&quot;</span>, RandomUtil.randomNumbers(<span class="hljs-number">5</span>));<br>        map.put(<span class="hljs-string">&quot;body&quot;</span>, body);<br>        map.put(<span class="hljs-string">&quot;timestamp&quot;</span>, String.valueOf(System.currentTimeMillis() / <span class="hljs-number">1000</span>));<br>        map.put(<span class="hljs-string">&quot;sign&quot;</span>, genSign(body,secretKey));<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br><br>    <span class="hljs-comment">// post传对象</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByPostJson</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSONUtil.toJsonStr(user);<br>        <span class="hljs-type">HttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> HttpRequest<br>                .post(HTTP_URL + <span class="hljs-string">&quot;/name/user&quot;</span>)<br>                .addHeaders(getHeaders(json))<br>                .body(json)<br>                .execute();<br>        System.out.println(<span class="hljs-string">&quot;json_user_status=&gt;&quot;</span> + response.getStatus());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> response.body();<br>        System.out.println(<span class="hljs-string">&quot;json=&gt;&quot;</span> + result);<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SignUtils</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加密用户参数和secret</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> body</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> secretKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> String <span class="hljs-title function_">genSign</span><span class="hljs-params">(String body, String secretKey)</span> &#123;<br>        <span class="hljs-type">Digester</span> <span class="hljs-variable">md5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Digester</span>(DigestAlgorithm.SHA1);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> body + <span class="hljs-string">&quot;.&quot;</span> + secretKey;<br>        <span class="hljs-keyword">return</span> md5.digestHex(content);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="6"><li><p>在resources里面新建META-INF文件夹，然后新建spring.factories文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.fly.FlyAPIClientConfig(此处是配置文件的地址)<br></code></pre></td></tr></table></figure></li><li><p>原有的interface里面相应的User和FlyApiClient,signUtils删除，引入新的依赖<br><img src="/images/api_stater_2.png" alt="img.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fly<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fly-Api-stater<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-test<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>重启项目<br><img src="/images/api_stater_1.png" alt="img.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>API</category>
      
      <category>stater</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring boot stater</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法通关村——不简单的数组增删改查</title>
    <link href="/post/47779642.html"/>
    <url>/post/47779642.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-有序数组添加元素"><a href="#1-有序数组添加元素" class="headerlink" title="1. 有序数组添加元素"></a>1. 有序数组添加元素</h1><p>先找到要插入元素的位置，然后将这个位置包括之后的元素都后移一位，然后插入元素进入数组。首先需要判断当前数组能不能继续添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 插入指定位置元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr     有序数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> size    已经存储的元素数量，从1开始</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> element 插入的元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addByElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> element)</span> &#123;<br>    <span class="hljs-comment">// size从1开始表示实际个数，arr.length也是从1开始</span><br>    <span class="hljs-keyword">if</span> (size &gt;= arr.length) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 防止插入的数大于当前最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (element &lt; arr[i]) &#123;<br>            index = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// j开始元素都后移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> size; j &gt; index; j--) &#123;<br>        arr[j] = arr[j - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// 插入元素</span><br>    arr[index] = element;<br>    <span class="hljs-keyword">return</span> index;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-删除指定位置元素"><a href="#2-删除指定位置元素" class="headerlink" title="2. 删除指定位置元素"></a>2. 删除指定位置元素</h1><p>先找到删除元素所存在的位置，如果位置存在，记录下来，然后判断这个位置下标是不是-1.不是-1表示存在，然后将删除元素后面的元素都前移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 删除元素key</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> arr  数组</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> size 数组元素个数从1开始</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> key  删除元素</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeByElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> key)</span> &#123;<br>      <span class="hljs-keyword">if</span> (size &gt;= arr.length) &#123;<br>          <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-comment">// index是-1，表示不存在</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>          <span class="hljs-keyword">if</span> (arr[i] == key) &#123;<br>              index = key;<br>              <span class="hljs-keyword">break</span>;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (index != -<span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index + <span class="hljs-number">1</span>; i &lt; size; i++) &#123;<br>              arr[i - <span class="hljs-number">1</span>] = arr[i];<br>              size--;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> size;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="3-单调数列"><a href="#3-单调数列" class="headerlink" title="3. 单调数列"></a>3. 单调数列</h1><p><a href="https://leetcode.cn/problems/monotonic-array/">单调数列</a><br>如果数组是单调递增或单调递减的，那么它是 单调 的。<br>如果对于所有 i &lt;&#x3D; j，nums[i] &lt;&#x3D; nums[j]，那么数组 nums 是单调递增的。 如果对于所有 i &lt;&#x3D; j，nums[i]&gt; &#x3D; nums[j]，那么数组 nums 是单调递减的。<br>当给定的数组 nums 是单调数组时返回 true，否则返回 false。</p><h2 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h2><p>由于题目里面是包含递增和递减的，直接判断无法知道是递增还是递减，所以需要使用两个变量inc，desc来记录，如果元素都是递增的，那么最后使用inc|| desc 只会是true，一旦是fasle就表明，不是单调的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMonotonic</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>  <span class="hljs-comment">// 递增标志</span><br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">inc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 递减标志</span><br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length-<span class="hljs-number">1</span>;i++)&#123;<br>          <span class="hljs-keyword">if</span>(nums[i]&gt;nums[i+<span class="hljs-number">1</span>])&#123;<br>          <span class="hljs-comment">// 由于是递减的，所以递增的不满足，设置为false</span><br>              inc = <span class="hljs-literal">false</span>;<br>          &#125;<br><span class="hljs-comment">// 同理</span><br>          <span class="hljs-keyword">if</span>(nums[i] &lt; nums[i+<span class="hljs-number">1</span>])&#123;<br>              desc = <span class="hljs-literal">false</span>;<br>          &#125;<br>      &#125;<br><span class="hljs-comment">// 只要一个为true就是true，如果都是false那么就不是递增的</span><br>      <span class="hljs-keyword">return</span> inc || desc;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="4-搜索插入位置"><a href="#4-搜索插入位置" class="headerlink" title="4. 搜索插入位置"></a>4. 搜索插入位置</h1><p><a href="https://leetcode.cn/problems/search-insert-position/">搜索插入位置</a><br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。</p><h2 id="4-1-分析"><a href="#4-1-分析" class="headerlink" title="4.1 分析"></a>4.1 分析</h2><p>题目要求logn的时间复杂度，第一时间想到二分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n;<br>     <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>     <span class="hljs-comment">// 这里要加上相应的括号，否则优先级会报错</span><br>         <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((right-left) &gt;&gt;<span class="hljs-number">1</span>) +left;<br>         <span class="hljs-keyword">if</span>(target&lt;=nums[mid])&#123;<br>             ans = mid;<br>             right = mid-<span class="hljs-number">1</span>;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>             left = mid+<span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> ans;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="5-合并两个有序数组"><a href="#5-合并两个有序数组" class="headerlink" title="5. 合并两个有序数组"></a>5. 合并两个有序数组</h1><p><a href="https://leetcode.cn/problems/merge-sorted-array/description/">合并两个有序数组</a><br>给你两个按非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。<br>请你合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。<br>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><h2 id="5-1-分析"><a href="#5-1-分析" class="headerlink" title="5.1 分析"></a>5.1 分析</h2><h3 id="5-1-1-先将元素都添加到nums1里面去，然后对nums1排序。"><a href="#5-1-1-先将元素都添加到nums1里面去，然后对nums1排序。" class="headerlink" title="5.1.1 先将元素都添加到nums1里面去，然后对nums1排序。"></a>5.1.1 先将元素都添加到nums1里面去，然后对nums1排序。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums2.length;i++)&#123;<br>         nums1[m+i] = nums2[i];<br>     &#125;      <br>     Arrays.sort(nums1);<br>   &#125;<br></code></pre></td></tr></table></figure><p>但是很显然效率是不高的，第一此遍历nums2，时间复杂度是O(n), 第二次使用Arrays排序，底层是快排，时间复杂度是O(nlogn)</p><h3 id="5-2-2-由于两个数组都是有序的，只需要比较两个数组的最后一个元素，将大的放入nums1的末尾，最后将未完成的元素放入nums1里面。"><a href="#5-2-2-由于两个数组都是有序的，只需要比较两个数组的最后一个元素，将大的放入nums1的末尾，最后将未完成的元素放入nums1里面。" class="headerlink" title="5.2.2 由于两个数组都是有序的，只需要比较两个数组的最后一个元素，将大的放入nums1的末尾，最后将未完成的元素放入nums1里面。"></a>5.2.2 由于两个数组都是有序的，只需要比较两个数组的最后一个元素，将大的放入nums1的末尾，最后将未完成的元素放入nums1里面。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 合并索引位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m + n - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// nums1的最后一个元素</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// nums2的最后一个元素</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (len1 &gt;= <span class="hljs-number">0</span> &amp;&amp; len2 &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (nums1[len1] &lt;= nums2[len2]) &#123;<br>            <span class="hljs-comment">// 将最大的元素放入nums1的末尾</span><br>            nums1[i--] = nums2[len2--];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums1[i--] = nums1[len1--];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断剩余数组是否有空余元素</span><br>    <span class="hljs-keyword">while</span> (len2 != -<span class="hljs-number">1</span>) nums1[i--] = nums2[len2--];<br>    <span class="hljs-keyword">while</span> (len1 != -<span class="hljs-number">1</span>) nums1[i--] = nums1[len1--];<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面的时间复杂度就是O(m+n)两个数组的长度。可以看出效率还是很高的、</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>数组问题的难点在于如何选择相对合理的方式来解决问题，尤其是数组的增加元素，删除元素的这种移动尤其需要注意。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring面试题-2</title>
    <link href="/post/fcd31521.html"/>
    <url>/post/fcd31521.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Spring-AOP"><a href="#1-Spring-AOP" class="headerlink" title="1. Spring AOP"></a>1. Spring AOP</h1><h2 id="1-1谈谈对spring-aop的理解"><a href="#1-1谈谈对spring-aop的理解" class="headerlink" title="1.1谈谈对spring aop的理解"></a>1.1谈谈对spring aop的理解</h2><p>主要是用于将那些与业务无关，被业务模块所共用的逻辑封装起来，减少系统的重复代码，降低耦合度，便于可拓展性。<br>Spring AOP是基于动态代理的，如果代理的对象实现了某个接口，那么就采用jdk动态代理，创建代理对象，对于没有实现接口的对象，使用cglib生成被代理对象的子类作为代理。</p><h2 id="1-2-Spring-AOP和AspectJ-AOP有什么区别？"><a href="#1-2-Spring-AOP和AspectJ-AOP有什么区别？" class="headerlink" title="1.2 Spring AOP和AspectJ AOP有什么区别？"></a>1.2 Spring AOP和AspectJ AOP有什么区别？</h2><ol><li>Spring AOP是运行时增强，而AspectJ AOP是编译时增强。</li><li>Spring AOP基于动态代理，而AspectJ AOP是基于字节码操作。</li><li>Spring AOP集成了AspectJ AOP。</li></ol><h2 id="1-3-AspectJ定义的通知类型有哪些？"><a href="#1-3-AspectJ定义的通知类型有哪些？" class="headerlink" title="1.3 AspectJ定义的通知类型有哪些？"></a>1.3 AspectJ定义的通知类型有哪些？</h2><ol><li>Before：前置通知，目标对象的方法调用前</li><li>After：后置通知，目标对象的方法调用后</li><li>AfterReturn：返回通知，目标对象的方法调用成功返回结果时候触发</li><li>AfterThrowing：异常通知，目标对象抛出异常后触发。</li><li>Around：环绕通知，编程式控制目标对象。操作范围最大的。</li></ol><h2 id="1-4-多个切面的执行顺序如何控制？"><a href="#1-4-多个切面的执行顺序如何控制？" class="headerlink" title="1.4 多个切面的执行顺序如何控制？"></a>1.4 多个切面的执行顺序如何控制？</h2><ol><li>使用@Order</li><li>实现Ordered重写getOrder方法</li></ol><h1 id="2-Spring-MVC"><a href="#2-Spring-MVC" class="headerlink" title="2. Spring MVC"></a>2. Spring MVC</h1><h2 id="2-1-谈谈对于Spring-MVC的理解。"><a href="#2-1-谈谈对于Spring-MVC的理解。" class="headerlink" title="2.1 谈谈对于Spring MVC的理解。"></a>2.1 谈谈对于Spring MVC的理解。</h2><p>MVC分成三部分模型，视图，控制器。将业务逻辑，数据，显示分离。</p><h2 id="2-2-Spring-MVC核心组件有哪些？"><a href="#2-2-Spring-MVC核心组件有哪些？" class="headerlink" title="2.2 Spring MVC核心组件有哪些？"></a>2.2 Spring MVC核心组件有哪些？</h2><ol><li><strong>DispatcherServlet</strong>:  核心的中央处理器，主要是负责接收请求，分发，响应客户端。</li><li><strong>HandlerMapping</strong>：处理器映射器，主要是根据uri匹配查找能够处理的Handler，并将请求涉及的拦截器和Handler进行封装。</li><li><strong>HandlerAdapter</strong>：处理器适配器，主要是根据HandlerMapping找到handler，适配对应的handler。</li><li><strong>Handler</strong>：请求处理器，处理实际请求。</li><li><strong>ViewResolver</strong>: 视图解析器，根据Handler返回的视图，解析渲染真正的视图，传递给DispatcherServlet相应客户端</li></ol><h2 id="2-3-Spring-MVC-工作原理"><a href="#2-3-Spring-MVC-工作原理" class="headerlink" title="2.3 Spring MVC 工作原理"></a>2.3 Spring MVC 工作原理</h2><p><img src="/images/smst-2-1.png" alt="img.png"></p><ol><li>客户端发送请求，DispatcherServlet进行拦截。</li><li>DispatcherServlet根据请求调用HandlerMapping。HandlerMapping根据对应的uri匹配查找能够处理handler，然后将涉及到的拦截器与handler进行封装。</li><li>调用HandlerAdapter，根据HandlerMapping里面找到的handler去找到适配的handler执行。</li><li>handler完成对用户的请求，返回ModelView数据给 DispatcherServlet。</li><li>ViewResolver：根据逻辑view查找实际的view。</li><li>DispatcherServlet将Model传给View</li><li>把View返回请求者</li></ol><h2 id="2-4-统一异常处理怎么做？"><a href="#2-4-统一异常处理怎么做？" class="headerlink" title="2.4 统一异常处理怎么做？"></a>2.4 统一异常处理怎么做？</h2><p>使用注解@ControllerAdvice(类)+@ExecptionHandler（方法）<br>会将指定的Controller织入异常的逻辑AOP，当Controller抛出异常的时候，被@ExceptionHandler修饰的方法处理。</p><p>里面的getMappedMethod()会先找到可以匹配的处理异常的所有方法信息，然后对其进行从小到大的排序，取出最小的匹配方法（匹配度最高的）。</p><h1 id="3-Spring-使用到的设计模式"><a href="#3-Spring-使用到的设计模式" class="headerlink" title="3.  Spring 使用到的设计模式"></a>3.  Spring 使用到的设计模式</h1><ol><li>控制反转和依赖注入：IOC是一个原则，并不是模式，主要是将手动创建的控制权交给Spring进行管理，只需要写好配置文件，不需要直到用户是如何创建出来的；依赖注入是实现控制反转的一种设计模式，将实例变量传递到对象中去。</li><li>工厂设计模式：可以使用BeanFactory或者ApplicationContext创建Bean对象。<br>  2.1 BeanFactory是延迟注入，只有使用到这个Bean的时候才会注入，占用内存小<br>  2.2 ApplicationContext：启动的时候会一次性创建所有的Bean。</li><li>单例设计模式：Spring里面的Bean默认都是单例的</li><li>代理设计模式：Spring AOP和AspectJ AOP</li><li>模板设计模式：定义一个算法骨架，将一些步骤延迟到子类里面。使子类不需要改变一个算法结构就能重新定义某些步骤的算法。JDBCTemplate等操作数据的类。</li><li>观察者模型：Spring事件驱动模型。</li><li>适配器模式：使接口不兼容的类一起工作。Spring AOP(增强，通知)和Spring MVC（Handler Adapter）</li><li>装饰者模式：动态的给对象添加一些额外的功能和属性。InputStream家族。配置DataSource</li></ol><h1 id="4-Spring事务"><a href="#4-Spring事务" class="headerlink" title="4. Spring事务"></a>4. Spring事务</h1><h2 id="4-1-Spring管理事务有哪几种方式？"><a href="#4-1-Spring管理事务有哪几种方式？" class="headerlink" title="4.1 Spring管理事务有哪几种方式？"></a>4.1 Spring管理事务有哪几种方式？</h2><ol><li>编程式事务：在代码里面硬编码，使用TransactionTemplate或者TransactionManager手动管理事务，很少使用。</li><li>声明式事务：xml或者基于注解，通过AOP实现（基于@Transactional注解）</li></ol><h2 id="4-2-Spring事务中有哪几种事务传播行为？"><a href="#4-2-Spring事务中有哪几种事务传播行为？" class="headerlink" title="4.2 Spring事务中有哪几种事务传播行为？"></a>4.2 Spring事务中有哪几种事务传播行为？</h2><p>主要是解决业务层方法之间相互调用的问题。</p><ol><li>required: 存在事务，则加入该事务，没有事务，创建新的事务。</li><li>required_new: 创建一个新的事务，如果存在事务，就把这个事务挂起。</li><li>nested：存在事务，就创建一个事务作为当前事务的嵌套事务来执行。不存在事务们就是required。</li><li>mandatory：存在事务，加入该事务，不存在该事务，报异常。</li></ol>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>API项目签名认证</title>
    <link href="/post/a9ae1af2.html"/>
    <url>/post/a9ae1af2.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-API签名认证"><a href="#1-API签名认证" class="headerlink" title="1. API签名认证"></a>1. API签名认证</h1><p>判断当前的用户是否符合要求，通过使用ak，sk进行验证是否有权限访问当前接口</p><ol><li>发送签名</li><li>使用签名</li></ol><h1 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="2. 如何实现"></a>2. 如何实现</h1><p>accessKey:  标识（复杂，无序，不易破解）</p><p>secretKey： 通过ak进行判断传递的sk和数据库的sk是否一致，密钥。</p><h1 id="3-模拟发送请求"><a href="#3-模拟发送请求" class="headerlink" title="3. 模拟发送请求"></a>3. 模拟发送请求</h1><p>请求头传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping( &quot;/user&quot; )</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByPostJson</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user, HttpServletRequest request)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">accessKey</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;accessKey&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">secretKey</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;secretKey&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!accessKey.equals(<span class="hljs-string">&quot;fly&quot;</span>) || !secretKey.equals(<span class="hljs-string">&quot;12345&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Post your name=&gt;&quot;</span> + user.getName();<br>    &#125;<br></code></pre></td></tr></table></figure><p>添加请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getHeaders</span><span class="hljs-params">()</span> &#123;<br>    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;accessKey&quot;</span>, <span class="hljs-string">&quot;fly&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;secretKey&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>);<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure><p>改造post</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// post传对象</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByPostJson</span><span class="hljs-params">(User user)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSONUtil.toJsonStr(user);<br>    <span class="hljs-type">HttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> HttpRequest<br>            .post(HTTP_URL + <span class="hljs-string">&quot;/name/user&quot;</span>)<br>            .addHeaders(getHeaders())<br>            .body(json)<br>            .execute();<br>    System.out.println(<span class="hljs-string">&quot;json_user_status=&gt;&quot;</span> + response.getStatus());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> response.body();<br>    System.out.println(<span class="hljs-string">&quot;json=&gt;&quot;</span> + result);<br>    System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用断点查看<br><img src="/images/api_project_sign_1.png" alt="img.png"></p><p>缺点：</p><p>将ak，sk直接在服务端传递时不安全的</p><h1 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h1><p>加密方式：对称加密，非对称加密，公钥加密，私钥解密，单项加密，mid5加密</p><p>采用mid5加密，不可解密</p><p>加密方式：</p><p>用户传递参数+密钥 &#x3D;&gt; 签名算法&#x3D;&gt;不可解密</p><p>abc+df&#x3D;&gt;123123dsada</p><p>解析密码：</p><p>服务端采用同样的方式生成签名算法</p><p>怎么防止重放</p><ol><li>使用随机数（只能使用一次），但是后端要保存使用的随机数</li><li>timestamp时间戳，判断时间相差是否小于5min，校验是否过期</li></ol><p>参数选取：</p><ol><li>accessKey</li><li>secretKey</li><li>用户请求参数</li><li>签名（加密算法）</li><li>nonce随机数</li><li>timestamp时间戳</li></ol>]]></content>
    
    
    <categories>
      
      <category>Hutool</category>
      
      <category>API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>签名认证</tag>
      
      <tag>Hutool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>API项目调用第三方HTTP请求-Hutool</title>
    <link href="/post/22eee5d7.html"/>
    <url>/post/22eee5d7.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-调用http方式"><a href="#1-调用http方式" class="headerlink" title="1. 调用http方式"></a>1. 调用http方式</h1><ol><li>httpClient</li><li>RestTemplate</li><li>第三方调用库（OkHttp,hutool）</li></ol><h1 id="2-使用hutool"><a href="#2-使用hutool" class="headerlink" title="2. 使用hutool"></a>2. 使用hutool</h1><ol><li>先开发三个不同的接口，包含get，post传参，post传对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping( &quot;/name&quot; )</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NameController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByGet</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;get your name=&gt;&quot;</span> + name;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByPost</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Post your name=&gt;&quot;</span> + name;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/user&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByPostJson</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Post your name=&gt;&quot;</span> + user.getName();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>引入hutool依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>查看官方文档</li></ol><p><a href="https://www.hutool.cn/docs/#/http/Http%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7%E7%B1%BB-HttpUtil">https://www.hutool.cn/docs/#/http/Http%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7%E7%B1%BB-HttpUtil</a></p><p>get示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最简单的HTTP请求，可以自动通过header等信息判断编码，不区分HTTP和HTTPS</span><br>String result1= HttpUtil.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br><span class="hljs-comment">// 当无法识别页面编码的时候，可以自定义请求页面的编码</span><br>String result2= HttpUtil.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>, CharsetUtil.CHARSET_UTF_8);<br><span class="hljs-comment">//可以单独传入http参数，这样参数会自动做URL编码，拼接在URL中</span><br>HashMap&lt;String, Object&gt; paramMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>paramMap.put(<span class="hljs-string">&quot;city&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>);<br>String result3= HttpUtil.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>, paramMap);<br></code></pre></td></tr></table></figure><p>post示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String, Object&gt; paramMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>paramMap.put(<span class="hljs-string">&quot;city&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>);<br><br>String result= HttpUtil.post(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>, paramMap);<br></code></pre></td></tr></table></figure><p>post传递对象,使用restful格式</p><p><a href="https://www.hutool.cn/docs/#/http/Http%E8%AF%B7%E6%B1%82-HttpRequest">https://www.hutool.cn/docs/#/http/Http%E8%AF%B7%E6%B1%82-HttpRequest</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> ...;<br><span class="hljs-type">String</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> HttpRequest.post(url)<br>    .body(json)<br>    .execute().body();<br></code></pre></td></tr></table></figure><ol start="4"><li>使用hutool的http请求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyApiClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HTTP_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://localhost:7530/api&quot;</span>;<br><br>    <span class="hljs-comment">// get</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByGet</span><span class="hljs-params">(String name)</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, name);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> HttpUtil.get(HTTP_URL + <span class="hljs-string">&quot;/name/&quot;</span>, map);<br>        System.out.println(<span class="hljs-string">&quot;get=&gt;&quot;</span> + result);<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// post传参</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByPost</span><span class="hljs-params">(String name)</span> &#123;<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, name);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> HttpUtil.post(HTTP_URL + <span class="hljs-string">&quot;/name/&quot;</span>, map);<br>        System.out.println(<span class="hljs-string">&quot;post_param=&gt;&quot;</span> + result);<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// post传对象</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameByPostJson</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSONUtil.toJsonStr(user);<br>        <span class="hljs-type">HttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> HttpRequest<br>                .post(HTTP_URL + <span class="hljs-string">&quot;/name/user&quot;</span>)<br>                .body(json)<br>                .execute();<br>        System.out.println(<span class="hljs-string">&quot;json_user_status=&gt;&quot;</span> + response.getStatus());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> response.body();<br>        System.out.println(<span class="hljs-string">&quot;json=&gt;&quot;</span> + result);<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="5"><li>测试请求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestApiClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FlyApiClient</span> <span class="hljs-variable">flyApiClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyApiClient</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">get_fly</span> <span class="hljs-operator">=</span> flyApiClient.getNameByGet(<span class="hljs-string">&quot;get_fly&quot;</span>);<br>        System.out.println(get_fly);<br>        System.out.println(<span class="hljs-string">&quot;---------------------------&quot;</span>);<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">post_param_fly</span> <span class="hljs-operator">=</span> flyApiClient.getNameByPost(<span class="hljs-string">&quot;post_param_fly&quot;</span>);<br>        System.out.println(post_param_fly);<br>        System.out.println(<span class="hljs-string">&quot;--------------------------&quot;</span>);<br>        <br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;post_json_fly&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">nameByPostJson</span> <span class="hljs-operator">=</span> flyApiClient.getNameByPostJson(user);<br>        System.out.println(nameByPostJson);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-运行截图"><a href="#3-运行截图" class="headerlink" title="3. 运行截图"></a>3. 运行截图</h1><p><img src="/images/hutool_http_1.png" alt="img.png"></p>]]></content>
    
    
    <categories>
      
      <category>Hutool</category>
      
      <category>API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hutool</tag>
      
      <tag>Http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法通关村第二关——链表指定区间反转问题解析</title>
    <link href="/post/67cb9fc5.html"/>
    <url>/post/67cb9fc5.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-反转链表-II"><a href="#1-反转链表-II" class="headerlink" title="1. 反转链表 II"></a>1. 反转链表 II</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</a><br><img src="/images/zdqjfz-1.png" alt="img.png"></p><h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><h3 id="2-1-头插法，首先肯定需要找到left的位置，但是由于这个节点需要改变，所以需要找到这个节点的前一个节点作为prev，然后这个节点就是cur，但是还需要记录后一个节点next，因为是将cur和next进行调换，所以需要保存next节点，然后将cur指向next的下一个节点，此时next节点需要指向prev的下一个节点位置，然后调整prev的下一个节点为next。"><a href="#2-1-头插法，首先肯定需要找到left的位置，但是由于这个节点需要改变，所以需要找到这个节点的前一个节点作为prev，然后这个节点就是cur，但是还需要记录后一个节点next，因为是将cur和next进行调换，所以需要保存next节点，然后将cur指向next的下一个节点，此时next节点需要指向prev的下一个节点位置，然后调整prev的下一个节点为next。" class="headerlink" title="2.1 头插法，首先肯定需要找到left的位置，但是由于这个节点需要改变，所以需要找到这个节点的前一个节点作为prev，然后这个节点就是cur，但是还需要记录后一个节点next，因为是将cur和next进行调换，所以需要保存next节点，然后将cur指向next的下一个节点，此时next节点需要指向prev的下一个节点位置，然后调整prev的下一个节点为next。"></a>2.1 头插法，首先肯定需要找到left的位置，但是由于这个节点需要改变，所以需要找到这个节点的前一个节点作为prev，然后这个节点就是cur，但是还需要记录后一个节点next，因为是将cur和next进行调换，所以需要保存next节点，然后将cur指向next的下一个节点，此时next节点需要指向prev的下一个节点位置，然后调整prev的下一个节点为next。</h3><p>核心图<br><img src="/images/zdqjfz-2.png" alt="img_1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">sentinel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    sentinel.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> sentinel;<br>    <span class="hljs-comment">// 移动到left前一个节点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;left;i++)&#123;<br>        prev=prev.next;<br>    &#125;<br>    <span class="hljs-comment">// 记录left节点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> prev.next;<br>    <span class="hljs-comment">// 存储left节点的后一个节点</span><br>    ListNode next;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;right-left;i++)&#123;<br>        <span class="hljs-comment">// 存储left节点的后一个节点</span><br>        next = cur.next;<br>        <span class="hljs-comment">// 将left节点指针指向后一个节点的后一个节点</span><br>        cur.next = next.next;<br>        <span class="hljs-comment">// 将后一个节点的指针指向left前一个节点的下一个节点</span><br>        next.next = prev.next;<br>        <span class="hljs-comment">// 然后将prev的指针指向next节点</span><br>        prev.next = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sentinel.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="/images/zdqjfz-3.png" alt="img_9.png"><br>时间复杂度：O（right）  第一次循环O（left）第二次循环O（right-left）<br>空间复杂度：O(1)</p><p>总结：头插法涉及到了4个节点的这种指向，需要好好画图才能了解，不然很头晕，一开始一直疑惑    next.next &#x3D; prev.next;作用，画完图了才知道这个只是为了后面的断开节点做准备，对于链表的这个删除插入节点还是不熟悉。</p><h2 id="2-2-穿针引线法，这个名字也挺绕的，总体思路简单，就是将链表分成三个部分，然后将中间链表反转，然后其余两个链表分别接入新链表。"><a href="#2-2-穿针引线法，这个名字也挺绕的，总体思路简单，就是将链表分成三个部分，然后将中间链表反转，然后其余两个链表分别接入新链表。" class="headerlink" title="2.2 穿针引线法，这个名字也挺绕的，总体思路简单，就是将链表分成三个部分，然后将中间链表反转，然后其余两个链表分别接入新链表。"></a>2.2 穿针引线法，这个名字也挺绕的，总体思路简单，就是将链表分成三个部分，然后将中间链表反转，然后其余两个链表分别接入新链表。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">sentinel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>       sentinel.next = head;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> sentinel;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;left-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-comment">// 找到left左边的节点</span><br>            prev =prev.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> prev;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;right-left+<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-comment">// 找到right节点</span><br>            rightNode=rightNode.next;<br>        &#125;<br>        <span class="hljs-comment">// right右边节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">rightNodeNext</span> <span class="hljs-operator">=</span> rightNode.next;<br>        <span class="hljs-comment">// left节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-comment">// 分割原链表</span><br>        rightNode.next = <span class="hljs-literal">null</span>;<br>        prev.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 反转链表</span><br>        reverseList(leftNode);<br>        <span class="hljs-comment">// 当前第一个链表指向右节点</span><br>        prev.next = rightNode;<br>        <span class="hljs-comment">// 第二个链表的右节点指向当前第三个链表</span><br>        leftNode.next = rightNodeNext;<br><br>        <span class="hljs-keyword">return</span> sentinel.next;<br><br>    &#125;<br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = prev;<br>            prev=cur;<br>            cur = nextNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/zdqjfz-4.png" alt="img_8.png"><br>时间复杂度: O(right-left)<br>空间复杂度：O(1)</p><p>总结：尤其需要注意反转链表前需要断开之前的链表</p><h1 id="2-两两交换链表中的节点"><a href="#2-两两交换链表中的节点" class="headerlink" title="2. 两两交换链表中的节点"></a>2. 两两交换链表中的节点</h1><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</a></p><h2 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h2><h3 id="2-1-1-这一题的思路主要是记录好第一个和第二个节点，然后让哨兵节点先指向第二个节点，第一个节点指向第二个节点的后一个节点，第二个节点然后指向第一个节点，那么此时交换已经完成，继续移动cur"><a href="#2-1-1-这一题的思路主要是记录好第一个和第二个节点，然后让哨兵节点先指向第二个节点，第一个节点指向第二个节点的后一个节点，第二个节点然后指向第一个节点，那么此时交换已经完成，继续移动cur" class="headerlink" title="2.1.1 这一题的思路主要是记录好第一个和第二个节点，然后让哨兵节点先指向第二个节点，第一个节点指向第二个节点的后一个节点，第二个节点然后指向第一个节点，那么此时交换已经完成，继续移动cur"></a>2.1.1 这一题的思路主要是记录好第一个和第二个节点，然后让哨兵节点先指向第二个节点，第一个节点指向第二个节点的后一个节点，第二个节点然后指向第一个节点，那么此时交换已经完成，继续移动cur</h3><p><img src="/images/zdqjfz-5.png" alt="img_7.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">sentinel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    sentinel.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> sentinel;<br>    <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-literal">null</span> &amp;&amp; cur.next.next!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">// 第一个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>        <span class="hljs-comment">// 第二个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextNext</span> <span class="hljs-operator">=</span> cur.next.next;<br>        <span class="hljs-comment">// 当前节点指向第二个节点</span><br>        cur.next = nextNext;<br>        <span class="hljs-comment">// 第一个节点指向第二个节点的下一个节点</span><br>        next.next = nextNext.next;<br>        <span class="hljs-comment">// 第二个节点指向第一个节点</span><br>        nextNext.next = next;<br>        <span class="hljs-comment">// cur变成第二个节点</span><br>        cur=next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sentinel.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="/images/zdqjfz-6.png" alt="img_6.png"><br>时间复杂度：O(n)<br>空间复杂度：O（1）</p><h1 id="3-单链表-1"><a href="#3-单链表-1" class="headerlink" title="3. 单链表+1"></a>3. 单链表+1</h1><p>用一个非空单链表来表示一个非负整数，然后将这个整数加一。你可以假设这个整数除了 0 本身，没有任何前导的 0。这个整数的各个数位按照 高位在链表头部、低位在链表尾部 的顺序排列。<br><a href="https://leetcode.cn/problems/plus-one-linked-list/"> 单链表加1</a><br><img src="/images/zdqjfz-8.png" alt="img_4.png"><br><img src="/images/zdqjfz-7.png" alt="img_5.png"></p><h2 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h2><h3 id="3-1-1-可以将链表元素写入栈里面，然后栈依次弹出，先判断时候之前没有进位，然后计算出元素和，继续判断是否有进位，然后依次将元素添加至新链表里面。总体思路和整型数据这种加法一致。"><a href="#3-1-1-可以将链表元素写入栈里面，然后栈依次弹出，先判断时候之前没有进位，然后计算出元素和，继续判断是否有进位，然后依次将元素添加至新链表里面。总体思路和整型数据这种加法一致。" class="headerlink" title="3.1.1 可以将链表元素写入栈里面，然后栈依次弹出，先判断时候之前没有进位，然后计算出元素和，继续判断是否有进位，然后依次将元素添加至新链表里面。总体思路和整型数据这种加法一致。"></a>3.1.1 可以将链表元素写入栈里面，然后栈依次弹出，先判断时候之前没有进位，然后计算出元素和，继续判断是否有进位，然后依次将元素添加至新链表里面。总体思路和整型数据这种加法一致。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">plusOne</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>      <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>          stack.push(head.value);<br>          head = head.next;<br>      &#125;<br>      <span class="hljs-comment">// 进位</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 1</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">sentinel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">while</span> (!stack.isEmpty() || carry &gt; <span class="hljs-number">0</span> || adder != <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">// 取出第一个弹出的元素</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> stack.isEmpty() ? <span class="hljs-number">0</span> : stack.pop();<br>          <span class="hljs-comment">// 计算总和</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> num + adder + carry;<br>          <span class="hljs-comment">// 先判断是否有进位</span><br>          carry = sum &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>          <span class="hljs-comment">// 判断值是否大于0</span><br>          sum = sum &gt;= <span class="hljs-number">10</span> ? sum - <span class="hljs-number">10</span> : sum;<br>          <span class="hljs-comment">// 创建新链表</span><br>          <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>          cur.next = sentinel.next;<br>          sentinel.next = cur;<br>          <span class="hljs-comment">// 加数设置为0</span><br>          adder = <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> sentinel.next;<br>  &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)将链表元素压入栈。<br>空间复杂度：O(n) 新建了一个链表。</p><p>总结：思路基本上都能想到，但是中间进位一开始放在判断求和是否大于10之后，就导致了进位永远都是0，应当是先进位，然后再处理和。</p><h3 id="3-1-2-先将链表反转，然后先从第一个开始计算，依次进位计算，不过最后需要判断进位是否为1，如果为1表名第二位有了进位，需要添加到里面去"><a href="#3-1-2-先将链表反转，然后先从第一个开始计算，依次进位计算，不过最后需要判断进位是否为1，如果为1表名第二位有了进位，需要添加到里面去" class="headerlink" title="3.1.2 先将链表反转，然后先从第一个开始计算，依次进位计算，不过最后需要判断进位是否为1，如果为1表名第二位有了进位，需要添加到里面去"></a>3.1.2 先将链表反转，然后先从第一个开始计算，依次进位计算，不过最后需要判断进位是否为1，如果为1表名第二位有了进位，需要添加到里面去</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">plusOne</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> reverseList(head);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> newHead;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> cur.value;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> carry + adder + num;<br>        carry = sum &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        sum = sum &gt;= <span class="hljs-number">10</span> ? sum - <span class="hljs-number">10</span> : sum;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>        node.next = temp;<br>        temp = node;<br>        cur = cur.next;<br>        adder = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否有进位</span><br>    <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        node.next = temp;<br>        temp = node;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNodeNext</span> <span class="hljs-operator">=</span> cur.next;<br>        cur.next = prev;<br>        prev = cur;<br>        cur = listNodeNext;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring面试题-1</title>
    <link href="/post/65da449b.html"/>
    <url>/post/65da449b.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-使用Spring框架的好处"><a href="#1-使用Spring框架的好处" class="headerlink" title="1. 使用Spring框架的好处"></a>1. 使用Spring框架的好处</h1><ol><li>面向切面编程AOP</li><li>依赖注入</li><li>声明式事务管理</li><li>IOC容器</li><li>便于测试</li></ol><h1 id="2-Spring的两大核心"><a href="#2-Spring的两大核心" class="headerlink" title="2. Spring的两大核心"></a>2. Spring的两大核心</h1><ol><li><strong>依赖反转</strong>：将对象的创建以及依赖管理交由spring管理</li><li><strong>Spring AOP</strong>：与业务无关的代码从业务中剥离出来。实现解耦。</li></ol><h1 id="3-Spring-IOC"><a href="#3-Spring-IOC" class="headerlink" title="3. Spring IOC"></a>3. Spring IOC</h1><h2 id="3-1-谈谈对Spring-IOC的理解"><a href="#3-1-谈谈对Spring-IOC的理解" class="headerlink" title="3.1 谈谈对Spring IOC的理解"></a>3.1 谈谈对Spring IOC的理解</h2><p>IOC也是称为控制反转，是一种<strong>设计思想</strong>，并不是一种技术的实现。Spring IOC主要是将原本手动创建对象的控制权，交给spring框架来管理。实现了松耦合与可重用性。</p><h2 id="3-2-Spring-IOC的实现机制"><a href="#3-2-Spring-IOC的实现机制" class="headerlink" title="3.2 Spring IOC的实现机制"></a>3.2 Spring IOC的实现机制</h2><ol><li><strong>定义一个Bean</strong>：所有的对象都可以看作是一个bean,需要在配置文件或者注解的方式进行配置和定义</li><li><strong>创建Bean工厂</strong>：Bean工厂管理Bean的创建，组装，销毁等任务。</li><li><strong>读取配置文件</strong>：Spring IOC容器会读取配置文件或者注解的方式来获取Bean的定义和配置信息。</li><li><strong>创建Bean实例</strong>：Spring IOC会根据配置文件里面的信息，使用反射技术创建Bean实例，保存在容器在容器里面。</li><li><strong>组装Bean</strong>：根据配置文件的信息，将不同的Bean实例组装起来，形成完整的应用程序。</li><li><strong>注入依赖</strong>：自动为Bean注入依赖的对象或者值。</li><li><strong>提供Bean实例</strong>：通过容器获取需要的Bean实例，从而使用其中的方法和属性</li></ol><h2 id="3-3-将一个类声明为一个Bean有哪些注解？"><a href="#3-3-将一个类声明为一个Bean有哪些注解？" class="headerlink" title="3.3 将一个类声明为一个Bean有哪些注解？"></a>3.3 将一个类声明为一个Bean有哪些注解？</h2><p>@Component:  标记任意类为spring组件<br>@Repository:  持久层，和数据库相关操作<br>@Service：  服务层，处理复杂逻辑，使用Dao层<br>@Controller：Spring MVC控制层，调用service数据返回前端数据</p><h2 id="3-4-Componet和-Bean有什么区别？"><a href="#3-4-Componet和-Bean有什么区别？" class="headerlink" title="3.4 @Componet和@Bean有什么区别？"></a>3.4 @Componet和@Bean有什么区别？</h2><ol><li>@Component注解作用于类，而@Bean 作用于方法</li><li>@Componet可以通过@ComponetScan扫描路径自动装配到Spring里面去，@Bean只是标注这个方法上产生这个Bean</li><li>@Bean自定义行强，比如引入第三方类需要使用@Bean</li></ol><h2 id="3-5-Autowired和-Resource的区别？"><a href="#3-5-Autowired和-Resource的区别？" class="headerlink" title="3.5 @Autowired和@Resource的区别？"></a>3.5 @Autowired和@Resource的区别？</h2><ol><li>@Autowired是Spring提供的，@Resource是JDK提供的。</li><li>@Autowired默认使用byType(类型匹配)，而@Resource默认是byName</li><li>当一个接口存在多个实现类，两者都需要使用名字来正确匹配Bean。@Autowired通过@Qualifier注解显示名称，@ Resource通过name属性指定名称。</li></ol><h2 id="3-6-Bean线程是安全的吗？"><a href="#3-6-Bean线程是安全的吗？" class="headerlink" title="3.6 Bean线程是安全的吗？"></a>3.6 Bean线程是安全的吗？</h2><p>protoType：每次创建一个新的bean，不存在资源竞争问题<br>singeton：IOC容器里面只有一个bean实例，可能存在资源抢占，如果这个bean是有状态的话（包含成员变量）<br>解决方法：</p><ol><li>避免使用成员变量</li><li>使用ThreadLocal</li></ol><h2 id="3-7-Bean的生命周期"><a href="#3-7-Bean的生命周期" class="headerlink" title="3.7 Bean的生命周期"></a>3.7 Bean的生命周期</h2><ol><li>实例化Bean：spring根据配置文件或注解方式创建Bean实例，存储在容器里面</li><li>属性注入：spring自动将属性值从配置文件或注解方式注入到bean实例里面去</li><li>初始化：调用bean的 init完成实例化，完成初始操作，例如数据库连接。</li><li>使用：bean正常使用，供程序调用</li><li>销毁：调用bean里面的destory-method完成资源的释放，例如关闭数据库</li></ol>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis面试题-3</title>
    <link href="/post/3d665699.html"/>
    <url>/post/3d665699.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Redis切片集群？"><a href="#1-什么是Redis切片集群？" class="headerlink" title="1. 什么是Redis切片集群？"></a>1. 什么是Redis切片集群？</h1><p>部署多台redis主节点，这些节点平等，并没有主从之说，同时对外提供读写能力，缓存的数据均匀的分布在这些redis实力上，客户端通过路由规则转发到目标master上</p><h1 id="2-Redis-Cluster集群优点"><a href="#2-Redis-Cluster集群优点" class="headerlink" title="2. Redis Cluster集群优点"></a>2. Redis Cluster集群优点</h1><ol><li>可以横向扩展缓解写压力和存储压力，动态扩容与缩容</li><li>主从复制，故障转移（内置sentinel）等等</li></ol><h1 id="3-Redis里面的Cluster节点如何通信？"><a href="#3-Redis里面的Cluster节点如何通信？" class="headerlink" title="3. Redis里面的Cluster节点如何通信？"></a>3. Redis里面的Cluster节点如何通信？</h1><p>Gossip协议</p><h1 id="4-Redis-cluster是如何进行分片的？-数据是如何分布的？-如何确定key分配到哪个哈希槽中？"><a href="#4-Redis-cluster是如何进行分片的？-数据是如何分布的？-如何确定key分配到哪个哈希槽中？" class="headerlink" title="4. Redis cluster是如何进行分片的？&#x2F;数据是如何分布的？&#x2F;如何确定key分配到哪个哈希槽中？"></a>4. Redis cluster是如何进行分片的？&#x2F;数据是如何分布的？&#x2F;如何确定key分配到哪个哈希槽中？</h1><p>采用的是哈希槽分区，每个键值对都属于一个哈希槽，通常由16384个哈希槽，然后通过相应的key确定应该分到哪个哈希槽里面。<br>当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标节点。</p><h1 id="5-Redis-Cluster扩容期间可以提供服务吗？-key所在的哈希槽正在迁移怎么办-如何确定key应该分布到哪个哈希槽？"><a href="#5-Redis-Cluster扩容期间可以提供服务吗？-key所在的哈希槽正在迁移怎么办-如何确定key应该分布到哪个哈希槽？" class="headerlink" title="5. Redis Cluster扩容期间可以提供服务吗？&#x2F;key所在的哈希槽正在迁移怎么办&#x2F;如何确定key应该分布到哪个哈希槽？"></a>5. Redis Cluster扩容期间可以提供服务吗？&#x2F;key所在的哈希槽正在迁移怎么办&#x2F;如何确定key应该分布到哪个哈希槽？</h1><p>Redis Cluster扩容和缩容的本质是进行重新分片，动态迁移哈希槽。<br>能够保证Redis扩容期间依然能够对外提供正常服务，提供了重定向机制：</p><ol><li>ASK重定向：临时重定向，查询发送旧节点</li><li>MOVED重定向：永久重定向，后续查询发送新节点</li></ol>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法通关村第二关——终于学会链表反转了</title>
    <link href="/post/e58bcd03.html"/>
    <url>/post/e58bcd03.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1. 反转链表"></a>1. 反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</a></p><h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><h3 id="2-1-如果不考虑使用链表反转的话，其实可以借助栈来实现，但是这里就不考虑了。链表反转就是将当前节点指向前一个节点，之前需要记录下一个节点，简单的写法是需要使用一个虚拟节点指向下一个节点。"><a href="#2-1-如果不考虑使用链表反转的话，其实可以借助栈来实现，但是这里就不考虑了。链表反转就是将当前节点指向前一个节点，之前需要记录下一个节点，简单的写法是需要使用一个虚拟节点指向下一个节点。" class="headerlink" title="2.1 如果不考虑使用链表反转的话，其实可以借助栈来实现，但是这里就不考虑了。链表反转就是将当前节点指向前一个节点，之前需要记录下一个节点，简单的写法是需要使用一个虚拟节点指向下一个节点。"></a>2.1 如果不考虑使用链表反转的话，其实可以借助栈来实现，但是这里就不考虑了。链表反转就是将当前节点指向前一个节点，之前需要记录下一个节点，简单的写法是需要使用一个虚拟节点指向下一个节点。</h3><p>画图流程<br><img src="/images/xhlbfz-1.png" alt="img.png"><br>完整图<br><img src="/images/xhlbfz-2.png" alt="img_1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">sentinel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>      <span class="hljs-keyword">while</span>(curr!=<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> curr.next;<br>          curr.next = sentinel.next;<br>          sentinel.next = curr;<br>          curr = nextNode;<br>      &#125;<br>      <span class="hljs-keyword">return</span> sentinel.next;<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="/images/xhlbfz-3.png" alt="img_2.png"><br>时间复杂度: O(n)<br>空间复杂度: O(1)</p><p>总结：这个刚开始写的时候，有点绕，一直不怎么理解为什么虚拟节点的下一个指向当前节点的位置，而且不会影响之前的节点，这个还是需要进一步画图才能理解。</p><h2 id="2-2-但是有的时候面试，不让使用虚拟节点，只能使用链表里面的节点，设置一个空节点prev，然后让当前节点指向空节点prev，然后prev再移动到当前节点，依次添加节点，那么走到最后prev就是第一个节点了，理清楚原理，也还是容易的。"><a href="#2-2-但是有的时候面试，不让使用虚拟节点，只能使用链表里面的节点，设置一个空节点prev，然后让当前节点指向空节点prev，然后prev再移动到当前节点，依次添加节点，那么走到最后prev就是第一个节点了，理清楚原理，也还是容易的。" class="headerlink" title="2.2 但是有的时候面试，不让使用虚拟节点，只能使用链表里面的节点，设置一个空节点prev，然后让当前节点指向空节点prev，然后prev再移动到当前节点，依次添加节点，那么走到最后prev就是第一个节点了，理清楚原理，也还是容易的。"></a>2.2 但是有的时候面试，不让使用虚拟节点，只能使用链表里面的节点，设置一个空节点prev，然后让当前节点指向空节点prev，然后prev再移动到当前节点，依次添加节点，那么走到最后prev就是第一个节点了，理清楚原理，也还是容易的。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-type">ListNode</span>  <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> cur.next;<br>           cur.next = prev;<br>           prev = cur;<br>           cur = nextNode;<br>       &#125;<br>       <span class="hljs-keyword">return</span> prev;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="/images/xhlbfz-4.png" alt="img_3.png"><br>时间复杂度和空间复杂度和上面的一样</p><p>总结：相对来说这个方法我还是能够容易理解的。</p><h2 id="2-3-第三个就是递归了，让每次递归出来的节点都指向前一个节点，但是这个需要判断当前节点以及后一个节点是否为空的情况。"><a href="#2-3-第三个就是递归了，让每次递归出来的节点都指向前一个节点，但是这个需要判断当前节点以及后一个节点是否为空的情况。" class="headerlink" title="2.3 第三个就是递归了，让每次递归出来的节点都指向前一个节点，但是这个需要判断当前节点以及后一个节点是否为空的情况。"></a>2.3 第三个就是递归了，让每次递归出来的节点都指向前一个节点，但是这个需要判断当前节点以及后一个节点是否为空的情况。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>    head.next.next = head;<br>    head.next = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> node;<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/xhlbfz-5.png" alt="img_4.png"><br>时间复杂度：O(n)<br>空间复杂度：O(n) 递归深度</p><p>总结：递归也是能够理解的，但是实际操作上很少使用递归。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>链表反转的前两个方法一定需要记住，很常用。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis面试题-2</title>
    <link href="/post/4a61660f.html"/>
    <url>/post/4a61660f.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Redis事务"><a href="#1-Redis事务" class="headerlink" title="1. Redis事务"></a>1. Redis事务</h1><h2 id="1-1-什么是redis事务？"><a href="#1-1-什么是redis事务？" class="headerlink" title="1.1 什么是redis事务？"></a>1.1 什么是redis事务？</h2><p>可以将一个或者多个命令请求打包处理，然后再按顺序执行打包的所有命令，并且不会被中途打断。(不建议使用)</p><h2 id="1-2-如何使用redis事务"><a href="#1-2-如何使用redis事务" class="headerlink" title="1.2 如何使用redis事务"></a>1.2 如何使用redis事务</h2><p>redis可以通过使用multi，exec，discard，watch<br>multi:  输入多个命令放入队列<br>exec:  执行命令<br>discard：取消事务,清空队列里面的命令<br>watch：watch监听指定的key，当被监听的key被修改了，整个事务都不会执行</p><h2 id="1-3Redis事务支持原子性吗？"><a href="#1-3Redis事务支持原子性吗？" class="headerlink" title="1.3Redis事务支持原子性吗？"></a>1.3Redis事务支持原子性吗？</h2><p>事务四大特性：原子性，一致性，隔离性，持久性<br>redis事务只有在运行错误的时候会弹出报错，其他命令都能执行，而且不支持事务回滚，是不满足事务的原子性的。</p><h2 id="1-4-Redis事务支持久化吗？"><a href="#1-4-Redis事务支持久化吗？" class="headerlink" title="1.4 Redis事务支持久化吗？"></a>1.4 Redis事务支持久化吗？</h2><p>Redis持久化方式</p><ol><li>RDB</li><li>AOF</li><li>RDB+AOF</li></ol><p>而AOF相应的持久化策略里面只有appendfsync always能够基本满足要求，但是性能太低，而sec，no两者都会存在数据丢失，没办法保证持久性。</p><h2 id="1-5-Redis事务还有哪些缺陷"><a href="#1-5-Redis事务还有哪些缺陷" class="headerlink" title="1.5 Redis事务还有哪些缺陷"></a>1.5 Redis事务还有哪些缺陷</h2><p>除了原子性，持久性不满足，每条命令都需要与服务器进行交互，浪费资源，不能批量执行</p><h2 id="1-6-如何解决Redis事务的缺陷？"><a href="#1-6-如何解决Redis事务的缺陷？" class="headerlink" title="1.6 如何解决Redis事务的缺陷？"></a>1.6 如何解决Redis事务的缺陷？</h2><p>采用lua脚本，可以一次性执行多个redis命令，减少资源消耗，但是需要保证lua脚本里面的语法都是对的，如果有语法错误，不会有回滚，也是不满足原子性的要求。<br>采用redis functions（比lua脚本更强大）</p><h1 id="2-Redis性能优化"><a href="#2-Redis性能优化" class="headerlink" title="2.Redis性能优化"></a>2.Redis性能优化</h1><h2 id="2-1-使用批量操作减少网络传输"><a href="#2-1-使用批量操作减少网络传输" class="headerlink" title="2.1 使用批量操作减少网络传输"></a>2.1 使用批量操作减少网络传输</h2><h2 id="2-2-大量的key集中过期的问题"><a href="#2-2-大量的key集中过期的问题" class="headerlink" title="2.2 大量的key集中过期的问题"></a>2.2 大量的key集中过期的问题</h2><p>redis一般采取定期删除+惰性删除<br>但是遇到大量的key集中过期，客户端需要等待将这些过期key完全删除才能进行下一步操作，这个任务是在主线程中。</p><h2 id="2-3-Redis-BigKey（了解）"><a href="#2-3-Redis-BigKey（了解）" class="headerlink" title="2.3 Redis BigKey（了解）"></a>2.3 Redis BigKey（了解）</h2><h3 id="2-3-1-什么是BigKey？有什么危害？"><a href="#2-3-1-什么是BigKey？有什么危害？" class="headerlink" title="2.3.1 什么是BigKey？有什么危害？"></a>2.3.1 什么是BigKey？有什么危害？</h3><p>一个key对应的value越大，内存占用越大。bigkek会消耗内存，影响性能。</p><h3 id="2-3-2-如何处理bigkey"><a href="#2-3-2-如何处理bigkey" class="headerlink" title="2.3.2 如何处理bigkey"></a>2.3.2 如何处理bigkey</h3><ol><li>分割bigkey</li><li>手动清理</li><li>采用合适数据结构</li><li>开启lazy_free</li></ol><h1 id="3-Redis内存碎片"><a href="#3-Redis内存碎片" class="headerlink" title="3. Redis内存碎片"></a>3. Redis内存碎片</h1><h2 id="3-1-什么是内存碎片？为什么会有redis内存碎片？"><a href="#3-1-什么是内存碎片？为什么会有redis内存碎片？" class="headerlink" title="3.1 什么是内存碎片？为什么会有redis内存碎片？"></a>3.1 什么是内存碎片？为什么会有redis内存碎片？</h2><p>内存碎片可以看作不可用的闲置空间<br>产生原因：</p><ol><li>Redis存储数据的时候向操作系统申请的内存空间大于实际数据需要的空间</li><li>频繁修改Redis里面数据</li></ol><h1 id="4-Redis生产问题"><a href="#4-Redis生产问题" class="headerlink" title="4. Redis生产问题"></a>4. Redis生产问题</h1><h2 id="4-1-缓存穿透"><a href="#4-1-缓存穿透" class="headerlink" title="4.1 缓存穿透"></a>4.1 缓存穿透</h2><h3 id="4-1-1-什么是缓存穿透？"><a href="#4-1-1-什么是缓存穿透？" class="headerlink" title="4.1.1 什么是缓存穿透？"></a>4.1.1 什么是缓存穿透？</h3><p>大量请求的key是不合理的，既不存在缓存中，也不存在数据库中。导致所有的请求直接到数据库上，没有经过缓存，数据库造成压力</p><h3 id="4-1-2-如何解决"><a href="#4-1-2-如何解决" class="headerlink" title="4.1.2 如何解决"></a>4.1.2 如何解决</h3><ol><li>缓存无效key</li><li>使用布隆过滤器，判断key是否合法</li></ol><h3 id="4-1-3-是什么是布隆过滤器"><a href="#4-1-3-是什么是布隆过滤器" class="headerlink" title="4.1.3 是什么是布隆过滤器"></a>4.1.3 是什么是布隆过滤器</h3><p>添加元素：</p><ol><li>通过哈希函数对元素值进行计算，得到哈希值。</li><li>在位数组对应下标设置为1</li></ol><p>查询元素:</p><ol><li>使用同样方式对key进行哈希计算，得到哈希值</li><li>判断哈希值相应数组下标是否为1，1表示存在，0表示不存在</li></ol><p>会有误判，比如不同的字符串会计算相同的哈希值</p><h2 id="4-2缓存击穿"><a href="#4-2缓存击穿" class="headerlink" title="4.2缓存击穿"></a>4.2缓存击穿</h2><h3 id="4-2-1-什么是缓存击穿？"><a href="#4-2-1-什么是缓存击穿？" class="headerlink" title="4.2.1 什么是缓存击穿？"></a>4.2.1 什么是缓存击穿？</h3><p>请求的key是热点数据，这个数据存在数据库，但是不存在与缓存里面（缓存数据过期），增加数据库压力</p><h3 id="4-2-2-解决方式"><a href="#4-2-2-解决方式" class="headerlink" title="4.2.2 解决方式"></a>4.2.2 解决方式</h3><ol><li>热点数据过期时间长</li><li>缓存预热</li><li>请求数据库写数据到缓存里面之前，先获取互斥锁，保证只有一个请求落到数据库上，减少数据库压力</li></ol><h3 id="4-2-3-缓存击穿和缓存穿透有什么区别？"><a href="#4-2-3-缓存击穿和缓存穿透有什么区别？" class="headerlink" title="4.2.3 缓存击穿和缓存穿透有什么区别？"></a>4.2.3 缓存击穿和缓存穿透有什么区别？</h3><ol><li>缓存击穿里面的key是热点数据，存在数据库，但是不存在于缓存</li><li>缓存穿透，请求的key既不存在数据库也不存在缓存</li></ol><h2 id="4-3-缓存雪崩"><a href="#4-3-缓存雪崩" class="headerlink" title="4.3 缓存雪崩"></a>4.3 缓存雪崩</h2><h3 id="4-3-1-什么是缓存雪崩？"><a href="#4-3-1-什么是缓存雪崩？" class="headerlink" title="4.3.1 什么是缓存雪崩？"></a>4.3.1 什么是缓存雪崩？</h3><p>缓存同一时间大面积失效，导致请求全部落在数据上。</p><h3 id="4-3-2-解决方法"><a href="#4-3-2-解决方法" class="headerlink" title="4.3.2 解决方法"></a>4.3.2 解决方法</h3><p>Redis服务不可用</p><ol><li>搭建集群</li><li>限流</li></ol><p>热点缓存失效</p><ol><li>设置不同的失效时间</li><li>缓存不失效</li><li>二级缓存</li></ol><h2 id="4-4-如何保证缓存数据和数据库数据是一致性的"><a href="#4-4-如何保证缓存数据和数据库数据是一致性的" class="headerlink" title="4.4 如何保证缓存数据和数据库数据是一致性的"></a>4.4 如何保证缓存数据和数据库数据是一致性的</h2><ol><li>旁路缓存模式：更新DB，删除缓存<br>a. 更新数据库成功，缓存删除失败，使用缓存失效时间变短(不推荐)<br>b. 增加cache更新重试机制</li><li>更新缓存，更新数据库</li><li>更新数据库，更新缓存</li><li>删除缓存，更新数据库</li></ol><h1 id="5-Redis集群"><a href="#5-Redis集群" class="headerlink" title="5. Redis集群"></a>5. Redis集群</h1><h2 id="5-1-如何保证redis服务高可用"><a href="#5-1-如何保证redis服务高可用" class="headerlink" title="5.1 如何保证redis服务高可用"></a>5.1 如何保证redis服务高可用</h2><p>Redis sentinel实现redis集群高可用，只是在主从复制实现集群的基础上，多了一个Sentinel角色帮我们监控Redis节点的运行状态，并且实现故障转移。<br>当master节点出现故障的时候，sentinel可以帮我住我们实现故障转移，按照一定规则从salve里面选出升级成为master,确保高可用，不需要人工介入。</p><h2 id="5-2-Sentinel有什么用？"><a href="#5-2-Sentinel有什么用？" class="headerlink" title="5.2 Sentinel有什么用？"></a>5.2 Sentinel有什么用？</h2><ol><li>监控：监控各个节点是否异常（包括自己）</li><li>故障转移：当master出现故障的时候，sentinel能够从salve里面更具相应的规则选出新的master，确保可用性</li><li>通知：通知slave节点新的master信息，使它们全部转移到新的master的slave</li><li>配置提供：客户端连接sentinel请求新的master地址，如果出现故障转移，sentinel会通知新的master节点给客户端</li></ol><h2 id="5-3-Sentinel如何检测节点下线"><a href="#5-3-Sentinel如何检测节点下线" class="headerlink" title="5.3 Sentinel如何检测节点下线"></a>5.3 Sentinel如何检测节点下线</h2><ol><li>主观下线：sentinel认为某个节点已经下线，但是还不确定，需要其他sentinel来确定</li><li>客观下线：多个sentinel节点认为某个redis节点已经下线。</li></ol><h2 id="5-4-Sentinel如何选出新的master节点"><a href="#5-4-Sentinel如何选出新的master节点" class="headerlink" title="5.4 Sentinel如何选出新的master节点"></a>5.4 Sentinel如何选出新的master节点</h2><ol><li>slave优先级</li><li>复制进度：会优先选择出数据和master数据最接近的节点</li><li>运行id</li></ol><h2 id="5-5-Sentinel如何选出Leader"><a href="#5-5-Sentinel如何选出Leader" class="headerlink" title="5.5 Sentinel如何选出Leader"></a>5.5 Sentinel如何选出Leader</h2><p>使用raft算法</p><h2 id="5-6-为什么建议部署多个sentinel节点（哨兵集群）"><a href="#5-6-为什么建议部署多个sentinel节点（哨兵集群）" class="headerlink" title="5.6 为什么建议部署多个sentinel节点（哨兵集群）"></a>5.6 为什么建议部署多个sentinel节点（哨兵集群）</h2><ol><li>多个sentinel可以通过投票的方式判断某个节点受否故障，避免误判</li><li>sentinel本身就是高可用</li></ol><h2 id="5-7-Sentinel可以防止脑裂吗？"><a href="#5-7-Sentinel可以防止脑裂吗？" class="headerlink" title="5.7 Sentinel可以防止脑裂吗？"></a>5.7 Sentinel可以防止脑裂吗？</h2><p>脑裂是指分布式系统里面，不同节点之间通信互相影响，导致数据不同步，出现影响<br>可以，sentinel提供流量控制以及监控</p><h2 id="5-8-Redis缓存的数据量太大怎么办？"><a href="#5-8-Redis缓存的数据量太大怎么办？" class="headerlink" title="5.8 Redis缓存的数据量太大怎么办？"></a>5.8 Redis缓存的数据量太大怎么办？</h2><p>采用Redis Cluster</p><h2 id="5-9-为什么要使用Redis-Cluster？"><a href="#5-9-为什么要使用Redis-Cluster？" class="headerlink" title="5.9 为什么要使用Redis Cluster？"></a>5.9 为什么要使用Redis Cluster？</h2><ol><li>缓存的数据量太大</li><li>并发量要求太大</li></ol><h2 id="5-10-Redis-Cluster虚拟槽分区有什么优点？"><a href="#5-10-Redis-Cluster虚拟槽分区有什么优点？" class="headerlink" title="5.10 Redis Cluster虚拟槽分区有什么优点？"></a>5.10 Redis Cluster虚拟槽分区有什么优点？</h2><ol><li>解耦了数据和节点之间的关系</li><li>提升了集群的横向扩展和容错性</li></ol>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法通关村第一关——链表经典问题之删除链表元素笔记</title>
    <link href="/post/64cd7498.html"/>
    <url>/post/64cd7498.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-题目-：移除链表元素"><a href="#1-题目-：移除链表元素" class="headerlink" title="1. 题目 ：移除链表元素"></a>1. 题目 ：移除链表元素</h1><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。<br><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣</a></p><h2 id="1-2-分析"><a href="#1-2-分析" class="headerlink" title="1.2 分析"></a>1.2 分析</h2><h3 id="1-2-1-这里没啥好分析的，就是查找是否相同的节点元素，但是需要注意要保存前一个节点的位置，然后和删除节点的后一个位置建立联系。"><a href="#1-2-1-这里没啥好分析的，就是查找是否相同的节点元素，但是需要注意要保存前一个节点的位置，然后和删除节点的后一个位置建立联系。" class="headerlink" title="1.2.1 这里没啥好分析的，就是查找是否相同的节点元素，但是需要注意要保存前一个节点的位置，然后和删除节点的后一个位置建立联系。"></a>1.2.1 这里没啥好分析的，就是查找是否相同的节点元素，但是需要注意要保存前一个节点的位置，然后和删除节点的后一个位置建立联系。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        res.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> res;<br>        <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cur.next.val == val)&#123;<br>                cur.next = cur.next.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur =cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbsclb-1.png" alt="img.png"><br>时间复杂度：O(n) 遍历了一次链表<br>空间复杂度:  O(1)</p><h1 id="2-题目：删除链表的倒数第-N-个结点"><a href="#2-题目：删除链表的倒数第-N-个结点" class="headerlink" title="2. 题目：删除链表的倒数第 N 个结点"></a>2. 题目：删除链表的倒数第 N 个结点</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣</a></p><h2 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h2><h3 id="2-1-1-使用快慢指针，倒数第n的节点，就保持快慢指针之间相差n个节点，当快指针的next走到null的时候，这时候就是删除节点的前一个节点位置，然后指向删除节点的后一个节点。"><a href="#2-1-1-使用快慢指针，倒数第n的节点，就保持快慢指针之间相差n个节点，当快指针的next走到null的时候，这时候就是删除节点的前一个节点位置，然后指向删除节点的后一个节点。" class="headerlink" title="2.1.1 使用快慢指针，倒数第n的节点，就保持快慢指针之间相差n个节点，当快指针的next走到null的时候，这时候就是删除节点的前一个节点位置，然后指向删除节点的后一个节点。"></a>2.1.1 使用快慢指针，倒数第n的节点，就保持快慢指针之间相差n个节点，当快指针的next走到null的时候，这时候就是删除节点的前一个节点位置，然后指向删除节点的后一个节点。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-comment">// 快指针先走n步</span><br>       <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>           fast = fast.next;<br>           n--;<br>       &#125;<br>       <span class="hljs-comment">// 防止是头节点</span><br>       <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> head.next;<br>       &#125;<br>       <span class="hljs-comment">// 同时移动</span><br>       <span class="hljs-keyword">while</span>(fast.next!=<span class="hljs-literal">null</span>)&#123;<br>           slow = slow.next;<br>           fast = fast.next;<br>       &#125;<br>       <span class="hljs-comment">// 删除元素</span><br>       slow.next = slow.next.next;<br>       <span class="hljs-keyword">return</span> head;<br>   &#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="/images/lbsclb-2.png" alt="img.png"><br>时间复杂度：O(n)遍历一次链表<br>空间复杂度：O(1)</p><p>总结：看一看见快慢指针速度还是可以的，不过尤其需要注意里面需要判断快指针是否为空的情况，这个时候意味着删除的就是头节点。</p><h2 id="2-1-2-使用链表长度，通过正向找到节点的前一个节点的位置，然后指向删除节点的后一个节点。"><a href="#2-1-2-使用链表长度，通过正向找到节点的前一个节点的位置，然后指向删除节点的后一个节点。" class="headerlink" title="2.1.2 使用链表长度，通过正向找到节点的前一个节点的位置，然后指向删除节点的后一个节点。"></a>2.1.2 使用链表长度，通过正向找到节点的前一个节点的位置，然后指向删除节点的后一个节点。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">sentail</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>   sentail.next = head;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span>head;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> sentail;<br>    <span class="hljs-comment">// 计算长度</span><br>   <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(currentNode!=<span class="hljs-literal">null</span>)&#123;<br>    currentNode = currentNode.next;<br>    length++;<br>   &#125;<br><span class="hljs-comment">// 移动第length-n-1元素位置</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length-n;i++)&#123;<br>      temp = temp.next;<br>   &#125;<br>    <span class="hljs-comment">// 删除</span><br>   temp.next = temp.next.next;<br> <span class="hljs-keyword">return</span> sentail.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="/images/lbsclb-3.png" alt="img.png"><br>时间复杂度: O(n) 第一次遍历链表 O(n)第二次遍历部分链表O(k)k表示删除节点元素的位置，总体是O(n)<br>空间复杂度: O(1)</p><p>总结：我没想到的是内存消耗比快慢指针的还要小。</p><h1 id="3-删除排序链表中的重复元素"><a href="#3-删除排序链表中的重复元素" class="headerlink" title="3. 删除排序链表中的重复元素"></a>3. 删除排序链表中的重复元素</h1><h2 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h2><h3 id="3-1-1-先定位到当前节点，判断前后节点的值是否一样，一样就跳过第二个节点，否则正常向后遍历"><a href="#3-1-1-先定位到当前节点，判断前后节点的值是否一样，一样就跳过第二个节点，否则正常向后遍历" class="headerlink" title="3.1.1 先定位到当前节点，判断前后节点的值是否一样，一样就跳过第二个节点，否则正常向后遍历"></a>3.1.1 先定位到当前节点，判断前后节点的值是否一样，一样就跳过第二个节点，否则正常向后遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(currentNode.next!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(currentNode.val == currentNode.next.val)&#123;<br>                currentNode.next = currentNode.next.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                currentNode = currentNode.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="https://img-blog.csdnimg.cn/9b64d259d805433390fc44f4df316309.png" alt="在这里插入图片描述"><br>时间复杂度：O(n)<br>空间复杂度:  O(1)</p><p>总结：每次执行这种需要下一个节点的，记住需要判断头节点是否为空</p><h1 id="4-删除排序链表中的重复元素-II"><a href="#4-删除排序链表中的重复元素-II" class="headerlink" title="4. 删除排序链表中的重复元素 II"></a>4. 删除排序链表中的重复元素 II</h1><p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。<br><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">力扣</a></p><h2 id="4-1-分析"><a href="#4-1-分析" class="headerlink" title="4.1 分析"></a>4.1 分析</h2><h3 id="4-1-1-发现这一题和上面的题目一样，但是i这一题不需要重复数据而是都删除。"><a href="#4-1-1-发现这一题和上面的题目一样，但是i这一题不需要重复数据而是都删除。" class="headerlink" title="4.1.1 发现这一题和上面的题目一样，但是i这一题不需要重复数据而是都删除。"></a>4.1.1 发现这一题和上面的题目一样，但是i这一题不需要重复数据而是都删除。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">sentail</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>      sentail.next = head;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> sentail;<br>      <span class="hljs-comment">// 下一个节点和下下一个节点都不为空</span><br>      <span class="hljs-keyword">while</span>(current.next!=<span class="hljs-literal">null</span> &amp;&amp; current.next.next !=<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-comment">// 判断下个节点和下下节点是否值一致</span><br>          <span class="hljs-keyword">if</span>(current.next.val == current.next.next.val)&#123;<br>              <span class="hljs-comment">// 保存相同的值</span><br>              <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span>current.next.val;<br>              <span class="hljs-comment">// 当前节点的下一个值不为空，值等于x，跳过当前节点</span><br>              <span class="hljs-keyword">while</span>(current.next!=<span class="hljs-literal">null</span> &amp;&amp; current.next.val == x)&#123;<br>                  current.next = current.next.next;<br>              &#125;<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>              current = current.next;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> sentail.next;<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbsclb-4.png" alt="img.png"><br>时间复杂度：O(n)<br>空间复杂度：O(n)</p><p>总结：原本以为很贱的，但是实际操作发现中间有些步骤还是有点难以考虑到，比如需要记录下下一个节点和下下节点的共同值，然后判断当前的下一个节点是否是这个共同值，是的话就跳过，比第三题多了一点限制条件，一开始不理解为什么要先记录共同值，现在了解了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>删除链表节点这一块核心是需要找到当前删除节点的前后关系的节点，后两题目也是差不多意思，只不过第四题需要先将值先保存，判断下一个和下下一个节点关系。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法通关村第一关——链表经典问题之双指针笔记</title>
    <link href="/post/e035491a.html"/>
    <url>/post/e035491a.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-题目：链表的中间结点"><a href="#1-题目：链表的中间结点" class="headerlink" title="1. 题目：链表的中间结点"></a>1. 题目：链表的中间结点</h1><p>给你单链表的头结点 head ，请你找出并返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。<br><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">力扣</a></p><h2 id="1-1-分析"><a href="#1-1-分析" class="headerlink" title="1.1 分析"></a>1.1 分析</h2><h3 id="1-1-1-第一想法，使用计数器先统计处所有长度，然后再来个计数器让指针移动到中间位置时停止，此时就可以获取中间链表了。"><a href="#1-1-1-第一想法，使用计数器先统计处所有长度，然后再来个计数器让指针移动到中间位置时停止，此时就可以获取中间链表了。" class="headerlink" title="1.1.1 第一想法，使用计数器先统计处所有长度，然后再来个计数器让指针移动到中间位置时停止，此时就可以获取中间链表了。"></a>1.1.1 第一想法，使用计数器先统计处所有长度，然后再来个计数器让指针移动到中间位置时停止，此时就可以获取中间链表了。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(current!=<span class="hljs-literal">null</span>)  &#123;<br>           current = current.next;<br>           length++;<br>       &#125;   <br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(count &lt; length/<span class="hljs-number">2</span>)&#123;<br>           head=head.next;<br>           count++;<br>       &#125;<br>       <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbszz-1.png" alt="img.png"><br>时间复杂度：O(n)里面两次遍历使用计数器<br>空间复杂度:  O(1)</p><p>总结：思路还是很清晰的，使用两个计数器</p><h3 id="1-1-2-很显然，这个专题是双指针，肯定是双指针来的快，那么就要思考如何使用双指针，我可以定义一个快慢指针，快指针走两个，慢指针走一个，最后快指针结束了，那么中间节点位置就是慢指针的位置"><a href="#1-1-2-很显然，这个专题是双指针，肯定是双指针来的快，那么就要思考如何使用双指针，我可以定义一个快慢指针，快指针走两个，慢指针走一个，最后快指针结束了，那么中间节点位置就是慢指针的位置" class="headerlink" title="1.1.2 很显然，这个专题是双指针，肯定是双指针来的快，那么就要思考如何使用双指针，我可以定义一个快慢指针，快指针走两个，慢指针走一个，最后快指针结束了，那么中间节点位置就是慢指针的位置"></a>1.1.2 很显然，这个专题是双指针，肯定是双指针来的快，那么就要思考如何使用双指针，我可以定义一个快慢指针，快指针走两个，慢指针走一个，最后快指针结束了，那么中间节点位置就是慢指针的位置</h3><p><img src="/images/lbszz-2.png" alt="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span>head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.next!=<span class="hljs-literal">null</span>)&#123;<br>        slow=slow.next;<br>        fast=fast.next.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>   &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbszz-3.png" alt="img.png"><br>时间复杂度：O(n)，遍历一次链表<br>空间复杂度: O(1)</p><p>总结：很明显，快慢指针时间空间上性能都很高，这里不需要考虑是否慢指针需要因为奇数偶数而再向后移动，因为条件里面的快指针就是条件，只要满足，最后慢指针就是结果</p><h1 id="2-题目：-链表中倒数第k个节点"><a href="#2-题目：-链表中倒数第k个节点" class="headerlink" title="2. 题目： 链表中倒数第k个节点"></a>2. 题目： 链表中倒数第k个节点</h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。<br>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。<br><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">力扣</a></p><h2 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h2><h3 id="2-1-1-采用快慢指针，先让快指针走k步，让快慢指针里面相差k步，然后两个指针同时走，直到快指针为null，那么慢指针就走到了倒数第k个节点，那么这个节点就是需要的节点。"><a href="#2-1-1-采用快慢指针，先让快指针走k步，让快慢指针里面相差k步，然后两个指针同时走，直到快指针为null，那么慢指针就走到了倒数第k个节点，那么这个节点就是需要的节点。" class="headerlink" title="2.1.1 采用快慢指针，先让快指针走k步，让快慢指针里面相差k步，然后两个指针同时走，直到快指针为null，那么慢指针就走到了倒数第k个节点，那么这个节点就是需要的节点。"></a>2.1.1 采用快慢指针，先让快指针走k步，让快慢指针里面相差k步，然后两个指针同时走，直到快指针为null，那么慢指针就走到了倒数第k个节点，那么这个节点就是需要的节点。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span>head;<br>        <span class="hljs-comment">// 快指针走k步，与慢指针相差k</span><br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; k&gt;<span class="hljs-number">0</span>)&#123;<br>            fast=fast.next;<br>            k--;<br>        &#125;<br>        <span class="hljs-comment">// 慢指针开始移动，快指针也继续移动</span><br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>)&#123;<br>            slow=slow.next;<br>            fast=fast.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="/images/lbszz-4.png" alt="img.png"><br>时间复杂度：O(n),遍历一次链表<br>空间复杂度:  O(1)</p><p>总结：当有这种k个距离的时候，采用快慢指针，速度一般是很快的，一开始想法是将链表反转，然后通过k元素的位置节点，然后再反转一次就是所求结果，但是很显然较为复杂，还是需要好好掌握快慢指针。</p><h1 id="2-旋转链表"><a href="#2-旋转链表" class="headerlink" title="2. 旋转链表"></a>2. 旋转链表</h1><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。<br><a href="https://leetcode.cn/problems/rotate-list/">力扣</a></p><h2 id="2-2-分析"><a href="#2-2-分析" class="headerlink" title="2.2 分析"></a>2.2 分析</h2><h3 id="2-2-1-使用快慢指针找到k的位置，不过先要判断一下k是否为空和节点是否存在，还要判断当前链表长度和k的大小，这里采用取余，因为k可能超过链表长度，如果取余后结果为0，意味着不需要移动，但是如果取余大于0，快指针就需要移动一格直到k为0，然后快慢指针一起移动，等快指针为null的时候，k就在慢指针的位置，然后将快指针的next指向链表的头部，然后慢指针后面断开。"><a href="#2-2-1-使用快慢指针找到k的位置，不过先要判断一下k是否为空和节点是否存在，还要判断当前链表长度和k的大小，这里采用取余，因为k可能超过链表长度，如果取余后结果为0，意味着不需要移动，但是如果取余大于0，快指针就需要移动一格直到k为0，然后快慢指针一起移动，等快指针为null的时候，k就在慢指针的位置，然后将快指针的next指向链表的头部，然后慢指针后面断开。" class="headerlink" title="2.2.1 使用快慢指针找到k的位置，不过先要判断一下k是否为空和节点是否存在，还要判断当前链表长度和k的大小，这里采用取余，因为k可能超过链表长度，如果取余后结果为0，意味着不需要移动，但是如果取余大于0，快指针就需要移动一格直到k为0，然后快慢指针一起移动，等快指针为null的时候，k就在慢指针的位置，然后将快指针的next指向链表的头部，然后慢指针后面断开。"></a>2.2.1 使用快慢指针找到k的位置，不过先要判断一下k是否为空和节点是否存在，还要判断当前链表长度和k的大小，这里采用取余，因为k可能超过链表长度，如果取余后结果为0，意味着不需要移动，但是如果取余大于0，快指针就需要移动一格直到k为0，然后快慢指针一起移动，等快指针为null的时候，k就在慢指针的位置，然后将快指针的next指向链表的头部，然后慢指针后面断开。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || k == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算链表长度</span><br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span>)&#123;<br>            len++;<br>            head=head.next;<br>        &#125;<br>        <span class="hljs-comment">// 当k就是链表的长度</span><br>        <span class="hljs-keyword">if</span>(k%len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(k%len &gt;<span class="hljs-number">0</span>)&#123;<br>            fast=fast.next;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast.next!=<span class="hljs-literal">null</span>)&#123;<br>            fast=fast.next;<br>            slow=slow.next;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> slow.next;<br>        slow.next = <span class="hljs-literal">null</span>;<br>        fast.next = temp;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/images/lbszz-5.png" alt="img.png"><br>时间复杂度： O(n)链表长度<br>空间复杂度:   O(1)</p><p>总结：需要注意的是一些临界值，比如k是否为0，或者取余是0，因为k不一定就是链表的长度以内。</p><h2 id="2-2-2-看到这个题目初始印象就是先分割链表，然后就是合并链表，但是实际写下来发现和上面快慢指针差不多，也是先找到位置分割，然后将第二个链表的最后一个指向原链表的头部，还是不如双指针简单。"><a href="#2-2-2-看到这个题目初始印象就是先分割链表，然后就是合并链表，但是实际写下来发现和上面快慢指针差不多，也是先找到位置分割，然后将第二个链表的最后一个指向原链表的头部，还是不如双指针简单。" class="headerlink" title="2.2.2 看到这个题目初始印象就是先分割链表，然后就是合并链表，但是实际写下来发现和上面快慢指针差不多，也是先找到位置分割，然后将第二个链表的最后一个指向原链表的头部，还是不如双指针简单。"></a>2.2.2 看到这个题目初始印象就是先分割链表，然后就是合并链表，但是实际写下来发现和上面快慢指针差不多，也是先找到位置分割，然后将第二个链表的最后一个指向原链表的头部，还是不如双指针简单。</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于这种题目说了第k的元素之类，优先考虑一下双指针。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis面试题-1</title>
    <link href="/post/d36837b5.html"/>
    <url>/post/d36837b5.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-为什么要用redis做缓存"><a href="#1-为什么要用redis做缓存" class="headerlink" title="1. 为什么要用redis做缓存"></a>1. 为什么要用redis做缓存</h1><ol><li>高性能：缓存获取数据</li><li>高并发：部分请求到缓存而不是数据库</li></ol><h1 id="2-Redis除了做缓存还能做什么"><a href="#2-Redis除了做缓存还能做什么" class="headerlink" title="2. Redis除了做缓存还能做什么"></a>2. Redis除了做缓存还能做什么</h1><ol><li>分布式锁</li><li>限流</li><li>消息队列</li><li>分布式session</li><li>延时队列</li></ol><h1 id="3-分布式缓存常见方案"><a href="#3-分布式缓存常见方案" class="headerlink" title="3. 分布式缓存常见方案"></a>3. 分布式缓存常见方案</h1><p>Memcached和redis<br>区别：</p><ol><li>redis提供更加丰富的数据类型</li><li>redis支持持久化，内存的数据结构存放在硬盘中，重启时候加载使用，mamcached数据存放内存</li><li>redis灾难恢复机制</li><li>redis服务器内存使用完了，可以将不用的数据放在磁盘上，memcached会报异常</li><li>redis支持集群，memcached没有原生集群</li><li>redis单线程多路复用，memcached多线程，非阻塞Io</li><li>redis支持发布订阅，lua脚本，事务等等</li></ol><h1 id="4-Redis常见的数据结构"><a href="#4-Redis常见的数据结构" class="headerlink" title="4. Redis常见的数据结构"></a>4. Redis常见的数据结构</h1><p>5种基础数据类型：String,List,Set,Hash,ZSet<br>3种特殊数据结构：HyperLogLogs（基数统计）Bitmap （位存储） Geospatial （地理位置）</p><h1 id="5-RDB"><a href="#5-RDB" class="headerlink" title="5. RDB"></a>5. RDB</h1><h2 id="5-1-什么是RDB持久化"><a href="#5-1-什么是RDB持久化" class="headerlink" title="5.1 什么是RDB持久化"></a>5.1 什么是RDB持久化</h2><p>Redis可以通过创建快照来获取存储在内存里面某个数据某个时间点上的副本。<br>Redis创建快照之后，可以对快照进行备份，可以复制到其他服务器创建具有相同数据的服务器副本。<br>快照持久化是 Redis 默认采用的持久化方式。</p><h1 id="5-2-RDB创建快照会阻塞主线程吗？"><a href="#5-2-RDB创建快照会阻塞主线程吗？" class="headerlink" title="5.2 RDB创建快照会阻塞主线程吗？"></a>5.2 RDB创建快照会阻塞主线程吗？</h1><p>dis提供两个方法</p><ul><li>save: 同步进行，会阻塞</li><li>bgsave：会fork创建一个子线程，子线程执行，不会阻塞，默认</li></ul><h1 id="6-AOF"><a href="#6-AOF" class="headerlink" title="6. AOF"></a>6. AOF</h1><h2 id="6-1-什么是AOF持久化"><a href="#6-1-什么是AOF持久化" class="headerlink" title="6.1 什么是AOF持久化"></a>6.1 什么是AOF持久化</h2><p>实时性比RDB好，开启AOF持久化每次执行一条会更改redis里面数据的命令,都会将该命令写入AOF缓冲区，然后再写入AOF文件（此时还在系统内核缓存区未同步到磁盘），最后根据持久化方式(fsync策略)配置来决定何时将系统内核缓存区的数据同步到硬盘中去</p><h2 id="6-2-AOF工作流程"><a href="#6-2-AOF工作流程" class="headerlink" title="6.2 AOF工作流程"></a>6.2 AOF工作流程</h2><ol><li>命令追加：将所有的写命令都写入AOF缓冲区</li><li>文件写入：将AOF缓冲区数据写入AOF文件（此时未将数据同步到硬盘）</li><li>文件同步：根据相应的持久化方式决定何时将内核里面的缓冲区数据同步到硬盘。</li><li>文件重写：AOF数据量大了之后，需要定期重写，达到压缩目的。</li><li>文件重载：当redis重启，加载AOF文件数据恢复</li></ol><h2 id="6-3-AOF持久化方式策略"><a href="#6-3-AOF持久化方式策略" class="headerlink" title="6.3 AOF持久化方式策略"></a>6.3 AOF持久化方式策略</h2><ol><li>appendfsync always：主进程调用write后，后台线程会立即调用AOF文件同步，完成后返回，（消耗性能）</li><li>appendfsync everysec：每秒钟调用 fsync 函数（系统调用）同步一次 AOF 文件</li><li>appendfsync no： 操作系统自己决定何时调用同步AOF文件</li></ol><h2 id="6-4-AOF为什么执行完命令后记录日志"><a href="#6-4-AOF为什么执行完命令后记录日志" class="headerlink" title="6.4 AOF为什么执行完命令后记录日志"></a>6.4 AOF为什么执行完命令后记录日志</h2><ol><li>节省开销，避免对语法进行检查</li><li>避免阻塞当前命令执行的线程</li></ol><p>缺点:</p><ol><li>刚执行完redis命令，redis就宕机了会导致数据丢失</li><li>阻塞后续其他命令的执行。</li></ol><h2 id="6-5-AOF重写了解吗"><a href="#6-5-AOF重写了解吗" class="headerlink" title="6.5 AOF重写了解吗"></a>6.5 AOF重写了解吗</h2><p>当AOF变得太大的时候，Redis会在后台自动重写产生一个新的ROF文件，这个AOF文件和原有的AOF文件保存的数据状态一样，但是体积更小。</p><h2 id="6-6-AOF校验校验机制了解吗"><a href="#6-6-AOF校验校验机制了解吗" class="headerlink" title="6.6 AOF校验校验机制了解吗"></a>6.6 AOF校验校验机制了解吗</h2><p>Redis启动时会对AOF文件文件检查，判断文件是否完整，是否损坏丢失数据。<br>主要是通过校验和（对整个 AOF 文件内容进行 CRC64 算法计算得出的数字）验证，如果文件发生改变，这个也会改变，会判断校验和和AOF文件末尾的校验和是否一致。</p><h2 id="6-7-如何选择RDB和AOF"><a href="#6-7-如何选择RDB和AOF" class="headerlink" title="6.7 如何选择RDB和AOF"></a>6.7 如何选择RDB和AOF</h2><p>RDB优点：</p><ol><li>存储的是经过压缩的二进制文件，文件占用小，适合数据备份，灾难恢复。AOF存储每一次的写命令，文件大</li><li>RBD恢复文件，只需要解析还原数据即可，不需要一条一条执行命令，速度快。AOF依赖每次的执行命令，速度慢。</li></ol><p>AOF优点：</p><ol><li>安全性好，实时持久化数据。RDB文件生成过程比较繁重，而AOF是直接追加到AOF文件里面去。</li><li>AOF易于理解和解析所有的日志。</li></ol><h1 id="7-Redis线程模型"><a href="#7-Redis线程模型" class="headerlink" title="7. Redis线程模型"></a>7. Redis线程模型</h1><h2 id="7-1-Redis单线程模型-单线程怎么监听大量客户的连接"><a href="#7-1-Redis单线程模型-单线程怎么监听大量客户的连接" class="headerlink" title="7.1 Redis单线程模型&#x2F;单线程怎么监听大量客户的连接"></a>7.1 Redis单线程模型&#x2F;单线程怎么监听大量客户的连接</h2><p>redis通过IO多路复用程序来见监听来自客户端的大量连接<br>好处是不需要创建多个线程监听大量用户，降低资源消耗</p><h2 id="7-2-Redis-6之前为什么不使用多线程"><a href="#7-2-Redis-6之前为什么不使用多线程" class="headerlink" title="7.2 Redis 6之前为什么不使用多线程"></a>7.2 Redis 6之前为什么不使用多线程</h2><ol><li>单线程管理容易维护。</li><li>redis性能主要在于内存和网络</li><li>多线程存在死锁，影响性能</li></ol><h2 id="7-3-Redis-6之后为什么引入多线程"><a href="#7-3-Redis-6之后为什么引入多线程" class="headerlink" title="7.3 Redis 6之后为什么引入多线程"></a>7.3 Redis 6之后为什么引入多线程</h2><p>提高网络IO读写性能</p><h1 id="8-Redis内存管理"><a href="#8-Redis内存管理" class="headerlink" title="8. Redis内存管理"></a>8. Redis内存管理</h1><h2 id="8-1-Redis给缓存数据设置过期时间的作用？"><a href="#8-1-Redis给缓存数据设置过期时间的作用？" class="headerlink" title="8.1 Redis给缓存数据设置过期时间的作用？"></a>8.1 Redis给缓存数据设置过期时间的作用？</h2><p>内存是有限的，不能缓存数据不能一直存在</p><h2 id="8-2-Redis如何判断数据是否过期"><a href="#8-2-Redis如何判断数据是否过期" class="headerlink" title="8.2 Redis如何判断数据是否过期"></a>8.2 Redis如何判断数据是否过期</h2><p>过期字典保存过期时间</p><h2 id="8-3-过期数据的删除策略方式"><a href="#8-3-过期数据的删除策略方式" class="headerlink" title="8.3 过期数据的删除策略方式"></a>8.3 过期数据的删除策略方式</h2><ol><li>惰性删除：只有取出Key的时候进行过期判断</li><li>定时删除： 每过一段时间取出过期的key删除。</li></ol><h2 id="8-4-Redis内存淘汰机制（8种）"><a href="#8-4-Redis内存淘汰机制（8种）" class="headerlink" title="8.4 Redis内存淘汰机制（8种）"></a>8.4 Redis内存淘汰机制（8种）</h2><p>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p><ol><li>volatile-lru： 从已设置过期时间的数据集中种挑选最少使用的淘汰</li><li>volatile-ttl： 从已设置过期时间的数据集中挑选要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集中任意挑选数据淘汰</li><li>allkeys-lru：内存不足以写入新数据，淘汰最少使用的（常用）</li><li>allkeys-random：从数据集中任选数据淘汰。</li><li>no-eviction：内存不足时不允许写入</li><li>volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰</li><li>allkeys-lfu：内存不足以写入新数据，移除补偿使用的key</li></ol>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法通关村第一关——链表经典问题之合并有序链表笔记</title>
    <link href="/post/3f07837f.html"/>
    <url>/post/3f07837f.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-题目：合并两个有序链表"><a href="#1-题目：合并两个有序链表" class="headerlink" title="1. 题目：合并两个有序链表"></a>1. 题目：合并两个有序链表</h1><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><a href="https://leetcode.cn/problems/merge-two-sorted-lists/submissions/">力扣</a></p><h2 id="1-2-分析"><a href="#1-2-分析" class="headerlink" title="1.2. 分析"></a>1.2. 分析</h2><h3 id="1-2-1-初始想法，直接采用一个新的链表存储两个链表元素，只需要比较两个链表的元素大小，然后改变新链表的指针。"><a href="#1-2-1-初始想法，直接采用一个新的链表存储两个链表元素，只需要比较两个链表的元素大小，然后改变新链表的指针。" class="headerlink" title="1.2.1 初始想法，直接采用一个新的链表存储两个链表元素，只需要比较两个链表的元素大小，然后改变新链表的指针。"></a>1.2.1 初始想法，直接采用一个新的链表存储两个链表元素，只需要比较两个链表的元素大小，然后改变新链表的指针。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">newListNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>       <span class="hljs-comment">// 哨兵节点</span><br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentNewNode</span> <span class="hljs-operator">=</span> newListNode;<br>       <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">// list1的值小</span><br>           <span class="hljs-keyword">if</span> (list1.value &lt;= list2.value) &#123;<br>               currentNewNode.next = list1;<br>               currentNewNode = list1;<br>               list1 = list1.next;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list1.value &gt; list2.value) &#123;<br>               <span class="hljs-comment">// list2的值小</span><br>               currentNewNode.next = list2;<br>               currentNewNode = list2;<br>               list2 = list2.next;<br>           &#125;<br>       &#125;<br><span class="hljs-comment">// 两者有一个为空</span><br>       currentNewNode.next = (list1 == <span class="hljs-literal">null</span>) ? list2 : list1;<br>       <span class="hljs-keyword">return</span> newListNode.next;<br>   &#125;<br></code></pre></td></tr></table></figure><p>这里面需要注意的是返回的头节点的下一个节点，因为头节点是作为哨兵节点的，没有实际意义。</p><p>运行截图<br><img src="/images/lbhb-1.png" alt="img.png"><br>时间复杂度：O(n),两个链表的节点总数<br>空间复杂度:  O(1)</p><p>以上代码还能再简单一些，  就是里面的每次新的节点都需要移动到新的链表的位置，list1和list2的移动都是一样的，没必要单独写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// list1的值小</span><br>          <span class="hljs-keyword">if</span> (list1.value &lt;= list2.value) &#123;<br>              currentNewNode.next = list1;<br>              list1 = list1.next;<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list1.value &gt; list2.value) &#123;<br>              <span class="hljs-comment">// list2的值小</span><br>              currentNewNode.next = list2;<br>              list2 = list2.next;<br>          &#125;<br>          currentNewNode = currentNewNode.next;<br>      &#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-2-递归写法，只需要比较头节点的元素大小，然后将其中小的元素就作为新链表的节点，然后比较下面的其他元素，最后返回的链表就是已经排序好的链表。"><a href="#1-2-2-递归写法，只需要比较头节点的元素大小，然后将其中小的元素就作为新链表的节点，然后比较下面的其他元素，最后返回的链表就是已经排序好的链表。" class="headerlink" title="1.2.2 递归写法，只需要比较头节点的元素大小，然后将其中小的元素就作为新链表的节点，然后比较下面的其他元素，最后返回的链表就是已经排序好的链表。"></a>1.2.2 递归写法，只需要比较头节点的元素大小，然后将其中小的元素就作为新链表的节点，然后比较下面的其他元素，最后返回的链表就是已经排序好的链表。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-keyword">if</span> (list1.value &lt;= list2.value) &#123;<br>            list1.next = mergeTwoLists(list1.next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            list2.next = mergeTwoLists(list2.next, list1);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>递归还是比较容易看懂的，一定需要注意递归判断条件是否为空，不然出不来递归。</p><p>运行截图<br><img src="/images/lbhb-2.png" alt="img.png"></p><p>时间复杂度：O(n)链表长度<br>空间复杂度:  O(n) 链表长度</p><p>递归主要是涉及到递归层数和这个空间，速度肯定是不如第一种方法快的。</p><h1 id="2-合并K个链表"><a href="#2-合并K个链表" class="headerlink" title="2. 合并K个链表"></a>2. 合并K个链表</h1><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>地址：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/submissions/">力扣</a></p><h2 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h2><p>比如栈等等都能合并链表，建议先将两个链表合并写出来，比较容易处理<br>后续， k个链表只是先选出一个链表然后和其他链表相比较进行合并，思路其实一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(ListNode list:lists)&#123;<br>            res=mergeTwoList(res,list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoList</span><span class="hljs-params">(ListNode list1,ListNode list2)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">sential</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span> sential;<br>        <span class="hljs-keyword">while</span>(list1!=<span class="hljs-literal">null</span> &amp;&amp; list2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list1.val &lt;= list2.val)&#123;<br>                currentNode.next=list1;<br>                list1=list1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                currentNode.next = list2;<br>                list2=list2.next;<br>            &#125;<br>            currentNode = currentNode.next;<br>        &#125;<br>        currentNode.next = list1 ==<span class="hljs-literal">null</span> ?list2:list1;<br>        <span class="hljs-keyword">return</span> sential.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbhb-3.png" alt="img.png"><br>时间复杂度：O(NlogK) N是节点综合，K是链表数量，每个链表最多合并一次<br>空间复杂度:  O(n) 创建新链表保存。</p><p>总结：掌握好两个链表合并，这个困难题的合并链表就会写。</p><h1 id="3-合并两个链表"><a href="#3-合并两个链表" class="headerlink" title="3. 合并两个链表"></a>3. 合并两个链表</h1><p>给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。<br>请你将 list1 中下标从 a 到 b 的全部节点都删除，并将list2 接在被删除节点的位置。<br><a href="https://leetcode.cn/problems/merge-in-between-linked-lists/">力扣</a></p><h2 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h2><h3 id="3-1-1-可以仔细分析下，链表A从a-b将链表分成了3分，中间是不需要的，链表A在a-1的位置后面插入链表B，然后当链表B遍历结束了，这时候就去连接链表A的b-1的位置，很显然就是3个链表合并，拆分下来就是合并两次链表，需要记录a-1，b，链表B结束位置，然后合并。"><a href="#3-1-1-可以仔细分析下，链表A从a-b将链表分成了3分，中间是不需要的，链表A在a-1的位置后面插入链表B，然后当链表B遍历结束了，这时候就去连接链表A的b-1的位置，很显然就是3个链表合并，拆分下来就是合并两次链表，需要记录a-1，b，链表B结束位置，然后合并。" class="headerlink" title="3.1.1 可以仔细分析下，链表A从a-b将链表分成了3分，中间是不需要的，链表A在a-1的位置后面插入链表B，然后当链表B遍历结束了，这时候就去连接链表A的b+1的位置，很显然就是3个链表合并，拆分下来就是合并两次链表，需要记录a-1，b，链表B结束位置，然后合并。"></a>3.1.1 可以仔细分析下，链表A从a-b将链表分成了3分，中间是不需要的，链表A在a-1的位置后面插入链表B，然后当链表B遍历结束了，这时候就去连接链表A的b+1的位置，很显然就是3个链表合并，拆分下来就是合并两次链表，需要记录a-1，b，链表B结束位置，然后合并。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">mergeInBetween</span><span class="hljs-params">(ListNode list1, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, ListNode list2)</span> &#123;<br>     <span class="hljs-comment">// list1中a的位置</span><br>     <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre1</span> <span class="hljs-operator">=</span> list1;<br>     <span class="hljs-comment">// list1中b的位置</span><br>     <span class="hljs-type">ListNode</span> <span class="hljs-variable">end1</span> <span class="hljs-operator">=</span> list1;<br>     <span class="hljs-comment">// list2在list1的a+1位置</span><br>     <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre2</span> <span class="hljs-operator">=</span> list2;<br>     <span class="hljs-comment">// 计数到a</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-comment">// 计数到b</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>     <span class="hljs-keyword">while</span> (pre1 != <span class="hljs-literal">null</span> &amp;&amp; end1 != <span class="hljs-literal">null</span> &amp;&amp; j &lt; b) &#123;<br>         <span class="hljs-comment">// i=a-1获取a前一个元素的位置</span><br>         <span class="hljs-keyword">if</span> (i != a - <span class="hljs-number">1</span>) &#123;<br>             pre1 = pre1.next;<br>             i++;<br>         &#125;<br>         <span class="hljs-comment">// 获取b的位置</span><br>         <span class="hljs-keyword">if</span> (j != b) &#123;<br>             end1 = end1.next;<br>             j++;<br>         &#125;<br>     &#125;<br>     <span class="hljs-comment">// 获取了b+1的元素</span><br>     end1 = end1.next;<br>     <span class="hljs-comment">// 遍历list2</span><br>     <span class="hljs-keyword">while</span> (pre2.next != <span class="hljs-literal">null</span>) &#123;<br>         pre2 = pre2.next;<br>     &#125;<br>     pre1.next = list2;<br>     pre2.next = end1;<br>     <span class="hljs-keyword">return</span> list1;<br> &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbhb-4.png" alt="img.png"><br>时间复杂度：O(n)链表长度<br>空间复杂度：O(1)</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql面试题-2</title>
    <link href="/post/b0cc9896.html"/>
    <url>/post/b0cc9896.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-日志"><a href="#1-日志" class="headerlink" title="1. 日志"></a>1. 日志</h1><h1 id="1-1-什么是索引？使用索引的优缺点"><a href="#1-1-什么是索引？使用索引的优缺点" class="headerlink" title="1.1 什么是索引？使用索引的优缺点"></a>1.1 什么是索引？使用索引的优缺点</h1><p>用于快速查找和检索数据的一种数据结构<br>优点：</p><ol><li>可以提高检索数据的效率</li><li>可以创建唯一索引，保证每一行数据的唯一性。</li></ol><p>缺点:</p><ol><li>创建和维护索引需要不少的时间。如果执行增删改有索引，对于索引需要动态修改，降低效率</li><li>索引需要空间存储，耗费空间</li></ol><h1 id="1-2-Mysql的索引为什么使用B-tree"><a href="#1-2-Mysql的索引为什么使用B-tree" class="headerlink" title="1.2 Mysql的索引为什么使用B+tree"></a>1.2 Mysql的索引为什么使用B+tree</h1><h2 id="1-2-1-二叉查找树"><a href="#1-2-1-二叉查找树" class="headerlink" title="1.2.1 二叉查找树"></a>1.2.1 二叉查找树</h2><p>特点：</p><ol><li>左子树的值一定比根节点的值小</li><li>右子树的值一定比根节点的值大</li><li>左右子树也是二叉查找树<br>缺点：非常依赖于平衡程度（比如所有的数据都在根节点的左边或者都在右边）</li></ol><h2 id="1-2-2-AVL树"><a href="#1-2-2-AVL树" class="headerlink" title="1.2.2 AVL树"></a>1.2.2 AVL树</h2><p>特点：</p><ol><li>任意节点的左子树右子树的高度不超过1</li><li>采用旋转保持平衡，LL,LR,RR,RL<br>缺点：需要频繁的旋转保持平衡，降低性能，而且只能读取一个节点的数据，读取其他节点需要多次处理磁盘IO</li></ol><h2 id="1-2-3-红黑树"><a href="#1-2-3-红黑树" class="headerlink" title="1.2.3 红黑树"></a>1.2.3 红黑树</h2><p>特点：</p><ol><li>每个节点非红即黑</li><li>根节点总是黑的</li><li>叶子节点都是黑色的</li><li>节点是红的，子节点必须是黑的</li><li>根节点到叶子节点，包含相同的黑色节点个数<br>缺点：当树高了，读取数据就需要多次读取磁盘IO</li></ol><h2 id="1-2-4-B树"><a href="#1-2-4-B树" class="headerlink" title="1.2.4 B树"></a>1.2.4 B树</h2><p>特点：</p><ol><li>B树的所有节点存放数据和键</li><li>叶子节点都是独立的</li><li>检索过程是对范围内的每个节点做二分查找，可能没有到达叶子节点就找完了</li><li>范围查询，需要先找到查找的下限，执行中序遍历，找到上限<br>缺点：查找性能低，每个节点都存储数据，查找时需要遍历多个节点</li></ol><h2 id="1-2-5-B-树"><a href="#1-2-5-B-树" class="headerlink" title="1.2.5 B+树"></a>1.2.5 B+树</h2><p>特点：</p><ol><li>B+树只有叶子节点存放key和data，其他节点存放key</li><li>有引用链指向相邻的叶子节点</li><li>检索稳定，都是从根节点到叶子节点</li><li>范围查找著需要对链表遍历，减少IO次数</li></ol><h1 id="1-3-主键索引和二级索引"><a href="#1-3-主键索引和二级索引" class="headerlink" title="1.3 主键索引和二级索引"></a>1.3 主键索引和二级索引</h1><p>主键索引：一个数据表只能有一个主键，并且不能为空，不能重复，（如果没有指定，Mysql会自动创建一个索引）<br>二级索引：辅助索引，它的叶子节点存储的是主键，通过二级索引定位到主键位置。<br>二级索引分类：</p><ol><li>普通索引: 快速查找数据</li><li>前缀索引：文本前几个字符创建索引</li><li>唯一索引：唯一索引的属性不能出现重复数据源，但是可以为null</li><li>全文索引：检索大文本关键字信息</li></ol><h1 id="1-4-聚簇索引和非聚簇索引"><a href="#1-4-聚簇索引和非聚簇索引" class="headerlink" title="1.4 聚簇索引和非聚簇索引"></a>1.4 聚簇索引和非聚簇索引</h1><p>聚簇索引：包含了索引结构和数据，不是单独的索引，InnoDB采用的主键索引就是聚簇索引<br>优点：</p><ol><li>查找速度快：B+树就是二叉查找树，叶子节点有序，可以快速定位到索引的节点</li><li>排序和范围查找快</li></ol><p>缺点:</p><ol><li>依赖有序的数据</li><li>更新代价大</li></ol><p>非聚簇索引：索引结构和数据分开存储，MylSAM的主键非主键都是采用的非聚簇索引<br>优点：更新代价小<br>缺点：</p><ol><li>依赖有序数据</li><li>查找效率低，可能二次查表</li></ol><h1 id="1-5-覆盖索引和联合索引"><a href="#1-5-覆盖索引和联合索引" class="headerlink" title="1.5 覆盖索引和联合索引"></a>1.5 覆盖索引和联合索引</h1><p>覆盖索引：当索引字段就是需要查找的字段，直接根据该索引，返回数据，不需要回表查询。<br>联合索引：多个字段创建索引</p><h1 id="1-6-最左前缀匹配原则"><a href="#1-6-最左前缀匹配原则" class="headerlink" title="1.6 最左前缀匹配原则"></a>1.6 最左前缀匹配原则</h1><p>使用联合索引的时候，MySQL会根据联合索引的字段顺序，从左到右查询匹配，如果存在就过滤掉其他数据，如果碰到范围查询(&gt;,&lt;)就停止匹配。而(&gt;&#x3D;,&lt;&#x3D;,between,like)范围匹配不会停止匹配。</p><h1 id="1-7-创建索引事项"><a href="#1-7-创建索引事项" class="headerlink" title="1.7. 创建索引事项"></a>1.7. 创建索引事项</h1><h2 id="1-7-1-选用合适的字段"><a href="#1-7-1-选用合适的字段" class="headerlink" title="1.7.1 选用合适的字段"></a>1.7.1 选用合适的字段</h2><ol><li>不能使用null的字段</li><li>频繁查找的字段</li><li>频繁排序</li><li>条件查询的字段</li><li>频繁用于连接字段</li></ol><h2 id="1-7-2-频繁更新的字段不宜使用索引"><a href="#1-7-2-频繁更新的字段不宜使用索引" class="headerlink" title="1.7.2 频繁更新的字段不宜使用索引"></a>1.7.2 频繁更新的字段不宜使用索引</h2><h2 id="1-7-3限制索引数量"><a href="#1-7-3限制索引数量" class="headerlink" title="1.7.3限制索引数量"></a>1.7.3限制索引数量</h2><h2 id="1-7-4优先考虑联合索引"><a href="#1-7-4优先考虑联合索引" class="headerlink" title="1.7.4优先考虑联合索引"></a>1.7.4优先考虑联合索引</h2><h2 id="1-7-5-避免冗余索引"><a href="#1-7-5-避免冗余索引" class="headerlink" title="1.7.5 避免冗余索引"></a>1.7.5 避免冗余索引</h2><h2 id="1-7-6避免索引失效"><a href="#1-7-6避免索引失效" class="headerlink" title="1.7.6避免索引失效"></a>1.7.6避免索引失效</h2><h1 id="2-日志"><a href="#2-日志" class="headerlink" title="2. 日志"></a>2. 日志</h1><h2 id="2-1-Mysql的日志有哪些"><a href="#2-1-Mysql的日志有哪些" class="headerlink" title="2.1 Mysql的日志有哪些"></a>2.1 Mysql的日志有哪些</h2><p>redo log,undo log,binlog,慢查询日志，查询日志等等</p><h2 id="2-2-redo-log"><a href="#2-2-redo-log" class="headerlink" title="2.2 redo log"></a>2.2 redo log</h2><p><strong>重做日志</strong>，<strong>InnoDB</strong>存储引擎独有，让Mysql的崩溃恢复，保证Mysql的<strong>持久性</strong>，主要用于事务的回归和MVCC。</p><h2 id="2-3-redo-log如何保持事务的持久性"><a href="#2-3-redo-log如何保持事务的持久性" class="headerlink" title="2.3 redo log如何保持事务的持久性"></a>2.3 redo log如何保持事务的持久性</h2><p>redo log主要做的事就是<strong>记录页的修改</strong>，比如某个页的某个偏移量处修改了几个字节的数据以及具体被修改了什么值。提交事务的时候，将redo log按照<strong>刷盘策略</strong>刷到磁盘上去，即时宕机了，也能恢复未写入磁盘的数据，保证事务的持久性。</p><h2 id="2-4-页修改了之后为什么不直接刷盘"><a href="#2-4-页修改了之后为什么不直接刷盘" class="headerlink" title="2.4 页修改了之后为什么不直接刷盘"></a>2.4 页修改了之后为什么不直接刷盘</h2><p>这样性能十分差。InnoDB的每个页的大小都是16kB，页是与磁盘进行交互的基本单位，即时我们修改了几个字节的数据，仍然需要将整页数据重新刷入磁盘。而且修改可能不相邻。</p><h2 id="2-5-undo-log"><a href="#2-5-undo-log" class="headerlink" title="2.5 undo log"></a>2.5 undo log</h2><p>回滚日志，发生异常的时候进行回滚操作，Mysql里面的恢复机制是通过回滚日志undo log来进行的，所有事务进行的修改都会先记录到这个回滚日志里面，然后执行相关的操作，最主要是保证了<strong>原子性</strong>。</p><h2 id="2-6-undo-log如何保持事务的原子性"><a href="#2-6-undo-log如何保持事务的原子性" class="headerlink" title="2.6 undo log如何保持事务的原子性"></a>2.6 undo log如何保持事务的原子性</h2><p>每个事务对数据的修改都会被记录到undo log，出现错误或者需要回滚操作的时候，利用undo log回滚到操作之前</p><h2 id="2-7-binlog"><a href="#2-7-binlog" class="headerlink" title="2.7 binlog"></a>2.7 binlog</h2><p>逻辑日志，记录的是语句的<strong>原始逻辑</strong>，只要产生表更新就会产生binlog日志。主要用于主主，主从。主备，数据备份，依靠binlog实现<strong>同步数据</strong>，保持了<strong>数据一致性</strong></p><h2 id="2-8-binlog和-redo-log区别"><a href="#2-8-binlog和-redo-log区别" class="headerlink" title="2.8 binlog和 redo log区别"></a>2.8 binlog和 redo log区别</h2><ol><li>redo log是物理日志，binlog是逻辑日志</li><li>redo log主要是记录某个页上修改了什么数据，binlog主要是记录语句的原始逻辑</li><li>redo log属于InnoDB引擎，binlog属于Mysql的服务端</li><li>redo log不可以跨平台，binlog可以跨平台使用</li></ol>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>面试题</tag>
      
      <tag>Mysql日志</tag>
      
      <tag>Mysql索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGpt+Vercel无需服务器部署</title>
    <link href="/post/b2dd429d.html"/>
    <url>/post/b2dd429d.html</url>
    
    <content type="html"><![CDATA[<h1 id="ChatGPT-Next-Web"><a href="#ChatGPT-Next-Web" class="headerlink" title="ChatGPT-Next-Web"></a>ChatGPT-Next-Web</h1><p>开源项目，跨平台无需服务器就可部署自己的gpt网页端口<br>地址<a href="https://github.com/Yidadaa/ChatGPT-Next-Web">https://github.com/Yidadaa/ChatGPT-Next-Web</a></p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol><li>一键部署</li><li>兼容各个系统</li><li>数据存储本地</li><li>支持markdown</li><li>支持自定义</li></ol><h1 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h1><ol><li>拥有vercel账号<br> 注册地址  <a href="https://vercel.com/dashboard%EF%BC%8C%E7%BB%91%E5%AE%9Agithub%E8%B4%A6%E5%8F%B7">https://vercel.com/dashboard，绑定github账号</a></li><li>拥有gpt账号<br>需要使用gpt的key</li><li>将ChatGPT-Next-Web  fork到自己的github仓库</li></ol><h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><ol><li>gpt的key获取<br>官网地址<a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a><br><img src="/images/gptv-1.png" alt="img.png"><br>点击创建新的key<br><img src="/images/gptv-2.png" alt="img.png"><br>保存好这个key</li><li>vercel部署<br>主界面<img src="/images/gptv-3.png" alt="img.png"><br>点击Add new Project创建新项目<br>找到自己之前的fork项目,点击import<br><img src="/images/gptv-4.png" alt="img.png"></li></ol><p>下拉找到Environment Variables<br><img src="/images/gptv-5.png" alt="img.png"><br>第一个填入OPENAI_API_KEY<br>第二个填入自己的gpt的key</p><p>新建一个NEXT_PUBLIC_USE_USER_KEY<br>让用户自己输入KEY才能用的设置，填入  false</p><p>点击部署，等待<br><img src="/images/gptv-6.png" alt="img.png"></p><ol start="3"><li><p>部署成功<br><img src="/images/gptv-7.png" alt="img.png"></p></li><li><p>去往自己的gpt<br>点击continue<br><img src="/images/gptv-8.png" alt="img.png"><br>里面的domain就是自己的域名地址，点击就能进入<br><img src="/images/gptv-9.png" alt="img.png"></p></li><li><p>配置域名<br>点击右上角的domain可以配置自己的域名<br><img src="/images/gptv-10.png" alt="img.png"></p></li></ol><h1 id="但是由于我的gpt是免费的，所以这里会显示余额不足，大家打着玩玩就行"><a href="#但是由于我的gpt是免费的，所以这里会显示余额不足，大家打着玩玩就行" class="headerlink" title="但是由于我的gpt是免费的，所以这里会显示余额不足，大家打着玩玩就行"></a>但是由于我的gpt是免费的，所以这里会显示余额不足，大家打着玩玩就行</h1><p><img src="/images/gptv-11.png" alt="img.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法通关村第一关——链表经典问题之两个链表的第一个公共节点笔记</title>
    <link href="/post/68997616.html"/>
    <url>/post/68997616.html</url>
    
    <content type="html"><![CDATA[<h1 id="题目-输入两个链表，找出它们的第一个公共节点。"><a href="#题目-输入两个链表，找出它们的第一个公共节点。" class="headerlink" title="题目 输入两个链表，找出它们的第一个公共节点。"></a>题目 输入两个链表，找出它们的第一个公共节点。</h1><p>地址 <a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="1-使用暴力法，将每一个链表节点和另一个链表比较，找到相同的节点位置，返回，但是很显然，时间复杂度比较高。"><a href="#1-使用暴力法，将每一个链表节点和另一个链表比较，找到相同的节点位置，返回，但是很显然，时间复杂度比较高。" class="headerlink" title="1. 使用暴力法，将每一个链表节点和另一个链表比较，找到相同的节点位置，返回，但是很显然，时间复杂度比较高。"></a>1. 使用暴力法，将每一个链表节点和另一个链表比较，找到相同的节点位置，返回，但是很显然，时间复杂度比较高。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">currA</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-keyword">while</span> (currA != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">currB</span> <span class="hljs-operator">=</span> headB;<br>            <span class="hljs-keyword">while</span> (currB != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (currA == currB) &#123;<br>                    <span class="hljs-keyword">return</span> currA;<br>                &#125;<br>                currB = currB.next;<br>            &#125;<br>            currA = currA.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-1.png" alt="img.png"><br>时间复杂度：O（mn），两个链表遍历的长度相乘<br>空间复杂度：O（1），使用了两个节点</p><p>可以看出时间复杂读还是很高的</p><h2 id="2-又想到了考虑的是既然要找到公共节点，两个链表是有长短的，只要找出短的链表，计算长度，然后再遍历长的链表，当两个链表一样长的时候，比较值就可以了，但是可想而知，会使用一堆while循环。"><a href="#2-又想到了考虑的是既然要找到公共节点，两个链表是有长短的，只要找出短的链表，计算长度，然后再遍历长的链表，当两个链表一样长的时候，比较值就可以了，但是可想而知，会使用一堆while循环。" class="headerlink" title="2. 又想到了考虑的是既然要找到公共节点，两个链表是有长短的，只要找出短的链表，计算长度，然后再遍历长的链表，当两个链表一样长的时候，比较值就可以了，但是可想而知，会使用一堆while循环。"></a>2. 又想到了考虑的是既然要找到公共节点，两个链表是有长短的，只要找出短的链表，计算长度，然后再遍历长的链表，当两个链表一样长的时候，比较值就可以了，但是可想而知，会使用一堆while循环。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode2</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>      <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-comment">// 先获取相应链表的长度</span><br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentA</span> <span class="hljs-operator">=</span> headA;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentB</span> <span class="hljs-operator">=</span> headB;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">lengthA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">lengthB</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (currentA != <span class="hljs-literal">null</span>) &#123;<br>          currentA = currentA.next;<br>          lengthA++;<br>      &#125;<br>      <span class="hljs-keyword">while</span> (currentB != <span class="hljs-literal">null</span>) &#123;<br>          currentB = currentB.next;<br>          lengthB++;<br>      &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">minLength</span> <span class="hljs-operator">=</span> lengthA &gt; lengthB ? lengthB : lengthA;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <br>      <span class="hljs-comment">// 链表A比较短</span><br>      <span class="hljs-keyword">if</span> (minLength == lengthA) &#123;<br>          <span class="hljs-keyword">while</span> (lengthB - count &gt; lengthA) &#123;<br>              headB = headB.next;<br>              count++;<br>          &#125;<br>          <span class="hljs-keyword">while</span> (headA != headB) &#123;<br>              headB = headB.next;<br>              headA = headA.next;<br>          &#125;<br>          <span class="hljs-keyword">return</span> headA;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (minLength == lengthB) &#123;<br>          <span class="hljs-keyword">while</span> (lengthA - count &gt; lengthB) &#123;<br>              headA = headA.next;<br>              count++;<br>          &#125;<br>          <span class="hljs-keyword">while</span> (headA != headB) &#123;<br>              headB = headB.next;<br>              headA = headA.next;<br>          &#125;<br>          <span class="hljs-keyword">return</span> headB;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-2.png" alt="img.png"><br>时间复杂度：首先各自遍历链表长度，为O(m+n), 然后调整长链表的长度和短链表一致，时间复杂度是O(max(m,n))，最后再执行遍历找到公共节点，O(min(m,n)),总的来说O(m+n+max(m,n)+min(m,n)),也不知道算的对不对，但是就是很复杂。</p><p>空间复杂度：O(1)两个节点；</p><p>总结：虽然一开始感觉时间耗费高，但是测试下来，发现时间耗费这么低。</p><h2 id="3-既然考虑公共节点，那么也就是说可以看作是在集合或者数据里面判断是否两个相同的数，最直接的是考虑hash，只需要将一个链表的节点放入map，然后依次和另一个链表的节点比较就行"><a href="#3-既然考虑公共节点，那么也就是说可以看作是在集合或者数据里面判断是否两个相同的数，最直接的是考虑hash，只需要将一个链表的节点放入map，然后依次和另一个链表的节点比较就行" class="headerlink" title="3. 既然考虑公共节点，那么也就是说可以看作是在集合或者数据里面判断是否两个相同的数，最直接的是考虑hash，只需要将一个链表的节点放入map，然后依次和另一个链表的节点比较就行"></a>3. 既然考虑公共节点，那么也就是说可以看作是在集合或者数据里面判断是否两个相同的数，最直接的是考虑hash，只需要将一个链表的节点放入map，然后依次和另一个链表的节点比较就行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>       Set&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>       <span class="hljs-keyword">while</span> (headA != <span class="hljs-literal">null</span>) &#123;<br>           set.add(headA);<br>           headA = headA.next;<br>       &#125;<br>       <span class="hljs-keyword">while</span> (headB != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">if</span> (set.contains(headB)) &#123;<br>               <span class="hljs-keyword">return</span> headB;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               headB = headB.next;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-3.png" alt="img.png"><br>时间复杂度：第一次循环添加headA节点，O(m),第二次遍历headB,O(n),总体O(m+n)<br>空间复杂度: 使用set来存储节点，O(m)</p><p>总结：需要多加注意下尤其是涉及到是否包含相同的节点，数的时候就考虑使用哈希</p><h2 id="4-使用栈，特点是先进后出，本质上还是将两个链表节点比较，只是由于是逆序，所以，如果有共同节点，最后一个相同的节点之后的其他节点就不相同了，不需要像之前从头开始循环遍历比较。"><a href="#4-使用栈，特点是先进后出，本质上还是将两个链表节点比较，只是由于是逆序，所以，如果有共同节点，最后一个相同的节点之后的其他节点就不相同了，不需要像之前从头开始循环遍历比较。" class="headerlink" title="4. 使用栈，特点是先进后出，本质上还是将两个链表节点比较，只是由于是逆序，所以，如果有共同节点，最后一个相同的节点之后的其他节点就不相同了，不需要像之前从头开始循环遍历比较。"></a>4. 使用栈，特点是先进后出，本质上还是将两个链表节点比较，只是由于是逆序，所以，如果有共同节点，最后一个相同的节点之后的其他节点就不相同了，不需要像之前从头开始循环遍历比较。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        Stack&lt;ListNode&gt; stackA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;ListNode&gt;();<br>        Stack&lt;ListNode&gt; stackB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;ListNode&gt;();<br>        <span class="hljs-keyword">while</span> (headA != <span class="hljs-literal">null</span>) &#123;<br>            stackA.add(headA);<br>            headA = headA.next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (headB != <span class="hljs-literal">null</span>) &#123;<br>            stackB.add(headB);<br>            headB = headB.next;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (stackA.size() &gt; <span class="hljs-number">0</span> &amp;&amp; stackB.size() &gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (stackA.peek() == stackB.peek()) &#123;<br>                preNode = stackA.pop();<br>                stackB.pop();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> preNode;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-4.png" alt="img.png"><br>时间复杂度：第一个链表添加至栈,O(m),第二个链表添加至栈，O(n)，最坏情况下O(min(m,n))，就是两个链表的长度谁短，总的O(m+n+min(m,n))<br>空间复杂度：O（m+n）</p><h2 id="5-拼接字符串，感觉很熟悉但是又很陌生的方法，分别将两个链表合并起来，合并的两个链表就是一样长的，然后比较节点，那么那个相同的节点就是结果。"><a href="#5-拼接字符串，感觉很熟悉但是又很陌生的方法，分别将两个链表合并起来，合并的两个链表就是一样长的，然后比较节点，那么那个相同的节点就是结果。" class="headerlink" title="5. 拼接字符串，感觉很熟悉但是又很陌生的方法，分别将两个链表合并起来，合并的两个链表就是一样长的，然后比较节点，那么那个相同的节点就是结果。"></a>5. 拼接字符串，感觉很熟悉但是又很陌生的方法，分别将两个链表合并起来，合并的两个链表就是一样长的，然后比较节点，那么那个相同的节点就是结果。</h2><p><img src="/images/gonggongjiedian-5.png" alt="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>       <span class="hljs-comment">// 需要考虑不为空的情况</span><br>       <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> headB;<br>       <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>           <span class="hljs-comment">// 不为null的时候继续遍历</span><br>           p1 = p1.next;<br>           p2 = p2.next;<br>           <span class="hljs-keyword">if</span> (p1 != p2) &#123;<br>               <span class="hljs-comment">// 链表1结束，转为链表2</span><br>               <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">null</span>) &#123;<br>                   p1 = headB;<br>               &#125;<br>               <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">null</span>) &#123;<br>                   p2 = headA;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> p1;<br>   &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-6.png" alt="img.png"></p><p>时间复杂度：最坏O(m+n)没有节点<br>空间复杂度：O(1)</p><p>总结：里面的两个if是没有关系的，不能使用else。假设链表1大于链表2的长度，那么第一个拼接的链表，公共点就在拼接的链表2上面，第二个拼接的链表，公共点就在链表1上面。核心思路还是将链表长度归一.</p><h2 id="6-差和双指针，假如公共子节点一定存在第一轮遍历，假设La长度为L1，Lb长度为L2-则｜L2-L1｜就是两个的差值。第二轮遍历，长的先走｜L2-L1｜-然后两个链表同时向前走，结点一样的时候就是公共结点了。这个方法仔细思考一下，和我第二个思路基本上一致，只不过对于部分进行了优化，比如之前的取最短的链表的长度，这个需要做两次判断，因为不知道哪个链表短，采取的方式也不一样，所以这里可以做一些优化。"><a href="#6-差和双指针，假如公共子节点一定存在第一轮遍历，假设La长度为L1，Lb长度为L2-则｜L2-L1｜就是两个的差值。第二轮遍历，长的先走｜L2-L1｜-然后两个链表同时向前走，结点一样的时候就是公共结点了。这个方法仔细思考一下，和我第二个思路基本上一致，只不过对于部分进行了优化，比如之前的取最短的链表的长度，这个需要做两次判断，因为不知道哪个链表短，采取的方式也不一样，所以这里可以做一些优化。" class="headerlink" title="6.  差和双指针，假如公共子节点一定存在第一轮遍历，假设La长度为L1，Lb长度为L2.则｜L2-L1｜就是两个的差值。第二轮遍历，长的先走｜L2-L1｜,然后两个链表同时向前走，结点一样的时候就是公共结点了。这个方法仔细思考一下，和我第二个思路基本上一致，只不过对于部分进行了优化，比如之前的取最短的链表的长度，这个需要做两次判断，因为不知道哪个链表短，采取的方式也不一样，所以这里可以做一些优化。"></a>6.  差和双指针，假如公共子节点一定存在第一轮遍历，假设La长度为L1，Lb长度为L2.则｜L2-L1｜就是两个的差值。第二轮遍历，长的先走｜L2-L1｜,然后两个链表同时向前走，结点一样的时候就是公共结点了。这个方法仔细思考一下，和我第二个思路基本上一致，只不过对于部分进行了优化，比如之前的取最短的链表的长度，这个需要做两次判断，因为不知道哪个链表短，采取的方式也不一样，所以这里可以做一些优化。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> headB;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">lengthA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">lengthB</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">null</span>) &#123;<br>          lengthA++;<br>          p1 = p1.next;<br>      &#125;<br><br>      <span class="hljs-keyword">while</span> (p2 != <span class="hljs-literal">null</span>) &#123;<br>          lengthB++;<br>          p2 = p2.next;<br>      &#125;<br><br>      p1 = headA;<br>      p2 = headB;<br>      <span class="hljs-comment">// 判断长度</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> lengthA &gt; lengthB ? lengthA - lengthB : lengthB - lengthA;<br>      <span class="hljs-keyword">if</span> (lengthA&gt;lengthB)&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">while</span> (a &lt; sub)&#123;<br>              p1 = p1.next;<br>              a++;<br>          &#125;<br>      &#125;<br><br><br>      <span class="hljs-keyword">if</span> (lengthB&gt;lengthA)&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">while</span> (b&lt;sub)&#123;<br>              p2 = p2.next;<br>              b++;<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">while</span> (p1!=p2)&#123;<br>          p1 =p1.next;<br>          p2=p2.next;<br>      &#125;<br>      <span class="hljs-keyword">return</span> p1;<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-7.png" alt="img.png"></p><p>时间复杂度：两个链表遍历长度O(m+n)，判断sub谁小O(sub)，同步找到公共节点O(min(m,n))，总的O(m+n+min(m,n)+sub)；<br>空间复杂度：O(1)</p><p>总结: 相比于之前的代码这个还节省了内存。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其中有3个方法都是围绕着链表的长度来的，很明显，这道题目核心就是链表长度。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql面试题-1</title>
    <link href="/post/29c5c92c.html"/>
    <url>/post/29c5c92c.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Mysql的基础架构-Sql在Mysql里面的执行流程"><a href="#1-Mysql的基础架构-Sql在Mysql里面的执行流程" class="headerlink" title="1. Mysql的基础架构&#x2F;Sql在Mysql里面的执行流程"></a>1. Mysql的基础架构&#x2F;Sql在Mysql里面的执行流程</h1><p>有连接器，查询缓存，分析器，优化器，执行器，插件式存储引擎。<br><img src="/images/mysql-1.png" alt="img.png"><br>连接器：身份认证以及权限登录，管理链接吗，查询认证。<br>查询缓存：执行查询语句，如果缓存里面有数据就直接返回。（Mysql 8已经移除，不常用）<br>分析器：检查sql是否有问题，词法分析，语法分析。<br>优化器：按照mysql认为的最优解来执行，选择。<br>执行器：执行sql代码，但是执行前还是要检查用户权限。<br>存储引擎：存储数据，提供读写接口</p><h1 id="2-Mysql支持的存储引擎"><a href="#2-Mysql支持的存储引擎" class="headerlink" title="2. Mysql支持的存储引擎"></a>2. Mysql支持的存储引擎</h1><p>通过show engines查看，这里我的是Mysql 8<br><img src="/images/mysql-2.png" alt="img.png"><br>一般默认的是InnoDB，只有InnoDB支持事务性存储引擎，也就是支持事务。<br>Mysql 5这里是MyISAM </p><h1 id="3-Mysql的存储引擎架构"><a href="#3-Mysql的存储引擎架构" class="headerlink" title="3. Mysql的存储引擎架构"></a>3. Mysql的存储引擎架构</h1><p>mysql采用的是<strong>插件式架构</strong>，支持多种存储引擎。存储引擎是基于表的，而不是数据库。</p><h1 id="4-MylSAM和InnoDB的区别"><a href="#4-MylSAM和InnoDB的区别" class="headerlink" title="4. MylSAM和InnoDB的区别"></a>4. MylSAM和InnoDB的区别</h1><ol><li>InnoDB支持行级锁，MylSAM只支持表级锁</li><li>InnoDB支持事务，定义了四个隔离级别，MylSAM不支持</li><li>InnoDB支持MVCC，MylSAM不支持</li><li>InnoDB支持外键（一般不推荐）</li><li>InnoDB支持数据崩溃后能够安全恢复</li><li>InnoDB性能好。</li><li>虽然两者都是使用B+tree实现的，但是有差别，InnoDB数据文件本身就是索引，而MylSAM，索引文件，数据文件是分离的。</li></ol><h1 id="5-事务"><a href="#5-事务" class="headerlink" title="5. 事务"></a>5. 事务</h1><h2 id="5-1-什么是事务？"><a href="#5-1-什么是事务？" class="headerlink" title="5.1 什么是事务？"></a>5.1 什么是事务？</h2><p>逻辑上的一组操作，要么都成功，要么都失败。</p><h2 id="5-2-什么是ACID"><a href="#5-2-什么是ACID" class="headerlink" title="5.2 什么是ACID"></a>5.2 什么是ACID</h2><ol><li>原子性：事务是最小的执行单位，事物的原子性保证操作要么都成功，要么都失败。</li><li>一致性：执行事务前后，数据保持一致</li><li>隔离性：并发访问数据库，一个用户的事务是不会被其他事务干扰，各并发事务间是独立的。</li><li>持久性：一个事务提交，对数据库的改变是永久的，哪怕数据库崩溃后恢复。</li></ol><p>原子性，隔离性，持久性都是为了一致性（一直以来的误区，这四个并不是同一层面）<br><img src="/images/mysql-3.png" alt="img.png"></p><h2 id="5-3-并发带来的问题"><a href="#5-3-并发带来的问题" class="headerlink" title="5.3 并发带来的问题"></a>5.3 并发带来的问题</h2><ul><li>脏读：一个事务读取了数据，对数据进行操作修改，另一个事务读取了修改后的数据，但是第一个事务回滚，数据恢复原来的数据，但是第二个事务并不知道，读取的就是脏数据。</li><li>幻读：当一个事务读取了几行数据，另一个并发事务又添加了几条数据，第一个事务就多了些原本不存在的数据。</li><li>不可重复读：当一个事务多次读取一个数据，第二个事务读取数据并且进行操作修改，第一个事务两次读的数据就不一致。</li><li>丢失修改：在一个事务读取数据后，另一个事务也来读取数据，第一个事务对于数据进行操作后，第二个事务也对数据进行了操作，那么第一个事务就认为自己已经操作成功，但是实际上已经丢失了。</li></ul><h2 id="5-4-事物的并发控制有哪些？"><a href="#5-4-事物的并发控制有哪些？" class="headerlink" title="5.4 事物的并发控制有哪些？"></a>5.4 事物的并发控制有哪些？</h2><p>锁和MVCC，锁可以看作悲观控制模式，MVCC多版本并发，可以看作乐观控制的模式。<br>读写锁：</p><ol><li>共享锁（S锁）：读锁。事务读取记录的时候获取共享锁，允许多个事务获取。</li><li>排他锁（X锁）：写锁，当一个事务获取锁来进行对数据的修改写入，其他事务就不能获取这个锁</li></ol><p>MVCC多版本并发控制：隐藏字段，undo log，read view</p><ol><li>undo log：记录某行多个数据的版本</li><li>read view和隐藏字段：判断当前版本数据的可见性。</li></ol><h2 id="5-5-SQL定义了哪些事务隔离级别"><a href="#5-5-SQL定义了哪些事务隔离级别" class="headerlink" title="5.5 SQL定义了哪些事务隔离级别"></a>5.5 SQL定义了哪些事务隔离级别</h2><ol><li>READ_UNCOMMITTED(读取未提交)：允许读取尚未提交的数据，会导致脏读，幻读，不可重复读</li><li>READ_COMMITTED(读取已提交)：允许读取已经提交的数据，可以阻止脏读，但是不可以组织幻读和不可重复读</li><li>REPEATABLE-READ(可重复读)：对同一字段的多个读取结果都是一致的，除非事务进行修改，可以阻止脏读，不可重复读，但是不可以阻止幻读。</li><li>SERIALIZABLE(可串行化)：完全服从ACID的隔离级别，事务逐个执行，可以防止脏读，幻读，不可重复读</li></ol><h2 id="5-6-Mysql默认事务隔离级别"><a href="#5-6-Mysql默认事务隔离级别" class="headerlink" title="5.6 Mysql默认事务隔离级别"></a>5.6 Mysql默认事务隔离级别</h2><p>可重复读<br>SELECT @@transaction_isolation;<br><img src="/images/mysql-4.png" alt="img.png"></p><h2 id="5-7-Mysql隔离级别是基于锁实现的吗？"><a href="#5-7-Mysql隔离级别是基于锁实现的吗？" class="headerlink" title="5.7 Mysql隔离级别是基于锁实现的吗？"></a>5.7 Mysql隔离级别是基于锁实现的吗？</h2><p>基于锁和MVCC，只是最高级别可串行化，里面使用了锁，而MVCC主要用于读取已提交和可重复读。</p><h1 id="6-Mysql锁"><a href="#6-Mysql锁" class="headerlink" title="6 Mysql锁"></a>6 Mysql锁</h1><h2 id="6-1-表级锁和行级锁区别？"><a href="#6-1-表级锁和行级锁区别？" class="headerlink" title="6.1 表级锁和行级锁区别？"></a>6.1 表级锁和行级锁区别？</h2><p>表级锁：锁定粒度最大的锁，针对非索引字段加上的锁，对当前操作的整张表进行加锁，实现简单，资源消耗少，不会出现死锁，高并发效率低。InnoDB和MylSAM都支持。<br>行级锁：锁定粒度最小的锁，针对索引字段加上的锁，只针对当前操作的行记录加锁。减少了数据库的冲突，开销较大，可能死锁。与存储引擎有关。</p><h2 id="6-2-行级锁有什么使用事项？"><a href="#6-2-行级锁有什么使用事项？" class="headerlink" title="6.2 行级锁有什么使用事项？"></a>6.2 行级锁有什么使用事项？</h2><p>行级锁主要是针对有索引的字段加上的锁，而表级锁是针对非索引字段加上的锁。当我们执行update，delete语句的时候，如果where后面的字段没有命中唯一索引或者索引失效，就对表里面的所有数据都加上锁，走全表扫描。</p><h2 id="6-3-InnoDB有哪几类行锁？"><a href="#6-3-InnoDB有哪几类行锁？" class="headerlink" title="6.3 InnoDB有哪几类行锁？"></a>6.3 InnoDB有哪几类行锁？</h2><p>记录锁（Record Lock）：单个行记录上的锁, 只能锁住已经存在的记录，为避免插入新纪录，需要依赖间隙锁。<br>间隙锁（Gap Lock）：锁定一个范围不包括记录本身<br>临键锁（Next-Key Lock）：锁定一个范围，包括记录本身。解决幻读。</p><p>InnoDB默认的隔离级别是可重复读，行级锁默认使用临键锁，但是如果有操作是唯一索引，或者主键，将会采用降级为记录锁，仅锁住索引本身，而不是范围。</p><h2 id="6-4-共享锁和排他锁"><a href="#6-4-共享锁和排他锁" class="headerlink" title="6.4 共享锁和排他锁"></a>6.4 共享锁和排他锁</h2><p>共享锁（S锁）：读锁，当一个事务读取记录的时候，获取共享锁，其他事务也能获取共享锁。<br>排他锁（X锁）：写锁，当一个事务进行修改写入的时候获取锁，其他事务就不能获取锁。</p><h2 id="6-5-意向锁"><a href="#6-5-意向锁" class="headerlink" title="6.5 意向锁"></a>6.5 意向锁</h2><p>判断是否可以对某个表使用表锁，是表级锁<br>有两种：</p><ol><li>意向共享锁：事务有意向对表中的某些记录加上共享锁，加锁之前必须获取IS锁</li><li>意向排他锁：事务有意向对表中的某些记录加上排他锁，加锁之前必须获取IX锁。<br>意向锁是数据引擎自己维护的，用户无法手动操作意向锁</li></ol>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法通关村第一关——链表经典问题之判断是否为回文序列</title>
    <link href="/post/f90e52df.html"/>
    <url>/post/f90e52df.html</url>
    
    <content type="html"><![CDATA[<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br><a href="https://leetcode.cn/problems/palindrome-linked-list/">力扣234</a></p><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="1. 分析"></a>1. 分析</h2><p><img src="/images/img-s1-1.png" alt="img.png"></p><h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><p>就是遍历链表，将元素写入数组，然后数组采用二分等等来比较。还有一种是将这些变成数字，然后使用数字的回文表示，但是由于这里是链表，考察的并不是其他的方法，就不做考虑。</p><h3 id="1-2-栈"><a href="#1-2-栈" class="headerlink" title="1.2 栈"></a>1.2 栈</h3><p>采用栈，将链表元素先全部入栈，出来后就是逆序的链表的值，然后依次比对是否一样，这里有个优化点，就是只需要比较一半，因为回文的另一半是一样的，不一样的肯定不是回文。<br><img src="/images/img_s1-2.png" alt="img_1.png"></p><h3 id="1-3-翻转链表"><a href="#1-3-翻转链表" class="headerlink" title="1.3 翻转链表"></a>1.3 翻转链表</h3><p>创建一个新的链表，然后使用反转链表，将元素依次插入，然后将新链表和原链表相应的值进行比较<br><img src="/images/img_s1-3.png" alt="img_2.png"></p><h3 id="1-4-快慢指针"><a href="#1-4-快慢指针" class="headerlink" title="1.4 快慢指针"></a>1.4 快慢指针</h3><p>可以将链表的后半部分反转，然后将前半部分和后半部分进行比较，比较难以想到。</p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h2><h3 id="2-1-栈"><a href="#2-1-栈" class="headerlink" title="2.1 栈"></a>2.1 栈</h3><p>思路主要是先将元素都入栈，然后使用栈的长度和链表长度比较，里面主要是比较是否元素相等，再一次遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<br>       Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>           stack.push(current.value);<br>           current = current.next;<br>       &#125;<br>       <span class="hljs-keyword">while</span> (head!=<span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">if</span> (head.value  != stack.pop())&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>           head = head.next;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度: O(n)，需要遍历两次链表，第一次入栈，第二次比较<br>空间复杂度: O(n)，链表长度n</p><p>运行<br><img src="/images/img_s1-4.png" alt="img_3.png"><br>解决速度并不是太好</p><h3 id="2-2-栈优化"><a href="#2-2-栈优化" class="headerlink" title="2.2 栈优化"></a>2.2 栈优化</h3><p>既然是回文数，那么另一半是对称的，只需要在出栈的时候比较一半的元素就可以了，需要使用一个计数器来比较，偶数个元素，正好一半，奇数个，中间往两边对称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(current.value);<br>            current = current.next;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> stack.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (count != size / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (head.value != stack.pop()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            head = head.next;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度:  O(n)，但是这个是l&#x2F;2个长度，所以还是n</p><p>运行<br><img src="/images/img_s1-5.png" alt="img_4.png"><br>可以看出有一点提升，但是不明显</p><h3 id="2-3-反转链表"><a href="#2-3-反转链表" class="headerlink" title="2.3 反转链表"></a>2.3 反转链表</h3><p>这个思路很简单，只需要创建一个新的链表，然后相应的指针是逆序而已，然后一一比较对应的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 反转链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">reversed</span> <span class="hljs-operator">=</span> reverseList(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-keyword">while</span> (reversed != <span class="hljs-literal">null</span> &amp;&amp; current != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (reversed.value != current.value) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            reversed = reversed.next;<br>            current = current.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反转链表，不影响原链表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">reversed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 只需要将当前节点的值给到一个空节点，然空节点代替原来的节点进行操作</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(current.value);<br>            newNode.next = reversed;<br>            reversed = newNode;<br>            current = current.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> reversed;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里一开始苦恼的问题是反转链表之后，原来的链表就不存在了，后面了解到了一种方法，就是使用新节点保存值来替代对原来节点的操作。</p><p>时间复杂度：O(n)，主要是两个部分，一个是反转链表遍历O(n) ，比较节点值是O(n&#x2F;2)<br>空间复杂度：O(n) 链表的长度</p><p>运行<br><img src="/images/img_s1-6.png" alt="img_5.png"><br>使用了部分空间换时间</p><h3 id="2-4-反转链表-快慢指针"><a href="#2-4-反转链表-快慢指针" class="headerlink" title="2.4 反转链表+快慢指针"></a>2.4 反转链表+快慢指针</h3><p>上面反转链表还是将所有元素数据都反转了，但是既然是回文数，那么就意味着只需要反转一半元素。先遍历一遍，得到长度，然后重新遍历，到达一半之后反转了，直接比较两个链表的长度即可。<br>这个比较难以想到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-comment">// 特殊情况，只有一个节点或者没有节点</span><br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-comment">// prepre反转好的头节点</span><br>    <span class="hljs-comment">// pre当前处理的节点</span><br>    <span class="hljs-comment">// slow向后移动</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head, prepre = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        pre = slow;<br>        <span class="hljs-comment">// 慢指针移动一步</span><br>        slow = slow.next;<br>        <span class="hljs-comment">// 快指针移动两步</span><br>        fast = fast.next.next;<br>        pre.next = prepre;<br>        prepre = pre;<br>    &#125;<br>    <span class="hljs-comment">// 快指针不为空，是奇数，慢指针后移一位</span><br>    <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-comment">// pre处理前半部分链表</span><br>    <span class="hljs-comment">// slow处理后半部分部分链表</span><br>    <span class="hljs-keyword">while</span>(pre != <span class="hljs-literal">null</span> &amp;&amp; slow != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span>(pre.value != slow.value) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        pre = pre.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n),只需要遍历一次链表<br>空间复杂度：O(1)使用了指针</p><p>运行<br><img src="/images/img_s1-7.png" alt="img_6.png"><br>这个方法是目前来说最快的，但是不理解这4个指针的话，甚至看不懂这个代码，快慢指针负责移动，剩余两个指针做链表反转一半，然后比对，这个还是需要在思索思索，还是有点绕在里面</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>Java</tag>
      
      <tag>回文数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法第一关——链表青铜挑战笔记</title>
    <link href="/post/cb83085.html"/>
    <url>/post/cb83085.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1. 单链表"></a>1. 单链表</h1><h2 id="1-单链表的建造"><a href="#1-单链表的建造" class="headerlink" title="1. 单链表的建造"></a>1. 单链表的建造</h2><p>链表有两个属性，一个就是当前的值val，还有一个就是记录当前节点的下一个节点位置，由此可以写出建造链表的相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    ListNode next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value, ListNode next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(ListNode next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-链表遍历"><a href="#2-链表遍历" class="headerlink" title="2. 链表遍历"></a>2. 链表遍历</h2><p>链表没有相关属性来记录当前的链表长度，所以只能经过遍历获取链表长度</p><p><img src="/images/img_2.png" alt="img_2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getListNodeLength</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-keyword">while</span> (listNode != <span class="hljs-literal">null</span>) &#123;<br>           length++;<br>           listNode = listNode.next;<br>       &#125;<br>       <span class="hljs-keyword">return</span> length;<br>   &#125;<br></code></pre></td></tr></table></figure><p>链表展示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-keyword">while</span> (listNode != <span class="hljs-literal">null</span>) &#123;<br>           System.out.print(listNode.value + <span class="hljs-string">&quot;=&gt;&quot;</span>);<br>           listNode = listNode.next;<br>       &#125;<br>       System.out.println(<span class="hljs-string">&quot;null&quot;</span>);<br>   &#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3. 插入元素"></a>3. 插入元素</h2><h3 id="3-1-头插法"><a href="#3-1-头插法" class="headerlink" title="3.1 头插法"></a>3.1 头插法</h3><p><img src="/images/img_4.png" alt="img_4.png"><br>头插法相对简单<br>新节点的下一个元素指向当前的头节点，然后头节点移动到新的节点处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">insertIntoNode</span><span class="hljs-params">(ListNode head, ListNode newNode)</span> &#123;<br>    newNode.next = head;<br>    head = newNode;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-尾插法"><a href="#3-2-尾插法" class="headerlink" title="3.2 尾插法"></a>3.2 尾插法</h3><p>在最后一个元素处后面插入元素，即最后一个元素的next指向插入元素，插入元素的下一个指向null<br><img src="/images/img_5.png" alt="img_5.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">insertIntoTail</span><span class="hljs-params">(ListNode head, ListNode newNode)</span> &#123;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>      <span class="hljs-keyword">while</span> (listNode.next != <span class="hljs-literal">null</span>) &#123;<br>          listNode = listNode.next;<br>      &#125;<br>      listNode.next = newNode;<br>      newNode.next = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">return</span> head;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-指定位置插入"><a href="#3-3-指定位置插入" class="headerlink" title="3.3 指定位置插入"></a>3.3 指定位置插入</h3><p>需要找到插入元素的位置的前一个元素，先将新建节点的next指向当前位置的下一个节点的位置，然后将当前节点的next指向新建节点</p><p>这两个顺序不能颠倒，如果颠倒了，当前节点就无法找到当前节点的下一个元素的位置，这时候连接已经断了，成为了两个链表<br><img src="/images/img_6.png" alt="img_6.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">insertIntoPosition</span><span class="hljs-params">(ListNode head, ListNode newNode, <span class="hljs-type">int</span> position)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span> (length &lt; position - <span class="hljs-number">1</span>) &#123;<br>           listNode = listNode.next;<br>           length++;<br>       &#125;<br>       newNode.next = listNode.next;<br>       listNode.next = newNode;<br>       <span class="hljs-keyword">return</span> head;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h3><p>以上3个方法较为独立，都是没有考虑到一些特殊情况，比如链表为空，插入元素的位置查过当前链表的界限，下面将会综合以上考虑完成较为完整的插入代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">insertIntoListNode</span><span class="hljs-params">(ListNode head, ListNode newNode, <span class="hljs-type">int</span> position)</span> &#123;<br>        <span class="hljs-comment">// 当前链表为空，插入元素则为第一个节点</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> newNode;<br>        &#125;<br>        <span class="hljs-comment">// 是否超过界限</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">listNodeLength</span> <span class="hljs-operator">=</span> getListNodeLength(head);<br>        <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">1</span> || position &gt; listNodeLength + <span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;元素越界&quot;</span>);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// 头节点</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) &#123;<br>            newNode.next = head;<br>            head = newNode;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 指定位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (count &lt; position - <span class="hljs-number">1</span>) &#123;<br>            node = node.next;<br>            count++;<br>        &#125;<br>        newNode.next = node.next;<br>        node.next = newNode;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4-删除元素"><a href="#4-删除元素" class="headerlink" title="4 删除元素"></a>4 删除元素</h2><h3 id="4-1-头删"><a href="#4-1-头删" class="headerlink" title="4.1 头删"></a>4.1 头删</h3><p>相对来说简单，只需要将头节点向后移动即可<br><img src="/images/img_7.png" alt="img_7.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">deleteHead</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>    listNode = listNode.next;<br>    head = listNode;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-尾删"><a href="#4-2-尾删" class="headerlink" title="4.2 尾删"></a>4.2 尾删</h3><p>主要需要找到尾部元素的前一个元素，将他的下一个节点指向null即可<br><img src="/images/img_8.png" alt="img_8.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">deleteTail</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (listNode.next.next != <span class="hljs-literal">null</span>) &#123;<br>            listNode = listNode.next;<br>        &#125;<br>        listNode.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-指定位置删除"><a href="#4-3-指定位置删除" class="headerlink" title="4.3 指定位置删除"></a>4.3 指定位置删除</h3><p><img src="/images/img_9.png" alt="img_9.png"><br>需要找到删除元素的前一个元素，先保留删除元素和前一个元素之间的联系，不能断开，否则无法找到后面的其他节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">deleteByPosition</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> position)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (count &lt; position - <span class="hljs-number">1</span>) &#123;<br>            count++;<br>            listNode = listNode.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">deleteNode</span> <span class="hljs-operator">=</span> listNode.next;<br>        listNode.next = deleteNode.next;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="综合删除"><a href="#综合删除" class="headerlink" title="综合删除"></a>综合删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">deletePosition</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> position)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-comment">// 链表为空</span><br>       <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br><br>       <span class="hljs-comment">// 判断界限</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">listNodeLength</span> <span class="hljs-operator">=</span> getListNodeLength(head);<br>       <span class="hljs-comment">// 这里不需要判断listNodeLength+1，因为下面已经记录了删除元素的前一个节点，和删除节点的下一个节点存不存在没有关系</span><br>       <span class="hljs-keyword">if</span> (position &gt; listNodeLength || position &lt; <span class="hljs-number">1</span>) &#123;<br>           System.out.println(<span class="hljs-string">&quot;超过界限&quot;</span>);<br>           <span class="hljs-keyword">return</span> head;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) &#123;<br>           listNode = listNode.next;<br>           head = listNode;<br>           <span class="hljs-keyword">return</span> head;<br>       &#125;<br><br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span> (count &lt; position - <span class="hljs-number">1</span>) &#123;<br>           preNode = preNode.next;<br>           count++;<br>       &#125;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">deleteNode</span> <span class="hljs-operator">=</span> preNode.next;<br>       preNode.next = deleteNode.next;<br>       <span class="hljs-keyword">return</span> head;<br><br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2. 双向链表"></a>2. 双向链表</h1><h2 id="1-双向链表的建立"><a href="#1-双向链表的建立" class="headerlink" title="1. 双向链表的建立"></a>1. 双向链表的建立</h2><p>单链表只能获取自己的后一个节点的元素，而双向链表里面有两个指针，可以获取前后节点<br><img src="/images/img_10.png" alt="img_10.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleListNode</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    DoubleListNode preNode;<br>    DoubleListNode nextNode;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value, DoubleListNode preNode, DoubleListNode nextNode)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.preNode = preNode;<br>        <span class="hljs-built_in">this</span>.nextNode = nextNode;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleListNode</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleListNode</span><span class="hljs-params">(DoubleListNode preNode)</span> &#123;<br>        <span class="hljs-built_in">this</span>.preNode = preNode;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleListNode</span><span class="hljs-params">(DoubleListNode preNode, DoubleListNode nextNode)</span> &#123;<br>        <span class="hljs-built_in">this</span>.preNode = preNode;<br>        <span class="hljs-built_in">this</span>.nextNode = nextNode;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 展示数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayNode</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;&#123;&quot;</span> + value + <span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>数据准备</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">doubleListNode1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleListNode</span>(<span class="hljs-number">1</span>);<br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">doubleListNode2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleListNode</span>(<span class="hljs-number">2</span>);<br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">doubleListNode3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleListNode</span>(<span class="hljs-number">3</span>);<br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">doubleListNode4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleListNode</span>(<span class="hljs-number">5</span>);<br>       doubleListNode1.nextNode = doubleListNode2;<br>       doubleListNode2.preNode = doubleListNode1;<br>       doubleListNode2.nextNode = doubleListNode3;<br>       doubleListNode3.preNode = doubleListNode2;<br>       doubleListNode3.nextNode = doubleListNode4;<br>       doubleListNode4.preNode = doubleListNode3;<br></code></pre></td></tr></table></figure><h2 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2. 遍历"></a>2. 遍历</h2><h3 id="2-1-头部遍历"><a href="#2-1-头部遍历" class="headerlink" title="2.1 头部遍历"></a>2.1 头部遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayDoubleNodeFromHead</span><span class="hljs-params">(DoubleListNode head)</span> &#123;<br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">// 展示</span><br>           current.displayNode();<br>           current = current.nextNode;<br>       &#125;<br>       System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-尾部遍历"><a href="#2-2-尾部遍历" class="headerlink" title="2.2 尾部遍历"></a>2.2 尾部遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayDoubleNodeFromTail</span><span class="hljs-params">(DoubleListNode tail)</span> &#123;<br>    <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>        current.displayNode();<br>        current = current.preNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面的tail记住选最后一个节点</p><h2 id="3-插入数据"><a href="#3-插入数据" class="headerlink" title="3 插入数据"></a>3 插入数据</h2><h3 id="3-1-头部插入"><a href="#3-1-头部插入" class="headerlink" title="3.1 头部插入"></a>3.1 头部插入</h3><p><img src="/images/img_12.png" alt="img_12.png"><br>只需要将新建节点的next指向原来的head，将原来的head的pre指向新建节点，head改变即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleListNode <span class="hljs-title function_">insetIntoNodeHead</span><span class="hljs-params">(DoubleListNode head, DoubleListNode newNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br>    newNode.nextNode = head;<br>    head.preNode = newNode;<br>    head = newNode;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-尾部插入"><a href="#3-2-尾部插入" class="headerlink" title="3.2 尾部插入"></a>3.2 尾部插入</h3><p><img src="/images/img_13.png" alt="img_13.png"><br>只需要将tail节点的next指向新建节点，新建节点的pre指向tail节点，tail改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleListNode <span class="hljs-title function_">insetIntoNodeTail</span><span class="hljs-params">(DoubleListNode tail, DoubleListNode newNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tail == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br>    tail.nextNode = newNode;<br>    newNode.preNode = tail;<br>    tail = newNode;<br>    <span class="hljs-keyword">return</span> tail;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-指定位置插入-1"><a href="#3-3-指定位置插入-1" class="headerlink" title="3.3 指定位置插入"></a>3.3 指定位置插入</h3><p><img src="/images/img_14.png" alt="img_14.png"></p><p>这个就有点麻烦，需要改动四个指针，还需要考虑第一个和最后一个节点的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleListNode <span class="hljs-title function_">insetIntoNodeByPosition</span><span class="hljs-params">(DoubleListNode head, DoubleListNode newNode, <span class="hljs-type">int</span> position)</span> &#123;<br>       <span class="hljs-comment">// 空节点</span><br>       <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> newNode;<br>       &#125;<br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br><br>       <span class="hljs-comment">// 头节点</span><br>       <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) &#123;<br>           newNode.nextNode = head;<br>           head.preNode = newNode;<br>           <span class="hljs-keyword">return</span> newNode;<br>       &#125;<br><br><br>       <span class="hljs-comment">// 计算处添加节点的前一个节点</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span> (count &lt; position - <span class="hljs-number">2</span> &amp;&amp; current.nextNode != <span class="hljs-literal">null</span>) &#123;<br>           current = current.nextNode;<br>           count++;<br>       &#125;<br><br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> current.nextNode;<br>       <span class="hljs-keyword">if</span> (nextNode != <span class="hljs-literal">null</span>) &#123;<br>           nextNode.preNode = newNode;<br>           newNode.nextNode = nextNode;<br>       &#125;<br><br>       current.nextNode = newNode;<br>       newNode.preNode = current;<br><br>       <span class="hljs-keyword">return</span> head;<br>   &#125;<br></code></pre></td></tr></table></figure><p>注意这里需要将新的链表传递给展示的方法才能展示新的链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">doubleListNode</span> <span class="hljs-operator">=</span> insetIntoNodeByPosition(doubleListNode1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleListNode</span>(<span class="hljs-number">4</span>), <span class="hljs-number">4</span>);<br>displayDoubleNodeFromHead(doubleListNode);<br></code></pre></td></tr></table></figure><h2 id="4-删除元素-1"><a href="#4-删除元素-1" class="headerlink" title="4. 删除元素"></a>4. 删除元素</h2><h3 id="4-1-删除头节点"><a href="#4-1-删除头节点" class="headerlink" title="4.1 删除头节点"></a>4.1 删除头节点</h3><p><img src="/images/img_15.png" alt="img_15.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(DoubleListNode head, <span class="hljs-type">int</span> position)</span> &#123;<br>        <span class="hljs-comment">// 头节点不存在</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 删除头节点</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> current.nextNode;<br>            nextNode.preNode = <span class="hljs-literal">null</span>;<br>            head = nextNode;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br><span class="hljs-comment">// 找到指定位置的节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (count &lt; position &amp;&amp; current != <span class="hljs-literal">null</span>) &#123;<br>            current = current.nextNode;<br>            count++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">prevNode</span> <span class="hljs-operator">=</span> current.preNode;<br>            <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> current.nextNode;<br><br>            <span class="hljs-keyword">if</span> (prevNode != <span class="hljs-literal">null</span>) &#123;<br>                prevNode.nextNode = nextNode;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (nextNode != <span class="hljs-literal">null</span>) &#123;<br>                nextNode.preNode = prevNode;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 当前节点是最后一个节点</span><br>                prevNode.nextNode = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>双向链表的插入和删除相对较为繁琐，但是步骤很简单，自己多画一些图就能理解。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/flybase1/AlgorithmPrtojects">https://github.com/flybase1/AlgorithmPrtojects</a></p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>里面部分代码还是可能有些问题，希望大家能够指出其中的错误，共同进步。<br>由于部分链接图片无法显示，可移步<a href="http://t.csdn.cn/bZbuS">http://t.csdn.cn/bZbuS</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Stable Diffusion</title>
    <link href="/post/5b798e2f.html"/>
    <url>/post/5b798e2f.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要使用Kaggle"><a href="#1-为什么要使用Kaggle" class="headerlink" title="1. 为什么要使用Kaggle"></a>1. 为什么要使用Kaggle</h2><p>优点：提供免费的GPU，每周有30个小时的免费使用，不使用的时候就关闭，完全足够使用<br>缺点：优点难以上手，原本是机器学习竞赛平台等等，需要特殊网络</p><h2 id="2-注册"><a href="#2-注册" class="headerlink" title="2. 注册"></a>2. 注册</h2><p><a href="https://www.kaggle.com/">https://www.kaggle.com/</a><br>这里可以选择自己需要的方式进行注册</p><h2 id="3-运行模型"><a href="#3-运行模型" class="headerlink" title="3. 运行模型"></a>3. 运行模型</h2><p>在主界面搜索zh-stable-diffusion-webui-kaggle<br>点击右上角Edit My Copy<br>选择右边Notebook options里面有个Get phone verified（手机验证，使用国内的手机可以接受验证码）<br>选择Notebook options的INTERNET，点击开启Internet on<br>点击Notebook options的ACCELERATOR，选择GPU T4✖2<br>点击中间的电源开机键<br>点击左边的三角运行<br>等待部署<br>最后应该能够看见Running on public URL: <a href="https://538e8529-d008-470d.gradio.live,点击地址运行即可/">https://538e8529-d008-470d.gradio.live，点击地址运行即可</a><br><img src="http://cdn.flycode.icu/img/202307152036274.png" alt="image-20230715203012967"></p><p>个人使用效果地址<br><a href="https://blog.csdn.net/qq_52843958/article/details/131743019">https://blog.csdn.net/qq_52843958/article/details/131743019</a></p><h2 id="4-谨记"><a href="#4-谨记" class="headerlink" title="4. 谨记"></a>4. 谨记</h2><p>不使用了就关闭</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI绘画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试题基础-5</title>
    <link href="/post/dc612634.html"/>
    <url>/post/dc612634.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是BIO-Block"><a href="#1-什么是BIO-Block" class="headerlink" title="1. 什么是BIO(Block)"></a>1. 什么是BIO(Block)</h2><p>同步阻塞模型，当应用程序调用一次read之后，会一直阻塞，直到内核完全将数据拷贝到用户空间<br>缺点：并发场景不适用。<br><a href="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/5acc17a26b49bf261766ab89eb804690.png&sign=d873806d567370a5adeee9111b49dfe7f0be99d2f86f0cd9e1bbcaf9e564475d">https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F5acc17a26b49bf261766ab89eb804690.png&amp;sign=d873806d567370a5adeee9111b49dfe7f0be99d2f86f0cd9e1bbcaf9e564475d</a></p><h2 id="2-什么是NIO（Non-block）"><a href="#2-什么是NIO（Non-block）" class="headerlink" title="2. 什么是NIO（Non-block）"></a>2. 什么是NIO（Non-block）</h2><p>同步非阻塞模型，返回调用read，让内核准备数据，等待数据从内核空间完全拷贝到用户空间这个时间，线程依然阻塞，直到内核完全把数据拷贝到用户空间。<br>优点：通过轮询避免阻塞<br>缺点：不停的调用模型，耗费CPU性能</p><h2 id="3-IO多路复用"><a href="#3-IO多路复用" class="headerlink" title="3. IO多路复用"></a>3. IO多路复用</h2><p>应用程序的线程首先发起select调用，询问内核是否准备成功ready，成功就发起read调用，等待数据从内核完全拷贝到用户空间，但是拷贝的过程还是阻塞的。<br>有带你：解决了NIO一直轮询耗费资源的情况。</p><h2 id="4-AIO"><a href="#4-AIO" class="headerlink" title="4. AIO"></a>4. AIO</h2><p>异步IO<br>应用调用之后会立即返回，而不是等待，直到任务成功发起回调</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>java</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试题基础-4</title>
    <link href="/post/ae0811d8.html"/>
    <url>/post/ae0811d8.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-ReentrantLock是什么？"><a href="#1-ReentrantLock是什么？" class="headerlink" title="1. ReentrantLock是什么？"></a>1. ReentrantLock是什么？</h2><p>   可重入独占式的锁，比synchronized更加灵活，增加了超时，轮询，中断，公平锁（先申请的先获取锁），非公平锁(随机或者有 相应的顺序)。</p><h2 id="2-ThreadLocal是什么？原理？"><a href="#2-ThreadLocal是什么？原理？" class="headerlink" title="2. ThreadLocal是什么？原理？"></a>2. ThreadLocal是什么？原理？</h2><p>可以让每个线程都有自己的本地变量<br>set源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br><span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>map.set(<span class="hljs-built_in">this</span>, value);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>createMap(t, value);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终的变量是存放了ThreadLocalMap里面，而不是ThreadLocal。每一个Thread都具备一个ThreadLocalMap，而ThreadLocalMap可以存放ThreadLocal为key，Object对象为Value的值。</p><h2 id="3-ThreadLocal内存泄漏"><a href="#3-ThreadLocal内存泄漏" class="headerlink" title="3. ThreadLocal内存泄漏"></a>3. ThreadLocal内存泄漏</h2><p>由于ThreadLocalMap里面的key是弱引用，而value是强引用，所以垃圾回收的时候会将key清除，而value保存，最终会导致一个key为null的Enrty，产生内存泄露。<br>解决方法：手动调用remove方法。</p><h2 id="4-什么是线程池？线程池的作用？如何创建线程池？"><a href="#4-什么是线程池？线程池的作用？如何创建线程池？" class="headerlink" title="4. 什么是线程池？线程池的作用？如何创建线程池？"></a>4. 什么是线程池？线程池的作用？如何创建线程池？</h2><p>管理一系列线程的资源池。当有任务需要处理，直接从线程池取出线程，当任务结束后，线程不会销毁，而是可以等待下一个任务。<br>好处：</p><ol><li>降低资源消耗：重复使用已经创建的线程</li><li>提高响应速度：任务不需要等待线程创建，直接执行。</li><li>提高线程的可管理性：统一分配，调优，监控</li></ol><p>创建线程池：</p><ol><li>ThreadPoolExecutor创建</li><li>Executor框架创建（不推荐）</li></ol><h2 id="5-为什么不推荐使用Executor创建线程池"><a href="#5-为什么不推荐使用Executor创建线程池" class="headerlink" title="5. 为什么不推荐使用Executor创建线程池"></a>5. 为什么不推荐使用Executor创建线程池</h2><p>FixedThreadPool 和SingleThreadExecutor：使用的时无界的LinkedBlockingQueue，队列长度时Integer最大值，可能会导致OOM。<br>CachedThreadPool：SynchronousQueue可能会创建多个请求，最大值是Integer的最大值，会造成OOM<br>ScheduledThreadPool和SingleThreadScheduledExecutor : 无界延迟队列。堆积请求OOM</p><h2 id="6-线程池重要参数"><a href="#6-线程池重要参数" class="headerlink" title="6. 线程池重要参数"></a>6. 线程池重要参数</h2><h2 id="7-线程池饱和策略"><a href="#7-线程池饱和策略" class="headerlink" title="7. 线程池饱和策略"></a>7. 线程池饱和策略</h2><ol><li>拒绝新任务的处理</li><li>调用自己的线程执行任务</li><li>丢弃任务</li><li>丢弃最早未被处理的任务</li></ol><h2 id="8-线程池处理任务的流程"><a href="#8-线程池处理任务的流程" class="headerlink" title="8. 线程池处理任务的流程"></a>8. 线程池处理任务的流程</h2><ol><li>任务进来后，判断当前运行的线程数是否小于核心线程数，如果小于，直接调用新的核心线程来处理任务</li><li>如果运行线程数已经等于核心线程数，接下来新的任务会放入工作队列里面，接下来判断任务队列是否满了，如果任务队列没有满，继续添加任务队列里面去。</li><li>如果任务队列满了，新建一个线程来处理任务。判断运行的线程数是否满足等于最大线程数，如果小于，继续从工作队列里面取出任务处理。</li><li>如果线程数等于最大线程数，并且任务队列也满了，接下来就是使用饱和策略，来拒绝任务或者丢去任务。</li></ol><h2 id="9-如何设置线程池大小"><a href="#9-如何设置线程池大小" class="headerlink" title="9. 如何设置线程池大小"></a>9. 如何设置线程池大小</h2><ol><li>CPU密集型：消耗CPU资源，一般是采取CPU核数+1</li><li>IO密集型：主要是设计网络传输，文件读取，一般是设置为2n</li></ol><h2 id="10-什么是AQS？原理是什么？什么是CLH锁？"><a href="#10-什么是AQS？原理是什么？什么是CLH锁？" class="headerlink" title="10. 什么是AQS？原理是什么？什么是CLH锁？"></a>10. 什么是AQS？原理是什么？什么是CLH锁？</h2><p>抽象队列同步器，是在locks里面，主要是构建锁和同步器。例如ReentrantLock等等。<br>原理：如果请求的共享资源空闲，那么当前请求资源的线程就设置为有效的工作线程，并且将共享资源设置为锁定状态。如果请求的资源被占用，需要一套线程阻塞以及被唤醒时锁的分配机制，AQS采用CLH队列所实现的，暂时获取不到锁的线程就加入队列中去。<br>CLH：虚拟的双向队列。AQS将每条请求共享资源的线程分装成一个CLH锁队列的节点来实现所得分配、CLH同步队列，一个节点表示一个线程，保存着现成的引用，当前节点状态，前驱后继。</p><h2 id="11-什么是Semaphore-应用场景？"><a href="#11-什么是Semaphore-应用场景？" class="headerlink" title="11. 什么是Semaphore?应用场景？"></a>11. 什么是Semaphore?应用场景？</h2><p>synchronized和reentrantLock都时一次只允许一个线程访问某个资源，semaphore可以同时控制多个线程访问资源。<br>场景：有明确访问数量限制的场景比如限流，但是一般推荐redis+lua限流</p><h2 id="12-Semaphore原理"><a href="#12-Semaphore原理" class="headerlink" title="12. Semaphore原理"></a>12. Semaphore原理</h2><p>共享锁的一种实现，默认构造的AQS的state值为permits，可以将permits的值理解为许可证的数量，只有拿到许可证的线程才能执行</p><h2 id="13-什么是CountDownLatch-原理是什么？"><a href="#13-什么是CountDownLatch-原理是什么？" class="headerlink" title="13. 什么是CountDownLatch?原理是什么？"></a>13. 什么是CountDownLatch?原理是什么？</h2><p>允许count值的数量的线程同时阻塞在一个地方，直到所有的线程的任务都执行完毕。但是这个count再初始化的时候只能执行一次，使用完毕后就不能使用？<br>原理：共享锁的实现，里面是AQS的state设置为count</p><h2 id="14-CountDownLatch应用场景？"><a href="#14-CountDownLatch应用场景？" class="headerlink" title="14. CountDownLatch应用场景？"></a>14. CountDownLatch应用场景？</h2><p>使用多线程读取多个文件处理的场景</p><h2 id="15-CyclicBarrier-是什么？"><a href="#15-CyclicBarrier-是什么？" class="headerlink" title="15. CyclicBarrier 是什么？"></a>15. CyclicBarrier 是什么？</h2><p>和CountDownLatch非常类似，可以实现线程之间的技术等待，功能更加复杂。主要是将所有的线程都放置在一个屏障外面阻塞，当最后一个线程到达才开启屏障，线程才能继续干活。<br>基于ReentrantLock(基于AQS），CountDownLatch基于AQS。</p><h2 id="16-并发3大特性"><a href="#16-并发3大特性" class="headerlink" title="16. 并发3大特性"></a>16. 并发3大特性</h2><ol><li>原子性：所有操作，要么都执行，要么都不执行。</li><li>可见性：当一个线程修改了共享变量的值，其余线程都能看见</li><li>有序性：volatile禁止指令排序，指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</li></ol><h2 id="17-什么是JMM？为什么需要JMM？"><a href="#17-什么是JMM？为什么需要JMM？" class="headerlink" title="17. 什么是JMM？为什么需要JMM？"></a>17. 什么是JMM？为什么需要JMM？</h2><p>JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试题基础-3</title>
    <link href="/post/e95b42b1.html"/>
    <url>/post/e95b42b1.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-线程和进程是什么？之间的关系，区别，优缺点？"><a href="#1-线程和进程是什么？之间的关系，区别，优缺点？" class="headerlink" title="1. 线程和进程是什么？之间的关系，区别，优缺点？"></a>1. 线程和进程是什么？之间的关系，区别，优缺点？</h2><p><strong>进程</strong>：进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。<br><strong>线程</strong>：是一个比进程更小的执行单位 线程时进程划分为更小的运行单位。 线程和进程最大的不同在于进程之间基本上不会相互影响，但是线程不一样，同一个进程里面的线程可能会相互影响。<br>线程执行开销小，不利于资源的管理维护。<br>线程拥有自己的<strong>本地方法栈</strong>，<strong>虚拟机栈</strong>和<strong>程序计数器</strong>，共用<strong>方法区</strong>和<strong>堆</strong>。</p><h2 id="2-为什么要使用多线程？"><a href="#2-为什么要使用多线程？" class="headerlink" title="2. 为什么要使用多线程？"></a>2. 为什么要使用多线程？</h2><ol><li>计算机角度：充分利用多核cpu的功能</li><li>项目角度：提升系统的性能</li></ol><h2 id="3-说说线程的生命周期和状态"><a href="#3-说说线程的生命周期和状态" class="headerlink" title="3. 说说线程的生命周期和状态"></a>3. 说说线程的生命周期和状态</h2><ul><li>NEW：初始状态，未执行start()方法。</li><li>RUNNABLE:  运行状态，执行了start（）方法。</li><li>BLOCKED：阻塞状态，等待锁被释放。</li><li>WAITING：等待状态，等待通知。</li><li>TIME_WAITING:  超时等待状态，指定时间后直接返回。</li><li>TERMINATED：终止状态，表示程序已经运行完毕。<br><a href="https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w">https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w</a></li></ul><h2 id="4-什么是线程死锁？如何预防和避免死锁？"><a href="#4-什么是线程死锁？如何预防和避免死锁？" class="headerlink" title="4. 什么是线程死锁？如何预防和避免死锁？"></a>4. 什么是线程死锁？如何预防和避免死锁？</h2><p>线程死锁：多个线程处于阻塞状态，他们都在等待一个或者多个资源被释放，线程无限等待。 例如 线程1持有资源1，线程2持有资源2，它们都想获取对方的资源。<br><strong>产生条件</strong>：</p><ul><li>互斥条件：该资源任意时刻都被一个线程占有。</li><li>请求与保持：线程请求资源阻塞，对已有资源不释放</li><li>不剥夺条件：线程占有的资源未被使用完成释放前，不能被其他线程所强行剥夺</li><li>循环等待：若干线程之间循环等待资源</li></ul><p><strong>避免死锁</strong>：</p><ul><li>银行家算法等资源分配计算评估，进入安全状态</li></ul><h2 id="5-sleep和wait区别"><a href="#5-sleep和wait区别" class="headerlink" title="5. sleep和wait区别"></a>5. sleep和wait区别</h2><ol><li>sleep方法不能释放锁，而wait能释放锁。</li><li>sleep只是用于暂停当前线程运行，而wait是用于线程之间交互。</li><li>sleep调用后，线程能够自己唤醒，而wait必须要其他线程使用notify(),notifyAll(),进行唤醒。</li><li>sleep是Thread的本地方法，而wait是Object的本地方法。</li></ol><h2 id="6-可以直接调用Thread的run方法吗？"><a href="#6-可以直接调用Thread的run方法吗？" class="headerlink" title="6. 可以直接调用Thread的run方法吗？"></a>6. 可以直接调用Thread的run方法吗？</h2><p>new Thread()后，线程进入新建状态，当调用start方法，线程进入就绪状态，当分配到时间片后才开始执行，调用run方法，这才是多线程。而直接调用run方法，只是让当前线程在main线程下执行一个普通方法。</p><h2 id="7-volatile关键字"><a href="#7-volatile关键字" class="headerlink" title="7. volatile关键字"></a>7. volatile关键字</h2><ol><li>保证变量的可见性，这个变量是共享的且不稳定，每次都要从主存里面进行读取。</li><li>防止JVM重排序，使用内存屏障</li><li>不能保证对变量的操作时原子性</li></ol><h2 id="8-乐观锁和悲观锁的区别"><a href="#8-乐观锁和悲观锁的区别" class="headerlink" title="8. 乐观锁和悲观锁的区别"></a>8. 乐观锁和悲观锁的区别</h2><p><strong>悲观锁</strong>：认为每次共享资源总是会出现问题（数据修改），每次操作数据都会加上锁。共享资源每次只给一个线程使用，其他线程阻塞，用完后转换给其他线程。 问题：高并发，锁竞争造成线程阻塞；死锁。 场景：写比较多<br><strong>乐观锁</strong>：认为共享资源的访问一定是没有问题的，线程可以不停的执行，不需要加锁，只需要将最后提交的时候验证是否被其他线程修改了。 问题：没有锁，但是会有需要重试失败问题，影响性能。 场景：多读场景</p><h2 id="9-如何实现乐观锁"><a href="#9-如何实现乐观锁" class="headerlink" title="9. 如何实现乐观锁"></a>9. 如何实现乐观锁</h2><p>版本号机制：数据库增加字段version，进行比对version是否一样。<br>CAS算法：预期值与要更新的变量比较。（原子操作，一旦开始就不能打断）</p><h2 id="10-CAS算法"><a href="#10-CAS算法" class="headerlink" title="10. CAS算法"></a>10. CAS算法</h2><ul><li>E 预期的值</li><li>V 要更新的值</li><li>N 写入的新值 只有V&#x3D;E，CAS才会将N的值更新到V的值、不等就说明有线程参与操作，放弃。</li></ul><p>CAS在ConcurrentHashMap里面和synchronized保证并发安全<br>concurrent.atomic包中的类通过volatile+CAS 重试保证线程安全性</p><h2 id="11-乐观锁的问题"><a href="#11-乐观锁的问题" class="headerlink" title="11. 乐观锁的问题"></a>11. 乐观锁的问题</h2><ol><li>ABA：当要修改一个值是A的时候，其他线程然后改造成了B，但是在修改前又改成了A。解决方案是加上版本号&#x2F;时间戳</li><li>循环开销大：长时间使用CAS自旋来重试知道成功</li><li>只能保证一个共享变量的操作：AtomicReference使用对象进行CAS操作解决问题。</li></ol><h2 id="12-synchronized"><a href="#12-synchronized" class="headerlink" title="12. synchronized"></a>12. synchronized</h2><p>java的关键字，目的是解决多个线程之间访问资源的的同步性，可以保证被它修饰的方法或者代码块任意时刻只有一个线程执行。 使用：</p><ol><li>修饰实例方法（锁示例）</li><li>修饰静态方法（锁当前类）</li><li>修饰代码块（锁指定对象&#x2F;类） 不需要使用synchronized 关键字修饰构造方法，本身就是安全的。</li></ol><h2 id="13-synchronized底层原理"><a href="#13-synchronized底层原理" class="headerlink" title="13. synchronized底层原理"></a>13. synchronized底层原理</h2><p>同步语句块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSynchronized</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span> &#123;<br><span class="hljs-type">TestSynchronized</span> <span class="hljs-variable">testSynchronized</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">TestSynchronized</span>();<br>testSynchronized.method();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;synchronized 代码块&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javap -c -s -v -l TestSynchronized.class<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>descriptor: ()V<br>flags: ACC_PUBLIC<br>Code:<br>stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br><span class="hljs-number">0</span>: aload_0<br><span class="hljs-number">1</span>: dup<br><span class="hljs-number">2</span>: astore_1<br><span class="hljs-number">3</span>: monitorenter<br><span class="hljs-number">4</span>: getstatic     #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="hljs-number">7</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String synchronized 代码块</span><br><span class="hljs-number">9</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="hljs-number">12</span>: aload_1<br><span class="hljs-number">13</span>: monitorexit<br><span class="hljs-number">14</span>: goto          <span class="hljs-number">22</span><br><span class="hljs-number">17</span>: astore_2<br><span class="hljs-number">18</span>: aload_1<br><span class="hljs-number">19</span>: monitorexit<br><span class="hljs-number">20</span>: aload_2<br><span class="hljs-number">21</span>: athrow<br><span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>Exception table:<br>from    to  target type<br><span class="hljs-number">4</span>    <span class="hljs-number">14</span>    <span class="hljs-number">17</span>   any<br><span class="hljs-number">17</span>    <span class="hljs-number">20</span>    <span class="hljs-number">17</span>   any<br>LineNumberTable:<br>line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>line <span class="hljs-number">9</span>: <span class="hljs-number">4</span><br>line <span class="hljs-number">10</span>: <span class="hljs-number">12</span><br>line <span class="hljs-number">11</span>: <span class="hljs-number">22</span><br>LocalVariableTable:<br>Start  Length  Slot  Name   Signature<br><span class="hljs-number">0</span>      <span class="hljs-number">23</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   LTestSynchronized;<br>StackMapTable: number_of_entries = <span class="hljs-number">2</span><br>frame_type = <span class="hljs-number">255</span> <span class="hljs-comment">/* full_frame */</span><br>offset_delta = <span class="hljs-number">17</span><br>locals = [ <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSynchronized</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>/lang/Object ]<br>stack = [ <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>/lang/Throwable ]<br>frame_type = <span class="hljs-number">250</span> <span class="hljs-comment">/* chop */</span><br>offset_delta = <span class="hljs-number">4</span><br>&#125;<br>SourceFile: <span class="hljs-string">&quot;TestSynchronized.java&quot;</span><br></code></pre></td></tr></table></figure><p>开始-&gt;monitorenter-&gt;锁计数器是否为0-&gt;是，锁计数器+1，获取锁成功-&gt;结束<br>开始-&gt;monitorexit-&gt;是否为当前锁的拥有者-&gt;是，锁计数器-1，释放锁-&gt;结束<br>同步语句块使用的是monitorenter（开始位置）和monitorexit（结束位置）<br>但是同步方法使用的是ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。</p><h2 id="14-synchronized-底层优化（1-6）"><a href="#14-synchronized-底层优化（1-6）" class="headerlink" title="14. synchronized 底层优化（1.6）"></a>14. synchronized 底层优化（1.6）</h2><p>加入了自旋锁，适应性自旋锁，锁消除，轻量级锁等待<br>主要四种状态：轻量级锁，重量级锁，无锁状态，偏向锁状态<br>锁可以升级但是不可以降级，主要是提高获得锁和释放锁的效率。</p><h2 id="15-synchronized-和volatile区别"><a href="#15-synchronized-和volatile区别" class="headerlink" title="15. synchronized 和volatile区别"></a>15. synchronized 和volatile区别</h2><ol><li>volatile线程同步的轻量级实现，性能好。</li><li>volatile只能修饰变量，但是synchronized 可以修饰实例，静态，代码块方法</li><li>volatile实现了数据可见性，但是不能保证数据操作原子性。而synchronized 两者都实现。</li><li>volatile实现了多线程之间的可见性，synchronized 多个线程访问资源的同步性</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试题基础-2</title>
    <link href="/post/b4617fdb.html"/>
    <url>/post/b4617fdb.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-List，Set，Queue，Map区别"><a href="#1-List，Set，Queue，Map区别" class="headerlink" title="1. List，Set，Queue，Map区别"></a>1. List，Set，Queue，Map区别</h2><ul><li><p>List: 元素存储是有序的，可以重复的。</p></li><li><p>Set: 元素存储是无序的，不可以重复。</p></li><li><p>Queue：元素存取满足先进先出顺序，元素可重复，有序。</p></li><li><p>Map：key-value键值对，key是不可重复的，无序的，但是value可以重复，无序的</p></li></ul><h2 id="2-ArrayList和LinkedList区别"><a href="#2-ArrayList和LinkedList区别" class="headerlink" title="2. ArrayList和LinkedList区别"></a>2. ArrayList和LinkedList区别</h2><ul><li><p>线程安全：两者都不能保证</p></li><li><p>底层数据结构：ArrayList底层是动态数据，LinkedList底层是双向链表</p></li><li><p>随机访问：ArrayList底层数动态数组，可以根据元素的下标来获取元素对象，实现了RamdomAccess接口（标识），因为内存地址是连续的，而LinedList没有实现接口，无法随机访问。</p></li><li><p>插入删除：</p><ul><li><p>ArrayList底层是动态数组，插入和删除受到元素位置的影响，比如add方法是在尾部插入元素，时间复杂度是O(1)。如果是插入指定位置，时间复杂度是O（n）</p></li><li><p>LinedList是双向链表，无论是插入头部或者尾部，时间复杂度都是O(1),但是指定位置插入时间复杂度是O(n),需要找到插入元素的位置。</p></li></ul></li><li><p>内存空间占用： ArrayList的列表结尾会预留一定的空间，而LinedList空间主要耗费在记录元素的前驱后继和数据</p></li></ul><h2 id="3-ArrayList扩容机制"><a href="#3-ArrayList扩容机制" class="headerlink" title="3. ArrayList扩容机制"></a>3. ArrayList扩容机制</h2><ol><li>添加元素add方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <br>elementData[size++] = e;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>里面调用了ensureCapacityInternal方法</p><ol start="2"><li>ensureCapacityInternal</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>调用了calculateCapacity</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>ensureExplicitCapacity</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br><br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>grow</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br><span class="hljs-comment">// overflow-conscious code</span><br><span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>    newCapacity = minCapacity;<br><span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>    newCapacity = hugeCapacity(minCapacity);<br><span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><p>第一个元素添加进入ArrayList，elementData.length是0，执行了ensureCapacityInternal方法，所以目前的容量minCapacity是10，minCapacity-elementData.length&gt;0 满足条件执行grow方法</p></li><li><p>第二个元素进入，minCapacity&#x3D;2，elementData.length扩容为10，不会执行grow方法。</p></li><li><p>添加第11元素，minCapacity&#x3D;11，满足grow方法，进行扩容，intnewCapacity&#x3D;oldCapacity+(oldCapacity&gt;&gt;1);，扩容为1.5倍数</p></li></ul><h2 id="4-HashSet，LinkedHashSet，TreeSet区别"><a href="#4-HashSet，LinkedHashSet，TreeSet区别" class="headerlink" title="4. HashSet，LinkedHashSet，TreeSet区别"></a>4. HashSet，LinkedHashSet，TreeSet区别</h2><p>底层：都是set的实现方式</p><p>线程安全：都不安全</p><p>数据结构：HashSet底层是哈希表，LinkedHashSet底层是链表，TreeSet底层是红黑树</p><p>应用场景：HashSet适用于不需要保证元素的插入和取出的顺序。LinkedHashSet保证元素的存入和取出满足先进先出的顺序。 TreeSet满足需要进行自定义排序场景</p><h2 id="5-Queue和Deque区别"><a href="#5-Queue和Deque区别" class="headerlink" title="5. Queue和Deque区别"></a>5. Queue和Deque区别</h2><p>Queue：单端队列，满足先进先出，只能从一段插入元素，另一端删除元素。</p><p>Deque：双端队列，队列两端都可以插入删除元素。</p><h2 id="6-ArrayDeque和LinkedList区别"><a href="#6-ArrayDeque和LinkedList区别" class="headerlink" title="6. ArrayDeque和LinkedList区别"></a>6. ArrayDeque和LinkedList区别</h2><p>两者都能实现队列功能</p><p>底层数据结构：ArrayDeque底层是可变数组和指针。LinkedList底层是链表。</p><p>存储null数据：ArrayDeque不可以存储元素为null的。LinkedList可以。</p><p>内存占用：ArrayDeque可能会存在扩容，但是均摊过后时间复杂度为O(1).LinkedList不需要扩容，但是每次插入元素都需要申请新的堆空间，性能相对较慢。</p><h2 id="7-PriorityQueue"><a href="#7-PriorityQueue" class="headerlink" title="7. PriorityQueue"></a>7. PriorityQueue</h2><p>PriorityQueue与Queue的主要区别在于元素的出队顺序，优先级高的元素先出队列。</p><p>PriorityQueue使用二叉树的数据结构实现的，底层是基于可变长的数组来存储数据</p><p>PriorityQueue通过堆元素的上浮和下沉，实现了O(nlogn)时间复杂度插入元素和删除栈顶元素。</p><p>PriorityQueue非线程安全，不支持存储数据为null。</p><p>PriorityQueue默认是小根堆，但是可以接受Comparator构造参数，自定义排列大小。</p><h2 id="8-HashMap底层实现"><a href="#8-HashMap底层实现" class="headerlink" title="8. HashMap底层实现"></a>8. HashMap底层实现</h2><p>1.8 之前</p><p>数组+链表&#x3D;&gt;链表散列。</p><p>数组链表</p><p>HashMap通过key的hashcode，经过扰动函数计算出hash值，然后再进行(n-1)&amp;hash来的带元素元素存储的位置，如果当前位置存在元素，判断该元素的hash以及key是否相同，相同就直接覆盖，不同就采用拉链法解决冲突。</p><p>1.8</p><p>数组+链表+红黑树</p><p>当链表长度大于阈值（8）（将链表转换为红黑树之前会判断当前数组长度是否超过64，没超过就会继续执行扩容）是，会将链表转换为红黑树，减少搜索时间。重点关注treebin()方法</p><p>9ConcurrentHashMap</p><p>1.8 与1.7有很大区别，不再是Segment数组+HashEntry数组+链表，而是采用了Node数组+链表+红黑树。当链表达到一定程度转换为红黑树。   </p><p><img src="img_2.jpg"></p><p>1 初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 如果sizeCtl&lt;0 表示另一个线程执行CAS成功，正在进行初化</span><br>            <br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>            <span class="hljs-comment">// 让出CPU使用权</span><br>            <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过自旋和CAS完成操作</p><p>sizeCtl：</p><p>-1：表示正在初始化</p><p>-N:表示有N-1个线程扩容</p><p>0：初始table大小</p><p>&gt;0: tabl扩容阈值</p><p>2 put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">// 计算key的hash所在位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        <span class="hljs-comment">// f是目标位置元素</span><br>        <span class="hljs-comment">// fh目标位置元素hash值</span><br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 是否初始化</span><br>            tab = initTable();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 使用CAS自旋写入，成功break跳出</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">//链表</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        <span class="hljs-comment">// 红黑树</span><br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                              value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>●通过key计算出hashcode</p><p>●判断是否初始化</p><p>●通过key定位处Node，为空表示可以写入数据，利用CAS尝试写入，失败就自旋保证成功</p><p>●当前位置hashcode&#x3D;&#x3D;MOVED&#x3D;-1,需要扩容</p><p>●不满足,synchronized锁写入数据</p><p>●当数据大于TREEIFY_THRESHOLD执行树化方法，在 treeifyBin 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</p><p>3 get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br><span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br><span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;  (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>        <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>            <span class="hljs-keyword">return</span> e.val;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>            ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>            <span class="hljs-keyword">return</span> e.val;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>根据hash查找位置</p></li><li><p>查找指定位置，如果头节点就是需要找的，返回value</p></li><li><p>头节点hash小于0，表示正在扩容或者红黑数，查找</p></li><li><p>如果是链表，遍历。</p></li></ul><h2 id="10-HashMap和HashTable"><a href="#10-HashMap和HashTable" class="headerlink" title="10. HashMap和HashTable"></a>10. HashMap和HashTable</h2><ol><li><p>线程安全：HashMap线程不安全，HashTable线程安全，里面方法加了Synchronized锁</p></li><li><p>效率：由于HashTable里面加了锁，所以效率不高</p></li><li><p>底层：1.8之后HashMap采用数组+链表+红黑树，而HashTable没有这种结构</p></li><li><p>使用：HashMap常用，HashTable不怎么使用了</p></li><li><p>存值：HashMap可以存储key为null，value为null的值，但是HashTable不允许这样，报异常。</p></li><li><p>初始化：HashMap初始化容量是16，每次扩充都是2倍。HashTable默认是11，扩容是2n+1</p></li></ol><h2 id="11-HashTable和ConcurrentHashMap"><a href="#11-HashTable和ConcurrentHashMap" class="headerlink" title="11. HashTable和ConcurrentHashMap"></a>11. HashTable和ConcurrentHashMap</h2><ol><li><p>底层数据结构：1.8之前ConcurrentHashMap使用的是Segment数组+链表，1.8之后次啊用数组+链表+红黑树。HashTable底层数组+链表</p></li><li><p>实现线程方式：</p><ol><li><p>ConcurrentHasMap 1.8之前采用的Segment数组+链表，对桶数组进行了分割分段，每一把锁里面只锁一部分数据，避免多线程问题。</p></li><li><p>ConcurrentHashMap 1.8后采用Node数组+链表+红黑树，采用CAS自旋和synchronized进行写入数据。</p></li><li><p>HashTable：使用synchronized 来保证安全，因为都是使用的同一把锁，效率低下。</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试题基础-1</title>
    <link href="/post/d37fe596.html"/>
    <url>/post/d37fe596.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-JVM-JDK-JRE"><a href="#1-JVM-JDK-JRE" class="headerlink" title="1. JVM JDK JRE"></a>1. JVM JDK JRE</h2><p>JVM：运行java字节码的虚拟机。保证了可移植性。</p><p>JDK： 包含了所有的java sdk，提供给开发者使用，包含</p><ul><li><ul><li>JRE</li></ul></li><li>javac（编译java源码的编译器）</li><li>javap（反编译）</li><li>jdb（调试器）</li><li>javadoc（文档注释工具）</li><li>……</li></ul><p>JRE:  java运行时环境。</p><ul><li><ul><li>JVM</li></ul></li><li>Class Library（java基础类库）</li></ul><h2 id="2-java的基本数据类型"><a href="#2-java的基本数据类型" class="headerlink" title="2. java的基本数据类型"></a>2. java的基本数据类型</h2><p>数字类型：</p><ul><li><p>整数型</p></li><li><ul><li>byte,short,int,long</li></ul></li><li><p>浮点型</p></li><li><ul><li>double,float</li></ul></li></ul><p>字符型： char</p><p>布尔型：boolean</p><h2 id="3-基本类型和包装类型"><a href="#3-基本类型和包装类型" class="headerlink" title="3. 基本类型和包装类型"></a>3. 基本类型和包装类型</h2><ol><li><strong>用途</strong>:</li></ol><ul><li>包装类型可用于泛型。</li></ul><ol start="2"><li><strong>默认值</strong></li></ol><ul><li>基本数据类型都有自己的默认值</li><li>包装类型默认值时null</li></ul><ol start="3"><li><strong>存储方式</strong></li></ol><ul><li>包装类型属于对象，存放在java虚拟机的堆里面。</li><li>基本类型的局部变量存放在java虚拟机栈的局部变量表，而成员变量（未被statsic修饰）存放在java虚拟机的堆里面。</li></ul><ol start="4"><li><strong>内存空间</strong></li></ol><ul><li>基本数据类型占用内存小</li></ul><ol start="5"><li><strong>比较</strong></li></ol><ul><li>基本类型，&#x3D;&#x3D;表示值的比较</li><li>包装类型，&#x3D;&#x3D;表示内存地址的比较，判断相同使用equals</li></ul><h2 id="4-浮点数精度丢失"><a href="#4-浮点数精度丢失" class="headerlink" title="4. 浮点数精度丢失"></a>4. 浮点数精度丢失</h2><p>计算机底层是二进制的，宽度是有限的，不能表示一些长度位数过长的小数，帮小数的长度唱过一定范围的时候，计算机就会进行截取，导致数据丢失。</p><p>解决方案：BigDecimal</p><h2 id="5-抽象类和接口共同点和区别"><a href="#5-抽象类和接口共同点和区别" class="headerlink" title="5. 抽象类和接口共同点和区别"></a>5. 抽象类和接口共同点和区别</h2><p>共同点：</p><ol><li>都不能被实例化</li><li>都可以包含抽象方法</li></ol><p>不同点</p><ol><li>抽象类主要是代码复用，接口主要是对类的行为约束</li><li>一个类只能修饰一个类，但是可以实现多个接口</li><li>抽象类成员变量，可以子类重新定义赋值，但是接口类成员变量需要使用public static final修饰，不可以改变值，必须要有初始值</li></ol><h2 id="6-浅拷贝和深拷贝"><a href="#6-浅拷贝和深拷贝" class="headerlink" title="6. 浅拷贝和深拷贝"></a>6. 浅拷贝和深拷贝</h2><p>浅拷贝：会在堆上创建一个新对象。如果对象是引用类型，就会直接复制原对象的引用地址。如果不是引用类型，就会创建一个新对象，与原对象互不关联。</p><p>深拷贝：会在堆上创建一个新对象，完全复制原对象。两者不存在关联。</p><p><img src="http://cdn.flycode.icu/img/202307111641259.png"></p><h2 id="7-Object常见方法"><a href="#7-Object常见方法" class="headerlink" title="7. Object常见方法"></a>7. Object常见方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">toString()<br>clone()<br>equals(),hashcode()<br>wait(),wait(<span class="hljs-type">long</span> timeout),wait(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> <span class="hljs-title function_">nano</span><span class="hljs-params">(额外时间)</span>),notify(),notifyAll()<br>finalize()(垃圾回收时触发)<br>getClass()<br></code></pre></td></tr></table></figure><h2 id="8-HashCode-Equals"><a href="#8-HashCode-Equals" class="headerlink" title="8. HashCode Equals"></a>8. HashCode Equals</h2><p>HashCode：返回一个代表对象的哈希码的整数值</p><p>equals： 比较两个内容是否相同</p><p>&#x3D;&#x3D;: 基本类型比较值，引用类型比较内存地址</p><h2 id="9-String-StringBuffer-StringBuilder"><a href="#9-String-StringBuffer-StringBuilder" class="headerlink" title="9. String,StringBuffer,StringBuilder"></a>9. String,StringBuffer,StringBuilder</h2><p>String: 不可变对象，每次修改值都需要重新创建一个新对象,适用于少量数据。</p><p>StringBuilder: 可变对象，线程不安全，适用于单线程，大量数据，效率高。</p><p>StringBuffer: 可变对象，线程安全，适用于多线程，大量数据，效率低。</p><p>String不可变原因，底层使用final关键字修饰，使用字符数组保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">public final class String<br>    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    private final char value[];<br></code></pre></td></tr></table></figure><p>StringBuffer安全的原因，加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">capacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value.length;<br>    &#125;<br>......<br></code></pre></td></tr></table></figure><p>StringBuilder效率高</p><p>StringBuffer源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-literal">null</span>) &#123;<br>        toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(toStringCache, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>StringBuilder源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Create a copy, don&#x27;t share the array</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, <span class="hljs-number">0</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显StringBuilder每次copy，而StringBuffer有自己的缓存，缓存区有数据的时候，就直接读取，很明显优化了部分内容，但是只要数量足够大的时候，StringBuffer的锁不起作用的时候，StringBuilder效率高。</p><h2 id="10-字符串常量池"><a href="#10-字符串常量池" class="headerlink" title="10. 字符串常量池"></a>10. 字符串常量池</h2><p>jvm为了提交性能和减少内存消耗为String类型专门开辟的一块区域，避免字符串的重复创建。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先在堆上创建aa</span><br><span class="hljs-comment">// 然后字符串常量池保存aa引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa&quot;</span>;       <br><span class="hljs-comment">// 返回常量池引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa&quot;</span>;<br>System.out.println(a1 == a2); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>String a1 &#x3D; new String(“aa”);</p><p>1-2个字符串对象</p><ol><li>字符串常量池里面不存在”aa”引用，会先在堆上创建一个”aa”，然后在字符串常量池中保存”aa”引用。</li><li>字符串常量池里面存在”aa”引用，只会在堆上创建一个”aa”字符串对象</li></ol><p>intern作用</p><p>将指定的字符串的引用保存在字符串常量中。有字符串常量池保存了引用则返回引用，否则常量池创建引用，返回。</p><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”Java“</span><br><span class="hljs-comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br><span class="hljs-comment">// 会在堆中在单独创建一个字符串对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s3.intern();<br><span class="hljs-comment">// s1 和 s2 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s2); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// s3 和 s4 指向的是堆中不同的对象</span><br>System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// s1 和 s4 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s4); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="11-什么是反射机制？反射机制的优缺点"><a href="#11-什么是反射机制？反射机制的优缺点" class="headerlink" title="11. 什么是反射机制？反射机制的优缺点"></a>11. 什么是反射机制？反射机制的优缺点</h2><p>反射机制：运行时动态的获取类的内部信息，创建对象以及调用对象的属性和方法的机制。</p><p>优点：</p><ul><li>动态的获取类的内部信息，不需要在编译时就知道对象的内部信息。</li><li>动态的创建对象，不需要在编译时知道对象的类型。</li><li>动态的调用对象的属性以及方法，可以在运行时动态的改变对象的行为</li></ul><p>缺点：</p><ul><li>动态的，效率低</li><li>动态的，不安全，破环java封装。</li></ul><p>应用场景：</p><ul><li>动态代理：使用动态代理可以在运行时动态创建代理对象，不需要在编译的时候知道接口的实现。</li><li>单元测试：Junit单元测试可以使用反射机制在运行时动态的获取类和方法的实现，实现自动化测试。</li><li>配置加载文件：Spring使用反射机制来读取和解析配置文件，实现依赖注入，切面编程。</li><li>个人项目API接口：由于接口是在单独的模块，我不需要知道有哪些接口，我只需要使用反射机制来读取相关接口的信息，然后调用里面的方法。</li></ul><h2 id="12-代理模式"><a href="#12-代理模式" class="headerlink" title="12. 代理模式"></a>12. 代理模式</h2><p>使用代理对象来替代对真实对象的访问，这样可以在不修改对象的原目标的前提下，提供额外的操作，<strong>扩展目标对象的功能</strong>。</p><h3 id="12-1-动态代理"><a href="#12-1-动态代理" class="headerlink" title="12.1. 动态代理"></a>12.1. 动态代理</h3><p>jvm：动态代理是在运行时动态的生成类字节码文件，加载到jvm中去。</p><h4 id="12-1-1-JDK动态代理和CGLIB动态代理机制"><a href="#12-1-1-JDK动态代理和CGLIB动态代理机制" class="headerlink" title="12.1.1. JDK动态代理和CGLIB动态代理机制"></a>12.1.1. JDK动态代理和CGLIB动态代理机制</h4><p>实现方式：JDK动态代理是使用的反射实现的。CGLIB通过继承目标类。</p><p>依赖库：JDK动态代理是通过java自带的库。而CGLIB是依赖cglib库。</p><p>目标类限制：JDK动态代理要求目标类必须要实现接口。</p><p>对象类型：JDK动态代理只能实现接口的类或者直接代理接口，而CGLIB可<strong>以代理未实现任何接口的类。</strong>通过继承实现，生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理final类。</p><p>应用场景</p><p>JDK动态代理：接口代理</p><p>CGLIB动态代理：类代理</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo存在提交github后,xxx.gitHub.io不更新</title>
    <link href="/post/344c3b7c.html"/>
    <url>/post/344c3b7c.html</url>
    
    <content type="html"><![CDATA[<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>hexo clean<br>hexo g -d</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>缓存未及时更新</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/post/4a17b156.html"/>
    <url>/post/4a17b156.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
