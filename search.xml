<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis面试题-2</title>
      <link href="/post/4a61660f.html"/>
      <url>/post/4a61660f.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Redis事务"><a href="#1-Redis事务" class="headerlink" title="1. Redis事务"></a>1. Redis事务</h1><h2 id="1-1-什么是redis事务？"><a href="#1-1-什么是redis事务？" class="headerlink" title="1.1 什么是redis事务？"></a>1.1 什么是redis事务？</h2><p>可以将一个或者多个命令请求打包处理，然后再按顺序执行打包的所有命令，并且不会被中途打断。(不建议使用)</p><h2 id="1-2-如何使用redis事务"><a href="#1-2-如何使用redis事务" class="headerlink" title="1.2 如何使用redis事务"></a>1.2 如何使用redis事务</h2><p>redis可以通过使用multi，exec，discard，watch<br>multi:  输入多个命令放入队列<br>exec:  执行命令<br>discard：取消事务,清空队列里面的命令<br>watch：watch监听指定的key，当被监听的key被修改了，整个事务都不会执行</p><h2 id="1-3Redis事务支持原子性吗？"><a href="#1-3Redis事务支持原子性吗？" class="headerlink" title="1.3Redis事务支持原子性吗？"></a>1.3Redis事务支持原子性吗？</h2><p>事务四大特性：原子性，一致性，隔离性，持久性<br>redis事务只有在运行错误的时候会弹出报错，其他命令都能执行，而且不支持事务回滚，是不满足事务的原子性的。</p><h2 id="1-4-Redis事务支持久化吗？"><a href="#1-4-Redis事务支持久化吗？" class="headerlink" title="1.4 Redis事务支持久化吗？"></a>1.4 Redis事务支持久化吗？</h2><p>Redis持久化方式</p><ol><li>RDB</li><li>AOF</li><li>RDB+AOF</li></ol><p>而AOF相应的持久化策略里面只有appendfsync always能够基本满足要求，但是性能太低，而sec，no两者都会存在数据丢失，没办法保证持久性。</p><h2 id="1-5-Redis事务还有哪些缺陷"><a href="#1-5-Redis事务还有哪些缺陷" class="headerlink" title="1.5 Redis事务还有哪些缺陷"></a>1.5 Redis事务还有哪些缺陷</h2><p>除了原子性，持久性不满足，每条命令都需要与服务器进行交互，浪费资源，不能批量执行</p><h2 id="1-6-如何解决Redis事务的缺陷？"><a href="#1-6-如何解决Redis事务的缺陷？" class="headerlink" title="1.6 如何解决Redis事务的缺陷？"></a>1.6 如何解决Redis事务的缺陷？</h2><p>采用lua脚本，可以一次性执行多个redis命令，减少资源消耗，但是需要保证lua脚本里面的语法都是对的，如果有语法错误，不会有回滚，也是不满足原子性的要求。<br>采用redis functions（比lua脚本更强大）</p><h1 id="2-Redis性能优化"><a href="#2-Redis性能优化" class="headerlink" title="2.Redis性能优化"></a>2.Redis性能优化</h1><h2 id="2-1-使用批量操作减少网络传输"><a href="#2-1-使用批量操作减少网络传输" class="headerlink" title="2.1 使用批量操作减少网络传输"></a>2.1 使用批量操作减少网络传输</h2><h2 id="2-2-大量的key集中过期的问题"><a href="#2-2-大量的key集中过期的问题" class="headerlink" title="2.2 大量的key集中过期的问题"></a>2.2 大量的key集中过期的问题</h2><p>redis一般采取定期删除+惰性删除<br>但是遇到大量的key集中过期，客户端需要等待将这些过期key完全删除才能进行下一步操作，这个任务是在主线程中。</p><h2 id="2-3-Redis-BigKey（了解）"><a href="#2-3-Redis-BigKey（了解）" class="headerlink" title="2.3 Redis BigKey（了解）"></a>2.3 Redis BigKey（了解）</h2><h3 id="2-3-1-什么是BigKey？有什么危害？"><a href="#2-3-1-什么是BigKey？有什么危害？" class="headerlink" title="2.3.1 什么是BigKey？有什么危害？"></a>2.3.1 什么是BigKey？有什么危害？</h3><p>一个key对应的value越大，内存占用越大。bigkek会消耗内存，影响性能。</p><h3 id="2-3-2-如何处理bigkey"><a href="#2-3-2-如何处理bigkey" class="headerlink" title="2.3.2 如何处理bigkey"></a>2.3.2 如何处理bigkey</h3><ol><li>分割bigkey</li><li>手动清理</li><li>采用合适数据结构</li><li>开启lazy_free</li></ol><h1 id="3-Redis内存碎片"><a href="#3-Redis内存碎片" class="headerlink" title="3. Redis内存碎片"></a>3. Redis内存碎片</h1><h2 id="3-1-什么是内存碎片？为什么会有redis内存碎片？"><a href="#3-1-什么是内存碎片？为什么会有redis内存碎片？" class="headerlink" title="3.1 什么是内存碎片？为什么会有redis内存碎片？"></a>3.1 什么是内存碎片？为什么会有redis内存碎片？</h2><p>内存碎片可以看作不可用的闲置空间<br>产生原因：</p><ol><li>Redis存储数据的时候向操作系统申请的内存空间大于实际数据需要的空间</li><li>频繁修改Redis里面数据</li></ol><h1 id="4-Redis生产问题"><a href="#4-Redis生产问题" class="headerlink" title="4. Redis生产问题"></a>4. Redis生产问题</h1><h2 id="4-1-缓存穿透"><a href="#4-1-缓存穿透" class="headerlink" title="4.1 缓存穿透"></a>4.1 缓存穿透</h2><h3 id="4-1-1-什么是缓存穿透？"><a href="#4-1-1-什么是缓存穿透？" class="headerlink" title="4.1.1 什么是缓存穿透？"></a>4.1.1 什么是缓存穿透？</h3><p>大量请求的key是不合理的，既不存在缓存中，也不存在数据库中。导致所有的请求直接到数据库上，没有经过缓存，数据库造成压力</p><h3 id="4-1-2-如何解决"><a href="#4-1-2-如何解决" class="headerlink" title="4.1.2 如何解决"></a>4.1.2 如何解决</h3><ol><li>缓存无效key</li><li>使用布隆过滤器，判断key是否合法</li></ol><h3 id="4-1-3-是什么是布隆过滤器"><a href="#4-1-3-是什么是布隆过滤器" class="headerlink" title="4.1.3 是什么是布隆过滤器"></a>4.1.3 是什么是布隆过滤器</h3><p>添加元素：</p><ol><li>通过哈希函数对元素值进行计算，得到哈希值。</li><li>在位数组对应下标设置为1</li></ol><p>查询元素:</p><ol><li>使用同样方式对key进行哈希计算，得到哈希值</li><li>判断哈希值相应数组下标是否为1，1表示存在，0表示不存在</li></ol><p>会有误判，比如不同的字符串会计算相同的哈希值</p><h2 id="4-2缓存击穿"><a href="#4-2缓存击穿" class="headerlink" title="4.2缓存击穿"></a>4.2缓存击穿</h2><h3 id="4-2-1-什么是缓存击穿？"><a href="#4-2-1-什么是缓存击穿？" class="headerlink" title="4.2.1 什么是缓存击穿？"></a>4.2.1 什么是缓存击穿？</h3><p>请求的key是热点数据，这个数据存在数据库，但是不存在与缓存里面（缓存数据过期），增加数据库压力</p><h3 id="4-2-2-解决方式"><a href="#4-2-2-解决方式" class="headerlink" title="4.2.2 解决方式"></a>4.2.2 解决方式</h3><ol><li>热点数据过期时间长</li><li>缓存预热</li><li>请求数据库写数据到缓存里面之前，先获取互斥锁，保证只有一个请求落到数据库上，减少数据库压力</li></ol><h3 id="4-2-3-缓存击穿和缓存穿透有什么区别？"><a href="#4-2-3-缓存击穿和缓存穿透有什么区别？" class="headerlink" title="4.2.3 缓存击穿和缓存穿透有什么区别？"></a>4.2.3 缓存击穿和缓存穿透有什么区别？</h3><ol><li>缓存击穿里面的key是热点数据，存在数据库，但是不存在于缓存</li><li>缓存穿透，请求的key既不存在数据库也不存在缓存</li></ol><h2 id="4-3-缓存雪崩"><a href="#4-3-缓存雪崩" class="headerlink" title="4.3 缓存雪崩"></a>4.3 缓存雪崩</h2><h3 id="4-3-1-什么是缓存雪崩？"><a href="#4-3-1-什么是缓存雪崩？" class="headerlink" title="4.3.1 什么是缓存雪崩？"></a>4.3.1 什么是缓存雪崩？</h3><p>缓存同一时间大面积失效，导致请求全部落在数据上。</p><h3 id="4-3-2-解决方法"><a href="#4-3-2-解决方法" class="headerlink" title="4.3.2 解决方法"></a>4.3.2 解决方法</h3><p>Redis服务不可用</p><ol><li>搭建集群</li><li>限流</li></ol><p>热点缓存失效</p><ol><li>设置不同的失效时间</li><li>缓存不失效</li><li>二级缓存</li></ol><h2 id="4-4-如何保证缓存数据和数据库数据是一致性的"><a href="#4-4-如何保证缓存数据和数据库数据是一致性的" class="headerlink" title="4.4 如何保证缓存数据和数据库数据是一致性的"></a>4.4 如何保证缓存数据和数据库数据是一致性的</h2><ol><li>旁路缓存模式：更新DB，删除缓存<br>a. 更新数据库成功，缓存删除失败，使用缓存失效时间变短(不推荐)<br>b. 增加cache更新重试机制</li><li>更新缓存，更新数据库</li><li>更新数据库，更新缓存</li><li>删除缓存，更新数据库</li></ol><h1 id="5-Redis集群"><a href="#5-Redis集群" class="headerlink" title="5. Redis集群"></a>5. Redis集群</h1><h2 id="5-1-如何保证redis服务高可用"><a href="#5-1-如何保证redis服务高可用" class="headerlink" title="5.1 如何保证redis服务高可用"></a>5.1 如何保证redis服务高可用</h2><p>Redis sentinel实现redis集群高可用，只是在主从复制实现集群的基础上，多了一个Sentinel角色帮我们监控Redis节点的运行状态，并且实现故障转移。<br>当master节点出现故障的时候，sentinel可以帮我住我们实现故障转移，按照一定规则从salve里面选出升级成为master,确保高可用，不需要人工介入。</p><h2 id="5-2-Sentinel有什么用？"><a href="#5-2-Sentinel有什么用？" class="headerlink" title="5.2 Sentinel有什么用？"></a>5.2 Sentinel有什么用？</h2><ol><li>监控：监控各个节点是否异常（包括自己）</li><li>故障转移：当master出现故障的时候，sentinel能够从salve里面更具相应的规则选出新的master，确保可用性</li><li>通知：通知slave节点新的master信息，使它们全部转移到新的master的slave</li><li>配置提供：客户端连接sentinel请求新的master地址，如果出现故障转移，sentinel会通知新的master节点给客户端</li></ol><h2 id="5-3-Sentinel如何检测节点下线"><a href="#5-3-Sentinel如何检测节点下线" class="headerlink" title="5.3 Sentinel如何检测节点下线"></a>5.3 Sentinel如何检测节点下线</h2><ol><li>主观下线：sentinel认为某个节点已经下线，但是还不确定，需要其他sentinel来确定</li><li>客观下线：多个sentinel节点认为某个redis节点已经下线。</li></ol><h2 id="5-4-Sentinel如何选出新的master节点"><a href="#5-4-Sentinel如何选出新的master节点" class="headerlink" title="5.4 Sentinel如何选出新的master节点"></a>5.4 Sentinel如何选出新的master节点</h2><ol><li>slave优先级</li><li>复制进度：会优先选择出数据和master数据最接近的节点</li><li>运行id</li></ol><h2 id="5-5-Sentinel如何选出Leader"><a href="#5-5-Sentinel如何选出Leader" class="headerlink" title="5.5 Sentinel如何选出Leader"></a>5.5 Sentinel如何选出Leader</h2><p>使用raft算法</p><h2 id="5-6-为什么建议部署多个sentinel节点（哨兵集群）"><a href="#5-6-为什么建议部署多个sentinel节点（哨兵集群）" class="headerlink" title="5.6 为什么建议部署多个sentinel节点（哨兵集群）"></a>5.6 为什么建议部署多个sentinel节点（哨兵集群）</h2><ol><li>多个sentinel可以通过投票的方式判断某个节点受否故障，避免误判</li><li>sentinel本身就是高可用</li></ol><h2 id="5-7-Sentinel可以防止脑裂吗？"><a href="#5-7-Sentinel可以防止脑裂吗？" class="headerlink" title="5.7 Sentinel可以防止脑裂吗？"></a>5.7 Sentinel可以防止脑裂吗？</h2><p>脑裂是指分布式系统里面，不同节点之间通信互相影响，导致数据不同步，出现影响<br>可以，sentinel提供流量控制以及监控</p><h2 id="5-8-Redis缓存的数据量太大怎么办？"><a href="#5-8-Redis缓存的数据量太大怎么办？" class="headerlink" title="5.8 Redis缓存的数据量太大怎么办？"></a>5.8 Redis缓存的数据量太大怎么办？</h2><p>采用Redis Cluster</p><h2 id="5-9-为什么要使用Redis-Cluster？"><a href="#5-9-为什么要使用Redis-Cluster？" class="headerlink" title="5.9 为什么要使用Redis Cluster？"></a>5.9 为什么要使用Redis Cluster？</h2><ol><li>缓存的数据量太大</li><li>并发量要求太大</li></ol><h2 id="5-10-Redis-Cluster虚拟槽分区有什么优点？"><a href="#5-10-Redis-Cluster虚拟槽分区有什么优点？" class="headerlink" title="5.10 Redis Cluster虚拟槽分区有什么优点？"></a>5.10 Redis Cluster虚拟槽分区有什么优点？</h2><ol><li>解耦了数据和节点之间的关系</li><li>提升了集群的横向扩展和容错性</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法通关村第一关——链表经典问题之删除链表元素笔记</title>
      <link href="/post/64cd7498.html"/>
      <url>/post/64cd7498.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-题目-：移除链表元素"><a href="#1-题目-：移除链表元素" class="headerlink" title="1. 题目 ：移除链表元素"></a>1. 题目 ：移除链表元素</h1><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。<br><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣</a></p><h2 id="1-2-分析"><a href="#1-2-分析" class="headerlink" title="1.2 分析"></a>1.2 分析</h2><h3 id="1-2-1-这里没啥好分析的，就是查找是否相同的节点元素，但是需要注意要保存前一个节点的位置，然后和删除节点的后一个位置建立联系。"><a href="#1-2-1-这里没啥好分析的，就是查找是否相同的节点元素，但是需要注意要保存前一个节点的位置，然后和删除节点的后一个位置建立联系。" class="headerlink" title="1.2.1 这里没啥好分析的，就是查找是否相同的节点元素，但是需要注意要保存前一个节点的位置，然后和删除节点的后一个位置建立联系。"></a>1.2.1 这里没啥好分析的，就是查找是否相同的节点元素，但是需要注意要保存前一个节点的位置，然后和删除节点的后一个位置建立联系。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        res.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> res;<br>        <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cur.next.val == val)&#123;<br>                cur.next = cur.next.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur =cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbsclb-1.png" alt="img.png"><br>时间复杂度：O(n) 遍历了一次链表<br>空间复杂度:  O(1)</p><h1 id="2-题目：删除链表的倒数第-N-个结点"><a href="#2-题目：删除链表的倒数第-N-个结点" class="headerlink" title="2. 题目：删除链表的倒数第 N 个结点"></a>2. 题目：删除链表的倒数第 N 个结点</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣</a></p><h2 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h2><h3 id="2-1-1-使用快慢指针，倒数第n的节点，就保持快慢指针之间相差n个节点，当快指针的next走到null的时候，这时候就是删除节点的前一个节点位置，然后指向删除节点的后一个节点。"><a href="#2-1-1-使用快慢指针，倒数第n的节点，就保持快慢指针之间相差n个节点，当快指针的next走到null的时候，这时候就是删除节点的前一个节点位置，然后指向删除节点的后一个节点。" class="headerlink" title="2.1.1 使用快慢指针，倒数第n的节点，就保持快慢指针之间相差n个节点，当快指针的next走到null的时候，这时候就是删除节点的前一个节点位置，然后指向删除节点的后一个节点。"></a>2.1.1 使用快慢指针，倒数第n的节点，就保持快慢指针之间相差n个节点，当快指针的next走到null的时候，这时候就是删除节点的前一个节点位置，然后指向删除节点的后一个节点。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-comment">// 快指针先走n步</span><br>       <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>           fast = fast.next;<br>           n--;<br>       &#125;<br>       <span class="hljs-comment">// 防止是头节点</span><br>       <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> head.next;<br>       &#125;<br>       <span class="hljs-comment">// 同时移动</span><br>       <span class="hljs-keyword">while</span>(fast.next!=<span class="hljs-literal">null</span>)&#123;<br>           slow = slow.next;<br>           fast = fast.next;<br>       &#125;<br>       <span class="hljs-comment">// 删除元素</span><br>       slow.next = slow.next.next;<br>       <span class="hljs-keyword">return</span> head;<br>   &#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="/images/lbsclb-2.png" alt="img.png"><br>时间复杂度：O(n)遍历一次链表<br>空间复杂度：O(1)</p><p>总结：看一看见快慢指针速度还是可以的，不过尤其需要注意里面需要判断快指针是否为空的情况，这个时候意味着删除的就是头节点。</p><h2 id="2-1-2-使用链表长度，通过正向找到节点的前一个节点的位置，然后指向删除节点的后一个节点。"><a href="#2-1-2-使用链表长度，通过正向找到节点的前一个节点的位置，然后指向删除节点的后一个节点。" class="headerlink" title="2.1.2 使用链表长度，通过正向找到节点的前一个节点的位置，然后指向删除节点的后一个节点。"></a>2.1.2 使用链表长度，通过正向找到节点的前一个节点的位置，然后指向删除节点的后一个节点。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">sentail</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>   sentail.next = head;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span>head;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> sentail;<br>    <span class="hljs-comment">// 计算长度</span><br>   <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(currentNode!=<span class="hljs-literal">null</span>)&#123;<br>    currentNode = currentNode.next;<br>    length++;<br>   &#125;<br><span class="hljs-comment">// 移动第length-n-1元素位置</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length-n;i++)&#123;<br>      temp = temp.next;<br>   &#125;<br>    <span class="hljs-comment">// 删除</span><br>   temp.next = temp.next.next;<br> <span class="hljs-keyword">return</span> sentail.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="/images/lbsclb-3.png" alt="img.png"><br>时间复杂度: O(n) 第一次遍历链表 O(n)第二次遍历部分链表O(k)k表示删除节点元素的位置，总体是O(n)<br>空间复杂度: O(1)</p><p>总结：我没想到的是内存消耗比快慢指针的还要小。</p><h1 id="3-删除排序链表中的重复元素"><a href="#3-删除排序链表中的重复元素" class="headerlink" title="3. 删除排序链表中的重复元素"></a>3. 删除排序链表中的重复元素</h1><h2 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h2><h3 id="3-1-1-先定位到当前节点，判断前后节点的值是否一样，一样就跳过第二个节点，否则正常向后遍历"><a href="#3-1-1-先定位到当前节点，判断前后节点的值是否一样，一样就跳过第二个节点，否则正常向后遍历" class="headerlink" title="3.1.1 先定位到当前节点，判断前后节点的值是否一样，一样就跳过第二个节点，否则正常向后遍历"></a>3.1.1 先定位到当前节点，判断前后节点的值是否一样，一样就跳过第二个节点，否则正常向后遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(currentNode.next!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(currentNode.val == currentNode.next.val)&#123;<br>                currentNode.next = currentNode.next.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                currentNode = currentNode.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="https://img-blog.csdnimg.cn/9b64d259d805433390fc44f4df316309.png" alt="在这里插入图片描述"><br>时间复杂度：O(n)<br>空间复杂度:  O(1)</p><p>总结：每次执行这种需要下一个节点的，记住需要判断头节点是否为空</p><h1 id="4-删除排序链表中的重复元素-II"><a href="#4-删除排序链表中的重复元素-II" class="headerlink" title="4. 删除排序链表中的重复元素 II"></a>4. 删除排序链表中的重复元素 II</h1><p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。<br><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">力扣</a></p><h2 id="4-1-分析"><a href="#4-1-分析" class="headerlink" title="4.1 分析"></a>4.1 分析</h2><h3 id="4-1-1-发现这一题和上面的题目一样，但是i这一题不需要重复数据而是都删除。"><a href="#4-1-1-发现这一题和上面的题目一样，但是i这一题不需要重复数据而是都删除。" class="headerlink" title="4.1.1 发现这一题和上面的题目一样，但是i这一题不需要重复数据而是都删除。"></a>4.1.1 发现这一题和上面的题目一样，但是i这一题不需要重复数据而是都删除。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">sentail</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>      sentail.next = head;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> sentail;<br>      <span class="hljs-comment">// 下一个节点和下下一个节点都不为空</span><br>      <span class="hljs-keyword">while</span>(current.next!=<span class="hljs-literal">null</span> &amp;&amp; current.next.next !=<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-comment">// 判断下个节点和下下节点是否值一致</span><br>          <span class="hljs-keyword">if</span>(current.next.val == current.next.next.val)&#123;<br>              <span class="hljs-comment">// 保存相同的值</span><br>              <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span>current.next.val;<br>              <span class="hljs-comment">// 当前节点的下一个值不为空，值等于x，跳过当前节点</span><br>              <span class="hljs-keyword">while</span>(current.next!=<span class="hljs-literal">null</span> &amp;&amp; current.next.val == x)&#123;<br>                  current.next = current.next.next;<br>              &#125;<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>              current = current.next;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> sentail.next;<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbsclb-4.png" alt="img.png"><br>时间复杂度：O(n)<br>空间复杂度：O(n)</p><p>总结：原本以为很贱的，但是实际操作发现中间有些步骤还是有点难以考虑到，比如需要记录下下一个节点和下下节点的共同值，然后判断当前的下一个节点是否是这个共同值，是的话就跳过，比第三题多了一点限制条件，一开始不理解为什么要先记录共同值，现在了解了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>删除链表节点这一块核心是需要找到当前删除节点的前后关系的节点，后两题目也是差不多意思，只不过第四题需要先将值先保存，判断下一个和下下一个节点关系。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法通关村第一关——链表经典问题之双指针笔记</title>
      <link href="/post/e035491a.html"/>
      <url>/post/e035491a.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-题目：链表的中间结点"><a href="#1-题目：链表的中间结点" class="headerlink" title="1. 题目：链表的中间结点"></a>1. 题目：链表的中间结点</h1><p>给你单链表的头结点 head ，请你找出并返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。<br><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">力扣</a></p><h2 id="1-1-分析"><a href="#1-1-分析" class="headerlink" title="1.1 分析"></a>1.1 分析</h2><h3 id="1-1-1-第一想法，使用计数器先统计处所有长度，然后再来个计数器让指针移动到中间位置时停止，此时就可以获取中间链表了。"><a href="#1-1-1-第一想法，使用计数器先统计处所有长度，然后再来个计数器让指针移动到中间位置时停止，此时就可以获取中间链表了。" class="headerlink" title="1.1.1 第一想法，使用计数器先统计处所有长度，然后再来个计数器让指针移动到中间位置时停止，此时就可以获取中间链表了。"></a>1.1.1 第一想法，使用计数器先统计处所有长度，然后再来个计数器让指针移动到中间位置时停止，此时就可以获取中间链表了。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(current!=<span class="hljs-literal">null</span>)  &#123;<br>           current = current.next;<br>           length++;<br>       &#125;   <br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(count &lt; length/<span class="hljs-number">2</span>)&#123;<br>           head=head.next;<br>           count++;<br>       &#125;<br>       <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbszz-1.png" alt="img.png"><br>时间复杂度：O(n)里面两次遍历使用计数器<br>空间复杂度:  O(1)</p><p>总结：思路还是很清晰的，使用两个计数器</p><h3 id="1-1-2-很显然，这个专题是双指针，肯定是双指针来的快，那么就要思考如何使用双指针，我可以定义一个快慢指针，快指针走两个，慢指针走一个，最后快指针结束了，那么中间节点位置就是慢指针的位置"><a href="#1-1-2-很显然，这个专题是双指针，肯定是双指针来的快，那么就要思考如何使用双指针，我可以定义一个快慢指针，快指针走两个，慢指针走一个，最后快指针结束了，那么中间节点位置就是慢指针的位置" class="headerlink" title="1.1.2 很显然，这个专题是双指针，肯定是双指针来的快，那么就要思考如何使用双指针，我可以定义一个快慢指针，快指针走两个，慢指针走一个，最后快指针结束了，那么中间节点位置就是慢指针的位置"></a>1.1.2 很显然，这个专题是双指针，肯定是双指针来的快，那么就要思考如何使用双指针，我可以定义一个快慢指针，快指针走两个，慢指针走一个，最后快指针结束了，那么中间节点位置就是慢指针的位置</h3><p><img src="/images/lbszz-2.png" alt="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span>head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.next!=<span class="hljs-literal">null</span>)&#123;<br>        slow=slow.next;<br>        fast=fast.next.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>   &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbszz-3.png" alt="img.png"><br>时间复杂度：O(n)，遍历一次链表<br>空间复杂度: O(1)</p><p>总结：很明显，快慢指针时间空间上性能都很高，这里不需要考虑是否慢指针需要因为奇数偶数而再向后移动，因为条件里面的快指针就是条件，只要满足，最后慢指针就是结果</p><h1 id="2-题目：-链表中倒数第k个节点"><a href="#2-题目：-链表中倒数第k个节点" class="headerlink" title="2. 题目： 链表中倒数第k个节点"></a>2. 题目： 链表中倒数第k个节点</h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。<br>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。<br><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">力扣</a></p><h2 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h2><h3 id="2-1-1-采用快慢指针，先让快指针走k步，让快慢指针里面相差k步，然后两个指针同时走，直到快指针为null，那么慢指针就走到了倒数第k个节点，那么这个节点就是需要的节点。"><a href="#2-1-1-采用快慢指针，先让快指针走k步，让快慢指针里面相差k步，然后两个指针同时走，直到快指针为null，那么慢指针就走到了倒数第k个节点，那么这个节点就是需要的节点。" class="headerlink" title="2.1.1 采用快慢指针，先让快指针走k步，让快慢指针里面相差k步，然后两个指针同时走，直到快指针为null，那么慢指针就走到了倒数第k个节点，那么这个节点就是需要的节点。"></a>2.1.1 采用快慢指针，先让快指针走k步，让快慢指针里面相差k步，然后两个指针同时走，直到快指针为null，那么慢指针就走到了倒数第k个节点，那么这个节点就是需要的节点。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span>head;<br>        <span class="hljs-comment">// 快指针走k步，与慢指针相差k</span><br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; k&gt;<span class="hljs-number">0</span>)&#123;<br>            fast=fast.next;<br>            k--;<br>        &#125;<br>        <span class="hljs-comment">// 慢指针开始移动，快指针也继续移动</span><br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>)&#123;<br>            slow=slow.next;<br>            fast=fast.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图：<br><img src="/images/lbszz-4.png" alt="img.png"><br>时间复杂度：O(n),遍历一次链表<br>空间复杂度:  O(1)</p><p>总结：当有这种k个距离的时候，采用快慢指针，速度一般是很快的，一开始想法是将链表反转，然后通过k元素的位置节点，然后再反转一次就是所求结果，但是很显然较为复杂，还是需要好好掌握快慢指针。</p><h1 id="2-旋转链表"><a href="#2-旋转链表" class="headerlink" title="2. 旋转链表"></a>2. 旋转链表</h1><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。<br><a href="https://leetcode.cn/problems/rotate-list/">力扣</a></p><h2 id="2-2-分析"><a href="#2-2-分析" class="headerlink" title="2.2 分析"></a>2.2 分析</h2><h3 id="2-2-1-使用快慢指针找到k的位置，不过先要判断一下k是否为空和节点是否存在，还要判断当前链表长度和k的大小，这里采用取余，因为k可能超过链表长度，如果取余后结果为0，意味着不需要移动，但是如果取余大于0，快指针就需要移动一格直到k为0，然后快慢指针一起移动，等快指针为null的时候，k就在慢指针的位置，然后将快指针的next指向链表的头部，然后慢指针后面断开。"><a href="#2-2-1-使用快慢指针找到k的位置，不过先要判断一下k是否为空和节点是否存在，还要判断当前链表长度和k的大小，这里采用取余，因为k可能超过链表长度，如果取余后结果为0，意味着不需要移动，但是如果取余大于0，快指针就需要移动一格直到k为0，然后快慢指针一起移动，等快指针为null的时候，k就在慢指针的位置，然后将快指针的next指向链表的头部，然后慢指针后面断开。" class="headerlink" title="2.2.1 使用快慢指针找到k的位置，不过先要判断一下k是否为空和节点是否存在，还要判断当前链表长度和k的大小，这里采用取余，因为k可能超过链表长度，如果取余后结果为0，意味着不需要移动，但是如果取余大于0，快指针就需要移动一格直到k为0，然后快慢指针一起移动，等快指针为null的时候，k就在慢指针的位置，然后将快指针的next指向链表的头部，然后慢指针后面断开。"></a>2.2.1 使用快慢指针找到k的位置，不过先要判断一下k是否为空和节点是否存在，还要判断当前链表长度和k的大小，这里采用取余，因为k可能超过链表长度，如果取余后结果为0，意味着不需要移动，但是如果取余大于0，快指针就需要移动一格直到k为0，然后快慢指针一起移动，等快指针为null的时候，k就在慢指针的位置，然后将快指针的next指向链表的头部，然后慢指针后面断开。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || k == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算链表长度</span><br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span>)&#123;<br>            len++;<br>            head=head.next;<br>        &#125;<br>        <span class="hljs-comment">// 当k就是链表的长度</span><br>        <span class="hljs-keyword">if</span>(k%len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(k%len &gt;<span class="hljs-number">0</span>)&#123;<br>            fast=fast.next;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast.next!=<span class="hljs-literal">null</span>)&#123;<br>            fast=fast.next;<br>            slow=slow.next;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> slow.next;<br>        slow.next = <span class="hljs-literal">null</span>;<br>        fast.next = temp;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/images/lbszz-5.png" alt="img.png"><br>时间复杂度： O(n)链表长度<br>空间复杂度:   O(1)</p><p>总结：需要注意的是一些临界值，比如k是否为0，或者取余是0，因为k不一定就是链表的长度以内。</p><h2 id="2-2-2-看到这个题目初始印象就是先分割链表，然后就是合并链表，但是实际写下来发现和上面快慢指针差不多，也是先找到位置分割，然后将第二个链表的最后一个指向原链表的头部，还是不如双指针简单。"><a href="#2-2-2-看到这个题目初始印象就是先分割链表，然后就是合并链表，但是实际写下来发现和上面快慢指针差不多，也是先找到位置分割，然后将第二个链表的最后一个指向原链表的头部，还是不如双指针简单。" class="headerlink" title="2.2.2 看到这个题目初始印象就是先分割链表，然后就是合并链表，但是实际写下来发现和上面快慢指针差不多，也是先找到位置分割，然后将第二个链表的最后一个指向原链表的头部，还是不如双指针简单。"></a>2.2.2 看到这个题目初始印象就是先分割链表，然后就是合并链表，但是实际写下来发现和上面快慢指针差不多，也是先找到位置分割，然后将第二个链表的最后一个指向原链表的头部，还是不如双指针简单。</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于这种题目说了第k的元素之类，优先考虑一下双指针。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题-1</title>
      <link href="/post/d36837b5.html"/>
      <url>/post/d36837b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么要用redis做缓存"><a href="#1-为什么要用redis做缓存" class="headerlink" title="1. 为什么要用redis做缓存"></a>1. 为什么要用redis做缓存</h1><ol><li>高性能：缓存获取数据</li><li>高并发：部分请求到缓存而不是数据库</li></ol><h1 id="2-Redis除了做缓存还能做什么"><a href="#2-Redis除了做缓存还能做什么" class="headerlink" title="2. Redis除了做缓存还能做什么"></a>2. Redis除了做缓存还能做什么</h1><ol><li>分布式锁</li><li>限流</li><li>消息队列</li><li>分布式session</li><li>延时队列</li></ol><h1 id="3-分布式缓存常见方案"><a href="#3-分布式缓存常见方案" class="headerlink" title="3. 分布式缓存常见方案"></a>3. 分布式缓存常见方案</h1><p>Memcached和redis<br>区别：</p><ol><li>redis提供更加丰富的数据类型</li><li>redis支持持久化，内存的数据结构存放在硬盘中，重启时候加载使用，mamcached数据存放内存</li><li>redis灾难恢复机制</li><li>redis服务器内存使用完了，可以将不用的数据放在磁盘上，memcached会报异常</li><li>redis支持集群，memcached没有原生集群</li><li>redis单线程多路复用，memcached多线程，非阻塞Io</li><li>redis支持发布订阅，lua脚本，事务等等</li></ol><h1 id="4-Redis常见的数据结构"><a href="#4-Redis常见的数据结构" class="headerlink" title="4. Redis常见的数据结构"></a>4. Redis常见的数据结构</h1><p>5种基础数据类型：String,List,Set,Hash,ZSet<br>3种特殊数据结构：HyperLogLogs（基数统计）Bitmap （位存储） Geospatial （地理位置）</p><h1 id="5-RDB"><a href="#5-RDB" class="headerlink" title="5. RDB"></a>5. RDB</h1><h2 id="5-1-什么是RDB持久化"><a href="#5-1-什么是RDB持久化" class="headerlink" title="5.1 什么是RDB持久化"></a>5.1 什么是RDB持久化</h2><p>Redis可以通过创建快照来获取存储在内存里面某个数据某个时间点上的副本。<br>Redis创建快照之后，可以对快照进行备份，可以复制到其他服务器创建具有相同数据的服务器副本。<br>快照持久化是 Redis 默认采用的持久化方式。</p><h1 id="5-2-RDB创建快照会阻塞主线程吗？"><a href="#5-2-RDB创建快照会阻塞主线程吗？" class="headerlink" title="5.2 RDB创建快照会阻塞主线程吗？"></a>5.2 RDB创建快照会阻塞主线程吗？</h1><p>dis提供两个方法</p><ul><li>save: 同步进行，会阻塞</li><li>bgsave：会fork创建一个子线程，子线程执行，不会阻塞，默认</li></ul><h1 id="6-AOF"><a href="#6-AOF" class="headerlink" title="6. AOF"></a>6. AOF</h1><h2 id="6-1-什么是AOF持久化"><a href="#6-1-什么是AOF持久化" class="headerlink" title="6.1 什么是AOF持久化"></a>6.1 什么是AOF持久化</h2><p>实时性比RDB好，开启AOF持久化每次执行一条会更改redis里面数据的命令,都会将该命令写入AOF缓冲区，然后再写入AOF文件（此时还在系统内核缓存区未同步到磁盘），最后根据持久化方式(fsync策略)配置来决定何时将系统内核缓存区的数据同步到硬盘中去</p><h2 id="6-2-AOF工作流程"><a href="#6-2-AOF工作流程" class="headerlink" title="6.2 AOF工作流程"></a>6.2 AOF工作流程</h2><ol><li>命令追加：将所有的写命令都写入AOF缓冲区</li><li>文件写入：将AOF缓冲区数据写入AOF文件（此时未将数据同步到硬盘）</li><li>文件同步：根据相应的持久化方式决定何时将内核里面的缓冲区数据同步到硬盘。</li><li>文件重写：AOF数据量大了之后，需要定期重写，达到压缩目的。</li><li>文件重载：当redis重启，加载AOF文件数据恢复</li></ol><h2 id="6-3-AOF持久化方式策略"><a href="#6-3-AOF持久化方式策略" class="headerlink" title="6.3 AOF持久化方式策略"></a>6.3 AOF持久化方式策略</h2><ol><li>appendfsync always：主进程调用write后，后台线程会立即调用AOF文件同步，完成后返回，（消耗性能）</li><li>appendfsync everysec：每秒钟调用 fsync 函数（系统调用）同步一次 AOF 文件</li><li>appendfsync no： 操作系统自己决定何时调用同步AOF文件</li></ol><h2 id="6-4-AOF为什么执行完命令后记录日志"><a href="#6-4-AOF为什么执行完命令后记录日志" class="headerlink" title="6.4 AOF为什么执行完命令后记录日志"></a>6.4 AOF为什么执行完命令后记录日志</h2><ol><li>节省开销，避免对语法进行检查</li><li>避免阻塞当前命令执行的线程</li></ol><p>缺点:</p><ol><li>刚执行完redis命令，redis就宕机了会导致数据丢失</li><li>阻塞后续其他命令的执行。</li></ol><h2 id="6-5-AOF重写了解吗"><a href="#6-5-AOF重写了解吗" class="headerlink" title="6.5 AOF重写了解吗"></a>6.5 AOF重写了解吗</h2><p>当AOF变得太大的时候，Redis会在后台自动重写产生一个新的ROF文件，这个AOF文件和原有的AOF文件保存的数据状态一样，但是体积更小。</p><h2 id="6-6-AOF校验校验机制了解吗"><a href="#6-6-AOF校验校验机制了解吗" class="headerlink" title="6.6 AOF校验校验机制了解吗"></a>6.6 AOF校验校验机制了解吗</h2><p>Redis启动时会对AOF文件文件检查，判断文件是否完整，是否损坏丢失数据。<br>主要是通过校验和（对整个 AOF 文件内容进行 CRC64 算法计算得出的数字）验证，如果文件发生改变，这个也会改变，会判断校验和和AOF文件末尾的校验和是否一致。</p><h2 id="6-7-如何选择RDB和AOF"><a href="#6-7-如何选择RDB和AOF" class="headerlink" title="6.7 如何选择RDB和AOF"></a>6.7 如何选择RDB和AOF</h2><p>RDB优点：</p><ol><li>存储的是经过压缩的二进制文件，文件占用小，适合数据备份，灾难恢复。AOF存储每一次的写命令，文件大</li><li>RBD恢复文件，只需要解析还原数据即可，不需要一条一条执行命令，速度快。AOF依赖每次的执行命令，速度慢。</li></ol><p>AOF优点：</p><ol><li>安全性好，实时持久化数据。RDB文件生成过程比较繁重，而AOF是直接追加到AOF文件里面去。</li><li>AOF易于理解和解析所有的日志。</li></ol><h1 id="7-Redis线程模型"><a href="#7-Redis线程模型" class="headerlink" title="7. Redis线程模型"></a>7. Redis线程模型</h1><h2 id="7-1-Redis单线程模型-单线程怎么监听大量客户的连接"><a href="#7-1-Redis单线程模型-单线程怎么监听大量客户的连接" class="headerlink" title="7.1 Redis单线程模型&#x2F;单线程怎么监听大量客户的连接"></a>7.1 Redis单线程模型&#x2F;单线程怎么监听大量客户的连接</h2><p>redis通过IO多路复用程序来见监听来自客户端的大量连接<br>好处是不需要创建多个线程监听大量用户，降低资源消耗</p><h2 id="7-2-Redis-6之前为什么不使用多线程"><a href="#7-2-Redis-6之前为什么不使用多线程" class="headerlink" title="7.2 Redis 6之前为什么不使用多线程"></a>7.2 Redis 6之前为什么不使用多线程</h2><ol><li>单线程管理容易维护。</li><li>redis性能主要在于内存和网络</li><li>多线程存在死锁，影响性能</li></ol><h2 id="7-3-Redis-6之后为什么引入多线程"><a href="#7-3-Redis-6之后为什么引入多线程" class="headerlink" title="7.3 Redis 6之后为什么引入多线程"></a>7.3 Redis 6之后为什么引入多线程</h2><p>提高网络IO读写性能</p><h1 id="8-Redis内存管理"><a href="#8-Redis内存管理" class="headerlink" title="8. Redis内存管理"></a>8. Redis内存管理</h1><h2 id="8-1-Redis给缓存数据设置过期时间的作用？"><a href="#8-1-Redis给缓存数据设置过期时间的作用？" class="headerlink" title="8.1 Redis给缓存数据设置过期时间的作用？"></a>8.1 Redis给缓存数据设置过期时间的作用？</h2><p>内存是有限的，不能缓存数据不能一直存在</p><h2 id="8-2-Redis如何判断数据是否过期"><a href="#8-2-Redis如何判断数据是否过期" class="headerlink" title="8.2 Redis如何判断数据是否过期"></a>8.2 Redis如何判断数据是否过期</h2><p>过期字典保存过期时间</p><h2 id="8-3-过期数据的删除策略方式"><a href="#8-3-过期数据的删除策略方式" class="headerlink" title="8.3 过期数据的删除策略方式"></a>8.3 过期数据的删除策略方式</h2><ol><li>惰性删除：只有取出Key的时候进行过期判断</li><li>定时删除： 每过一段时间取出过期的key删除。</li></ol><h2 id="8-4-Redis内存淘汰机制（8种）"><a href="#8-4-Redis内存淘汰机制（8种）" class="headerlink" title="8.4 Redis内存淘汰机制（8种）"></a>8.4 Redis内存淘汰机制（8种）</h2><p>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p><ol><li>volatile-lru： 从已设置过期时间的数据集中种挑选最少使用的淘汰</li><li>volatile-ttl： 从已设置过期时间的数据集中挑选要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集中任意挑选数据淘汰</li><li>allkeys-lru：内存不足以写入新数据，淘汰最少使用的（常用）</li><li>allkeys-random：从数据集中任选数据淘汰。</li><li>no-eviction：内存不足时不允许写入</li><li>volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰</li><li>allkeys-lfu：内存不足以写入新数据，移除补偿使用的key</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法通关村第一关——链表经典问题之合并有序链表笔记</title>
      <link href="/post/3f07837f.html"/>
      <url>/post/3f07837f.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-题目：合并两个有序链表"><a href="#1-题目：合并两个有序链表" class="headerlink" title="1. 题目：合并两个有序链表"></a>1. 题目：合并两个有序链表</h1><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><a href="https://leetcode.cn/problems/merge-two-sorted-lists/submissions/">力扣</a></p><h2 id="1-2-分析"><a href="#1-2-分析" class="headerlink" title="1.2. 分析"></a>1.2. 分析</h2><h3 id="1-2-1-初始想法，直接采用一个新的链表存储两个链表元素，只需要比较两个链表的元素大小，然后改变新链表的指针。"><a href="#1-2-1-初始想法，直接采用一个新的链表存储两个链表元素，只需要比较两个链表的元素大小，然后改变新链表的指针。" class="headerlink" title="1.2.1 初始想法，直接采用一个新的链表存储两个链表元素，只需要比较两个链表的元素大小，然后改变新链表的指针。"></a>1.2.1 初始想法，直接采用一个新的链表存储两个链表元素，只需要比较两个链表的元素大小，然后改变新链表的指针。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">newListNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>       <span class="hljs-comment">// 哨兵节点</span><br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentNewNode</span> <span class="hljs-operator">=</span> newListNode;<br>       <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">// list1的值小</span><br>           <span class="hljs-keyword">if</span> (list1.value &lt;= list2.value) &#123;<br>               currentNewNode.next = list1;<br>               currentNewNode = list1;<br>               list1 = list1.next;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list1.value &gt; list2.value) &#123;<br>               <span class="hljs-comment">// list2的值小</span><br>               currentNewNode.next = list2;<br>               currentNewNode = list2;<br>               list2 = list2.next;<br>           &#125;<br>       &#125;<br><span class="hljs-comment">// 两者有一个为空</span><br>       currentNewNode.next = (list1 == <span class="hljs-literal">null</span>) ? list2 : list1;<br>       <span class="hljs-keyword">return</span> newListNode.next;<br>   &#125;<br></code></pre></td></tr></table></figure><p>这里面需要注意的是返回的头节点的下一个节点，因为头节点是作为哨兵节点的，没有实际意义。</p><p>运行截图<br><img src="/images/lbhb-1.png" alt="img.png"><br>时间复杂度：O(n),两个链表的节点总数<br>空间复杂度:  O(1)</p><p>以上代码还能再简单一些，  就是里面的每次新的节点都需要移动到新的链表的位置，list1和list2的移动都是一样的，没必要单独写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// list1的值小</span><br>          <span class="hljs-keyword">if</span> (list1.value &lt;= list2.value) &#123;<br>              currentNewNode.next = list1;<br>              list1 = list1.next;<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list1.value &gt; list2.value) &#123;<br>              <span class="hljs-comment">// list2的值小</span><br>              currentNewNode.next = list2;<br>              list2 = list2.next;<br>          &#125;<br>          currentNewNode = currentNewNode.next;<br>      &#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-2-递归写法，只需要比较头节点的元素大小，然后将其中小的元素就作为新链表的节点，然后比较下面的其他元素，最后返回的链表就是已经排序好的链表。"><a href="#1-2-2-递归写法，只需要比较头节点的元素大小，然后将其中小的元素就作为新链表的节点，然后比较下面的其他元素，最后返回的链表就是已经排序好的链表。" class="headerlink" title="1.2.2 递归写法，只需要比较头节点的元素大小，然后将其中小的元素就作为新链表的节点，然后比较下面的其他元素，最后返回的链表就是已经排序好的链表。"></a>1.2.2 递归写法，只需要比较头节点的元素大小，然后将其中小的元素就作为新链表的节点，然后比较下面的其他元素，最后返回的链表就是已经排序好的链表。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-keyword">if</span> (list1.value &lt;= list2.value) &#123;<br>            list1.next = mergeTwoLists(list1.next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            list2.next = mergeTwoLists(list2.next, list1);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>递归还是比较容易看懂的，一定需要注意递归判断条件是否为空，不然出不来递归。</p><p>运行截图<br><img src="/images/lbhb-2.png" alt="img.png"></p><p>时间复杂度：O(n)链表长度<br>空间复杂度:  O(n) 链表长度</p><p>递归主要是涉及到递归层数和这个空间，速度肯定是不如第一种方法快的。</p><h1 id="2-合并K个链表"><a href="#2-合并K个链表" class="headerlink" title="2. 合并K个链表"></a>2. 合并K个链表</h1><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>地址：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/submissions/">力扣</a></p><h2 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h2><p>比如栈等等都能合并链表，建议先将两个链表合并写出来，比较容易处理<br>后续， k个链表只是先选出一个链表然后和其他链表相比较进行合并，思路其实一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(ListNode list:lists)&#123;<br>            res=mergeTwoList(res,list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoList</span><span class="hljs-params">(ListNode list1,ListNode list2)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">sential</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span> sential;<br>        <span class="hljs-keyword">while</span>(list1!=<span class="hljs-literal">null</span> &amp;&amp; list2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list1.val &lt;= list2.val)&#123;<br>                currentNode.next=list1;<br>                list1=list1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                currentNode.next = list2;<br>                list2=list2.next;<br>            &#125;<br>            currentNode = currentNode.next;<br>        &#125;<br>        currentNode.next = list1 ==<span class="hljs-literal">null</span> ?list2:list1;<br>        <span class="hljs-keyword">return</span> sential.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbhb-3.png" alt="img.png"><br>时间复杂度：O(NlogK) N是节点综合，K是链表数量，每个链表最多合并一次<br>空间复杂度:  O(n) 创建新链表保存。</p><p>总结：掌握好两个链表合并，这个困难题的合并链表就会写。</p><h1 id="3-合并两个链表"><a href="#3-合并两个链表" class="headerlink" title="3. 合并两个链表"></a>3. 合并两个链表</h1><p>给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。<br>请你将 list1 中下标从 a 到 b 的全部节点都删除，并将list2 接在被删除节点的位置。<br><a href="https://leetcode.cn/problems/merge-in-between-linked-lists/">力扣</a></p><h2 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h2><h3 id="3-1-1-可以仔细分析下，链表A从a-b将链表分成了3分，中间是不需要的，链表A在a-1的位置后面插入链表B，然后当链表B遍历结束了，这时候就去连接链表A的b-1的位置，很显然就是3个链表合并，拆分下来就是合并两次链表，需要记录a-1，b，链表B结束位置，然后合并。"><a href="#3-1-1-可以仔细分析下，链表A从a-b将链表分成了3分，中间是不需要的，链表A在a-1的位置后面插入链表B，然后当链表B遍历结束了，这时候就去连接链表A的b-1的位置，很显然就是3个链表合并，拆分下来就是合并两次链表，需要记录a-1，b，链表B结束位置，然后合并。" class="headerlink" title="3.1.1 可以仔细分析下，链表A从a-b将链表分成了3分，中间是不需要的，链表A在a-1的位置后面插入链表B，然后当链表B遍历结束了，这时候就去连接链表A的b+1的位置，很显然就是3个链表合并，拆分下来就是合并两次链表，需要记录a-1，b，链表B结束位置，然后合并。"></a>3.1.1 可以仔细分析下，链表A从a-b将链表分成了3分，中间是不需要的，链表A在a-1的位置后面插入链表B，然后当链表B遍历结束了，这时候就去连接链表A的b+1的位置，很显然就是3个链表合并，拆分下来就是合并两次链表，需要记录a-1，b，链表B结束位置，然后合并。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">mergeInBetween</span><span class="hljs-params">(ListNode list1, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, ListNode list2)</span> &#123;<br>     <span class="hljs-comment">// list1中a的位置</span><br>     <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre1</span> <span class="hljs-operator">=</span> list1;<br>     <span class="hljs-comment">// list1中b的位置</span><br>     <span class="hljs-type">ListNode</span> <span class="hljs-variable">end1</span> <span class="hljs-operator">=</span> list1;<br>     <span class="hljs-comment">// list2在list1的a+1位置</span><br>     <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre2</span> <span class="hljs-operator">=</span> list2;<br>     <span class="hljs-comment">// 计数到a</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-comment">// 计数到b</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>     <span class="hljs-keyword">while</span> (pre1 != <span class="hljs-literal">null</span> &amp;&amp; end1 != <span class="hljs-literal">null</span> &amp;&amp; j &lt; b) &#123;<br>         <span class="hljs-comment">// i=a-1获取a前一个元素的位置</span><br>         <span class="hljs-keyword">if</span> (i != a - <span class="hljs-number">1</span>) &#123;<br>             pre1 = pre1.next;<br>             i++;<br>         &#125;<br>         <span class="hljs-comment">// 获取b的位置</span><br>         <span class="hljs-keyword">if</span> (j != b) &#123;<br>             end1 = end1.next;<br>             j++;<br>         &#125;<br>     &#125;<br>     <span class="hljs-comment">// 获取了b+1的元素</span><br>     end1 = end1.next;<br>     <span class="hljs-comment">// 遍历list2</span><br>     <span class="hljs-keyword">while</span> (pre2.next != <span class="hljs-literal">null</span>) &#123;<br>         pre2 = pre2.next;<br>     &#125;<br>     pre1.next = list2;<br>     pre2.next = end1;<br>     <span class="hljs-keyword">return</span> list1;<br> &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/lbhb-4.png" alt="img.png"><br>时间复杂度：O(n)链表长度<br>空间复杂度：O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql面试题-2</title>
      <link href="/post/b0cc9896.html"/>
      <url>/post/b0cc9896.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-日志"><a href="#1-日志" class="headerlink" title="1. 日志"></a>1. 日志</h1><h1 id="1-1-什么是索引？使用索引的优缺点"><a href="#1-1-什么是索引？使用索引的优缺点" class="headerlink" title="1.1 什么是索引？使用索引的优缺点"></a>1.1 什么是索引？使用索引的优缺点</h1><p>用于快速查找和检索数据的一种数据结构<br>优点：</p><ol><li>可以提高检索数据的效率</li><li>可以创建唯一索引，保证每一行数据的唯一性。</li></ol><p>缺点:</p><ol><li>创建和维护索引需要不少的时间。如果执行增删改有索引，对于索引需要动态修改，降低效率</li><li>索引需要空间存储，耗费空间</li></ol><h1 id="1-2-Mysql的索引为什么使用B-tree"><a href="#1-2-Mysql的索引为什么使用B-tree" class="headerlink" title="1.2 Mysql的索引为什么使用B+tree"></a>1.2 Mysql的索引为什么使用B+tree</h1><h2 id="1-2-1-二叉查找树"><a href="#1-2-1-二叉查找树" class="headerlink" title="1.2.1 二叉查找树"></a>1.2.1 二叉查找树</h2><p>特点：</p><ol><li>左子树的值一定比根节点的值小</li><li>右子树的值一定比根节点的值大</li><li>左右子树也是二叉查找树<br>缺点：非常依赖于平衡程度（比如所有的数据都在根节点的左边或者都在右边）</li></ol><h2 id="1-2-2-AVL树"><a href="#1-2-2-AVL树" class="headerlink" title="1.2.2 AVL树"></a>1.2.2 AVL树</h2><p>特点：</p><ol><li>任意节点的左子树右子树的高度不超过1</li><li>采用旋转保持平衡，LL,LR,RR,RL<br>缺点：需要频繁的旋转保持平衡，降低性能，而且只能读取一个节点的数据，读取其他节点需要多次处理磁盘IO</li></ol><h2 id="1-2-3-红黑树"><a href="#1-2-3-红黑树" class="headerlink" title="1.2.3 红黑树"></a>1.2.3 红黑树</h2><p>特点：</p><ol><li>每个节点非红即黑</li><li>根节点总是黑的</li><li>叶子节点都是黑色的</li><li>节点是红的，子节点必须是黑的</li><li>根节点到叶子节点，包含相同的黑色节点个数<br>缺点：当树高了，读取数据就需要多次读取磁盘IO</li></ol><h2 id="1-2-4-B树"><a href="#1-2-4-B树" class="headerlink" title="1.2.4 B树"></a>1.2.4 B树</h2><p>特点：</p><ol><li>B树的所有节点存放数据和键</li><li>叶子节点都是独立的</li><li>检索过程是对范围内的每个节点做二分查找，可能没有到达叶子节点就找完了</li><li>范围查询，需要先找到查找的下限，执行中序遍历，找到上限<br>缺点：查找性能低，每个节点都存储数据，查找时需要遍历多个节点</li></ol><h2 id="1-2-5-B-树"><a href="#1-2-5-B-树" class="headerlink" title="1.2.5 B+树"></a>1.2.5 B+树</h2><p>特点：</p><ol><li>B+树只有叶子节点存放key和data，其他节点存放key</li><li>有引用链指向相邻的叶子节点</li><li>检索稳定，都是从根节点到叶子节点</li><li>范围查找著需要对链表遍历，减少IO次数</li></ol><h1 id="1-3-主键索引和二级索引"><a href="#1-3-主键索引和二级索引" class="headerlink" title="1.3 主键索引和二级索引"></a>1.3 主键索引和二级索引</h1><p>主键索引：一个数据表只能有一个主键，并且不能为空，不能重复，（如果没有指定，Mysql会自动创建一个索引）<br>二级索引：辅助索引，它的叶子节点存储的是主键，通过二级索引定位到主键位置。<br>二级索引分类：</p><ol><li>普通索引: 快速查找数据</li><li>前缀索引：文本前几个字符创建索引</li><li>唯一索引：唯一索引的属性不能出现重复数据源，但是可以为null</li><li>全文索引：检索大文本关键字信息</li></ol><h1 id="1-4-聚簇索引和非聚簇索引"><a href="#1-4-聚簇索引和非聚簇索引" class="headerlink" title="1.4 聚簇索引和非聚簇索引"></a>1.4 聚簇索引和非聚簇索引</h1><p>聚簇索引：包含了索引结构和数据，不是单独的索引，InnoDB采用的主键索引就是聚簇索引<br>优点：</p><ol><li>查找速度快：B+树就是二叉查找树，叶子节点有序，可以快速定位到索引的节点</li><li>排序和范围查找快</li></ol><p>缺点:</p><ol><li>依赖有序的数据</li><li>更新代价大</li></ol><p>非聚簇索引：索引结构和数据分开存储，MylSAM的主键非主键都是采用的非聚簇索引<br>优点：更新代价小<br>缺点：</p><ol><li>依赖有序数据</li><li>查找效率低，可能二次查表</li></ol><h1 id="1-5-覆盖索引和联合索引"><a href="#1-5-覆盖索引和联合索引" class="headerlink" title="1.5 覆盖索引和联合索引"></a>1.5 覆盖索引和联合索引</h1><p>覆盖索引：当索引字段就是需要查找的字段，直接根据该索引，返回数据，不需要回表查询。<br>联合索引：多个字段创建索引</p><h1 id="1-6-最左前缀匹配原则"><a href="#1-6-最左前缀匹配原则" class="headerlink" title="1.6 最左前缀匹配原则"></a>1.6 最左前缀匹配原则</h1><p>使用联合索引的时候，MySQL会根据联合索引的字段顺序，从左到右查询匹配，如果存在就过滤掉其他数据，如果碰到范围查询(&gt;,&lt;)就停止匹配。而(&gt;&#x3D;,&lt;&#x3D;,between,like)范围匹配不会停止匹配。</p><h1 id="1-7-创建索引事项"><a href="#1-7-创建索引事项" class="headerlink" title="1.7. 创建索引事项"></a>1.7. 创建索引事项</h1><h2 id="1-7-1-选用合适的字段"><a href="#1-7-1-选用合适的字段" class="headerlink" title="1.7.1 选用合适的字段"></a>1.7.1 选用合适的字段</h2><ol><li>不能使用null的字段</li><li>频繁查找的字段</li><li>频繁排序</li><li>条件查询的字段</li><li>频繁用于连接字段</li></ol><h2 id="1-7-2-频繁更新的字段不宜使用索引"><a href="#1-7-2-频繁更新的字段不宜使用索引" class="headerlink" title="1.7.2 频繁更新的字段不宜使用索引"></a>1.7.2 频繁更新的字段不宜使用索引</h2><h2 id="1-7-3限制索引数量"><a href="#1-7-3限制索引数量" class="headerlink" title="1.7.3限制索引数量"></a>1.7.3限制索引数量</h2><h2 id="1-7-4优先考虑联合索引"><a href="#1-7-4优先考虑联合索引" class="headerlink" title="1.7.4优先考虑联合索引"></a>1.7.4优先考虑联合索引</h2><h2 id="1-7-5-避免冗余索引"><a href="#1-7-5-避免冗余索引" class="headerlink" title="1.7.5 避免冗余索引"></a>1.7.5 避免冗余索引</h2><h2 id="1-7-6避免索引失效"><a href="#1-7-6避免索引失效" class="headerlink" title="1.7.6避免索引失效"></a>1.7.6避免索引失效</h2><h1 id="2-日志"><a href="#2-日志" class="headerlink" title="2. 日志"></a>2. 日志</h1><h2 id="2-1-Mysql的日志有哪些"><a href="#2-1-Mysql的日志有哪些" class="headerlink" title="2.1 Mysql的日志有哪些"></a>2.1 Mysql的日志有哪些</h2><p>redo log,undo log,binlog,慢查询日志，查询日志等等</p><h2 id="2-2-redo-log"><a href="#2-2-redo-log" class="headerlink" title="2.2 redo log"></a>2.2 redo log</h2><p><strong>重做日志</strong>，<strong>InnoDB</strong>存储引擎独有，让Mysql的崩溃恢复，保证Mysql的<strong>持久性</strong>，主要用于事务的回归和MVCC。</p><h2 id="2-3-redo-log如何保持事务的持久性"><a href="#2-3-redo-log如何保持事务的持久性" class="headerlink" title="2.3 redo log如何保持事务的持久性"></a>2.3 redo log如何保持事务的持久性</h2><p>redo log主要做的事就是<strong>记录页的修改</strong>，比如某个页的某个偏移量处修改了几个字节的数据以及具体被修改了什么值。提交事务的时候，将redo log按照<strong>刷盘策略</strong>刷到磁盘上去，即时宕机了，也能恢复未写入磁盘的数据，保证事务的持久性。</p><h2 id="2-4-页修改了之后为什么不直接刷盘"><a href="#2-4-页修改了之后为什么不直接刷盘" class="headerlink" title="2.4 页修改了之后为什么不直接刷盘"></a>2.4 页修改了之后为什么不直接刷盘</h2><p>这样性能十分差。InnoDB的每个页的大小都是16kB，页是与磁盘进行交互的基本单位，即时我们修改了几个字节的数据，仍然需要将整页数据重新刷入磁盘。而且修改可能不相邻。</p><h2 id="2-5-undo-log"><a href="#2-5-undo-log" class="headerlink" title="2.5 undo log"></a>2.5 undo log</h2><p>回滚日志，发生异常的时候进行回滚操作，Mysql里面的恢复机制是通过回滚日志undo log来进行的，所有事务进行的修改都会先记录到这个回滚日志里面，然后执行相关的操作，最主要是保证了<strong>原子性</strong>。</p><h2 id="2-6-undo-log如何保持事务的原子性"><a href="#2-6-undo-log如何保持事务的原子性" class="headerlink" title="2.6 undo log如何保持事务的原子性"></a>2.6 undo log如何保持事务的原子性</h2><p>每个事务对数据的修改都会被记录到undo log，出现错误或者需要回滚操作的时候，利用undo log回滚到操作之前</p><h2 id="2-7-binlog"><a href="#2-7-binlog" class="headerlink" title="2.7 binlog"></a>2.7 binlog</h2><p>逻辑日志，记录的是语句的<strong>原始逻辑</strong>，只要产生表更新就会产生binlog日志。主要用于主主，主从。主备，数据备份，依靠binlog实现<strong>同步数据</strong>，保持了<strong>数据一致性</strong></p><h2 id="2-8-binlog和-redo-log区别"><a href="#2-8-binlog和-redo-log区别" class="headerlink" title="2.8 binlog和 redo log区别"></a>2.8 binlog和 redo log区别</h2><ol><li>redo log是物理日志，binlog是逻辑日志</li><li>redo log主要是记录某个页上修改了什么数据，binlog主要是记录语句的原始逻辑</li><li>redo log属于InnoDB引擎，binlog属于Mysql的服务端</li><li>redo log不可以跨平台，binlog可以跨平台使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 面试题 </tag>
            
            <tag> Mysql日志 </tag>
            
            <tag> Mysql索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGpt+Vercel无需服务器部署</title>
      <link href="/post/b2dd429d.html"/>
      <url>/post/b2dd429d.html</url>
      
        <content type="html"><![CDATA[<h1 id="ChatGPT-Next-Web"><a href="#ChatGPT-Next-Web" class="headerlink" title="ChatGPT-Next-Web"></a>ChatGPT-Next-Web</h1><p>开源项目，跨平台无需服务器就可部署自己的gpt网页端口<br>地址<a href="https://github.com/Yidadaa/ChatGPT-Next-Web">https://github.com/Yidadaa/ChatGPT-Next-Web</a></p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol><li>一键部署</li><li>兼容各个系统</li><li>数据存储本地</li><li>支持markdown</li><li>支持自定义</li></ol><h1 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h1><ol><li>拥有vercel账号<br> 注册地址  <a href="https://vercel.com/dashboard%EF%BC%8C%E7%BB%91%E5%AE%9Agithub%E8%B4%A6%E5%8F%B7">https://vercel.com/dashboard，绑定github账号</a></li><li>拥有gpt账号<br>需要使用gpt的key</li><li>将ChatGPT-Next-Web  fork到自己的github仓库</li></ol><h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><ol><li>gpt的key获取<br>官网地址<a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a><br><img src="/images/gptv-1.png" alt="img.png"><br>点击创建新的key<br><img src="/images/gptv-2.png" alt="img.png"><br>保存好这个key</li><li>vercel部署<br>主界面<img src="/images/gptv-3.png" alt="img.png"><br>点击Add new Project创建新项目<br>找到自己之前的fork项目,点击import<br><img src="/images/gptv-4.png" alt="img.png"></li></ol><p>下拉找到Environment Variables<br><img src="/images/gptv-5.png" alt="img.png"><br>第一个填入OPENAI_API_KEY<br>第二个填入自己的gpt的key</p><p>新建一个NEXT_PUBLIC_USE_USER_KEY<br>让用户自己输入KEY才能用的设置，填入  false</p><p>点击部署，等待<br><img src="/images/gptv-6.png" alt="img.png"></p><ol start="3"><li><p>部署成功<br><img src="/images/gptv-7.png" alt="img.png"></p></li><li><p>去往自己的gpt<br>点击continue<br><img src="/images/gptv-8.png" alt="img.png"><br>里面的domain就是自己的域名地址，点击就能进入<br><img src="/images/gptv-9.png" alt="img.png"></p></li><li><p>配置域名<br>点击右上角的domain可以配置自己的域名<br><img src="/images/gptv-10.png" alt="img.png"></p></li></ol><h1 id="但是由于我的gpt是免费的，所以这里会显示余额不足，大家打着玩玩就行"><a href="#但是由于我的gpt是免费的，所以这里会显示余额不足，大家打着玩玩就行" class="headerlink" title="但是由于我的gpt是免费的，所以这里会显示余额不足，大家打着玩玩就行"></a>但是由于我的gpt是免费的，所以这里会显示余额不足，大家打着玩玩就行</h1><p><img src="/images/gptv-11.png" alt="img.png"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法通关村第一关——链表经典问题之两个链表的第一个公共节点笔记</title>
      <link href="/post/68997616.html"/>
      <url>/post/68997616.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目-输入两个链表，找出它们的第一个公共节点。"><a href="#题目-输入两个链表，找出它们的第一个公共节点。" class="headerlink" title="题目 输入两个链表，找出它们的第一个公共节点。"></a>题目 输入两个链表，找出它们的第一个公共节点。</h1><p>地址 <a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="1-使用暴力法，将每一个链表节点和另一个链表比较，找到相同的节点位置，返回，但是很显然，时间复杂度比较高。"><a href="#1-使用暴力法，将每一个链表节点和另一个链表比较，找到相同的节点位置，返回，但是很显然，时间复杂度比较高。" class="headerlink" title="1. 使用暴力法，将每一个链表节点和另一个链表比较，找到相同的节点位置，返回，但是很显然，时间复杂度比较高。"></a>1. 使用暴力法，将每一个链表节点和另一个链表比较，找到相同的节点位置，返回，但是很显然，时间复杂度比较高。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">currA</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-keyword">while</span> (currA != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">currB</span> <span class="hljs-operator">=</span> headB;<br>            <span class="hljs-keyword">while</span> (currB != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (currA == currB) &#123;<br>                    <span class="hljs-keyword">return</span> currA;<br>                &#125;<br>                currB = currB.next;<br>            &#125;<br>            currA = currA.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-1.png" alt="img.png"><br>时间复杂度：O（mn），两个链表遍历的长度相乘<br>空间复杂度：O（1），使用了两个节点</p><p>可以看出时间复杂读还是很高的</p><h2 id="2-又想到了考虑的是既然要找到公共节点，两个链表是有长短的，只要找出短的链表，计算长度，然后再遍历长的链表，当两个链表一样长的时候，比较值就可以了，但是可想而知，会使用一堆while循环。"><a href="#2-又想到了考虑的是既然要找到公共节点，两个链表是有长短的，只要找出短的链表，计算长度，然后再遍历长的链表，当两个链表一样长的时候，比较值就可以了，但是可想而知，会使用一堆while循环。" class="headerlink" title="2. 又想到了考虑的是既然要找到公共节点，两个链表是有长短的，只要找出短的链表，计算长度，然后再遍历长的链表，当两个链表一样长的时候，比较值就可以了，但是可想而知，会使用一堆while循环。"></a>2. 又想到了考虑的是既然要找到公共节点，两个链表是有长短的，只要找出短的链表，计算长度，然后再遍历长的链表，当两个链表一样长的时候，比较值就可以了，但是可想而知，会使用一堆while循环。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode2</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>      <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-comment">// 先获取相应链表的长度</span><br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentA</span> <span class="hljs-operator">=</span> headA;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentB</span> <span class="hljs-operator">=</span> headB;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">lengthA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">lengthB</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (currentA != <span class="hljs-literal">null</span>) &#123;<br>          currentA = currentA.next;<br>          lengthA++;<br>      &#125;<br>      <span class="hljs-keyword">while</span> (currentB != <span class="hljs-literal">null</span>) &#123;<br>          currentB = currentB.next;<br>          lengthB++;<br>      &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">minLength</span> <span class="hljs-operator">=</span> lengthA &gt; lengthB ? lengthB : lengthA;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <br>      <span class="hljs-comment">// 链表A比较短</span><br>      <span class="hljs-keyword">if</span> (minLength == lengthA) &#123;<br>          <span class="hljs-keyword">while</span> (lengthB - count &gt; lengthA) &#123;<br>              headB = headB.next;<br>              count++;<br>          &#125;<br>          <span class="hljs-keyword">while</span> (headA != headB) &#123;<br>              headB = headB.next;<br>              headA = headA.next;<br>          &#125;<br>          <span class="hljs-keyword">return</span> headA;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (minLength == lengthB) &#123;<br>          <span class="hljs-keyword">while</span> (lengthA - count &gt; lengthB) &#123;<br>              headA = headA.next;<br>              count++;<br>          &#125;<br>          <span class="hljs-keyword">while</span> (headA != headB) &#123;<br>              headB = headB.next;<br>              headA = headA.next;<br>          &#125;<br>          <span class="hljs-keyword">return</span> headB;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-2.png" alt="img.png"><br>时间复杂度：首先各自遍历链表长度，为O(m+n), 然后调整长链表的长度和短链表一致，时间复杂度是O(max(m,n))，最后再执行遍历找到公共节点，O(min(m,n)),总的来说O(m+n+max(m,n)+min(m,n)),也不知道算的对不对，但是就是很复杂。</p><p>空间复杂度：O(1)两个节点；</p><p>总结：虽然一开始感觉时间耗费高，但是测试下来，发现时间耗费这么低。</p><h2 id="3-既然考虑公共节点，那么也就是说可以看作是在集合或者数据里面判断是否两个相同的数，最直接的是考虑hash，只需要将一个链表的节点放入map，然后依次和另一个链表的节点比较就行"><a href="#3-既然考虑公共节点，那么也就是说可以看作是在集合或者数据里面判断是否两个相同的数，最直接的是考虑hash，只需要将一个链表的节点放入map，然后依次和另一个链表的节点比较就行" class="headerlink" title="3. 既然考虑公共节点，那么也就是说可以看作是在集合或者数据里面判断是否两个相同的数，最直接的是考虑hash，只需要将一个链表的节点放入map，然后依次和另一个链表的节点比较就行"></a>3. 既然考虑公共节点，那么也就是说可以看作是在集合或者数据里面判断是否两个相同的数，最直接的是考虑hash，只需要将一个链表的节点放入map，然后依次和另一个链表的节点比较就行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>       Set&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>       <span class="hljs-keyword">while</span> (headA != <span class="hljs-literal">null</span>) &#123;<br>           set.add(headA);<br>           headA = headA.next;<br>       &#125;<br>       <span class="hljs-keyword">while</span> (headB != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">if</span> (set.contains(headB)) &#123;<br>               <span class="hljs-keyword">return</span> headB;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               headB = headB.next;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-3.png" alt="img.png"><br>时间复杂度：第一次循环添加headA节点，O(m),第二次遍历headB,O(n),总体O(m+n)<br>空间复杂度: 使用set来存储节点，O(m)</p><p>总结：需要多加注意下尤其是涉及到是否包含相同的节点，数的时候就考虑使用哈希</p><h2 id="4-使用栈，特点是先进后出，本质上还是将两个链表节点比较，只是由于是逆序，所以，如果有共同节点，最后一个相同的节点之后的其他节点就不相同了，不需要像之前从头开始循环遍历比较。"><a href="#4-使用栈，特点是先进后出，本质上还是将两个链表节点比较，只是由于是逆序，所以，如果有共同节点，最后一个相同的节点之后的其他节点就不相同了，不需要像之前从头开始循环遍历比较。" class="headerlink" title="4. 使用栈，特点是先进后出，本质上还是将两个链表节点比较，只是由于是逆序，所以，如果有共同节点，最后一个相同的节点之后的其他节点就不相同了，不需要像之前从头开始循环遍历比较。"></a>4. 使用栈，特点是先进后出，本质上还是将两个链表节点比较，只是由于是逆序，所以，如果有共同节点，最后一个相同的节点之后的其他节点就不相同了，不需要像之前从头开始循环遍历比较。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        Stack&lt;ListNode&gt; stackA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;ListNode&gt;();<br>        Stack&lt;ListNode&gt; stackB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;ListNode&gt;();<br>        <span class="hljs-keyword">while</span> (headA != <span class="hljs-literal">null</span>) &#123;<br>            stackA.add(headA);<br>            headA = headA.next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (headB != <span class="hljs-literal">null</span>) &#123;<br>            stackB.add(headB);<br>            headB = headB.next;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (stackA.size() &gt; <span class="hljs-number">0</span> &amp;&amp; stackB.size() &gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (stackA.peek() == stackB.peek()) &#123;<br>                preNode = stackA.pop();<br>                stackB.pop();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> preNode;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-4.png" alt="img.png"><br>时间复杂度：第一个链表添加至栈,O(m),第二个链表添加至栈，O(n)，最坏情况下O(min(m,n))，就是两个链表的长度谁短，总的O(m+n+min(m,n))<br>空间复杂度：O（m+n）</p><h2 id="5-拼接字符串，感觉很熟悉但是又很陌生的方法，分别将两个链表合并起来，合并的两个链表就是一样长的，然后比较节点，那么那个相同的节点就是结果。"><a href="#5-拼接字符串，感觉很熟悉但是又很陌生的方法，分别将两个链表合并起来，合并的两个链表就是一样长的，然后比较节点，那么那个相同的节点就是结果。" class="headerlink" title="5. 拼接字符串，感觉很熟悉但是又很陌生的方法，分别将两个链表合并起来，合并的两个链表就是一样长的，然后比较节点，那么那个相同的节点就是结果。"></a>5. 拼接字符串，感觉很熟悉但是又很陌生的方法，分别将两个链表合并起来，合并的两个链表就是一样长的，然后比较节点，那么那个相同的节点就是结果。</h2><p><img src="/images/gonggongjiedian-5.png" alt="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>       <span class="hljs-comment">// 需要考虑不为空的情况</span><br>       <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> headB;<br>       <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>           <span class="hljs-comment">// 不为null的时候继续遍历</span><br>           p1 = p1.next;<br>           p2 = p2.next;<br>           <span class="hljs-keyword">if</span> (p1 != p2) &#123;<br>               <span class="hljs-comment">// 链表1结束，转为链表2</span><br>               <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">null</span>) &#123;<br>                   p1 = headB;<br>               &#125;<br>               <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">null</span>) &#123;<br>                   p2 = headA;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> p1;<br>   &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-6.png" alt="img.png"></p><p>时间复杂度：最坏O(m+n)没有节点<br>空间复杂度：O(1)</p><p>总结：里面的两个if是没有关系的，不能使用else。假设链表1大于链表2的长度，那么第一个拼接的链表，公共点就在拼接的链表2上面，第二个拼接的链表，公共点就在链表1上面。核心思路还是将链表长度归一.</p><h2 id="6-差和双指针，假如公共子节点一定存在第一轮遍历，假设La长度为L1，Lb长度为L2-则｜L2-L1｜就是两个的差值。第二轮遍历，长的先走｜L2-L1｜-然后两个链表同时向前走，结点一样的时候就是公共结点了。这个方法仔细思考一下，和我第二个思路基本上一致，只不过对于部分进行了优化，比如之前的取最短的链表的长度，这个需要做两次判断，因为不知道哪个链表短，采取的方式也不一样，所以这里可以做一些优化。"><a href="#6-差和双指针，假如公共子节点一定存在第一轮遍历，假设La长度为L1，Lb长度为L2-则｜L2-L1｜就是两个的差值。第二轮遍历，长的先走｜L2-L1｜-然后两个链表同时向前走，结点一样的时候就是公共结点了。这个方法仔细思考一下，和我第二个思路基本上一致，只不过对于部分进行了优化，比如之前的取最短的链表的长度，这个需要做两次判断，因为不知道哪个链表短，采取的方式也不一样，所以这里可以做一些优化。" class="headerlink" title="6.  差和双指针，假如公共子节点一定存在第一轮遍历，假设La长度为L1，Lb长度为L2.则｜L2-L1｜就是两个的差值。第二轮遍历，长的先走｜L2-L1｜,然后两个链表同时向前走，结点一样的时候就是公共结点了。这个方法仔细思考一下，和我第二个思路基本上一致，只不过对于部分进行了优化，比如之前的取最短的链表的长度，这个需要做两次判断，因为不知道哪个链表短，采取的方式也不一样，所以这里可以做一些优化。"></a>6.  差和双指针，假如公共子节点一定存在第一轮遍历，假设La长度为L1，Lb长度为L2.则｜L2-L1｜就是两个的差值。第二轮遍历，长的先走｜L2-L1｜,然后两个链表同时向前走，结点一样的时候就是公共结点了。这个方法仔细思考一下，和我第二个思路基本上一致，只不过对于部分进行了优化，比如之前的取最短的链表的长度，这个需要做两次判断，因为不知道哪个链表短，采取的方式也不一样，所以这里可以做一些优化。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> headB;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">lengthA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">lengthB</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">null</span>) &#123;<br>          lengthA++;<br>          p1 = p1.next;<br>      &#125;<br><br>      <span class="hljs-keyword">while</span> (p2 != <span class="hljs-literal">null</span>) &#123;<br>          lengthB++;<br>          p2 = p2.next;<br>      &#125;<br><br>      p1 = headA;<br>      p2 = headB;<br>      <span class="hljs-comment">// 判断长度</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> lengthA &gt; lengthB ? lengthA - lengthB : lengthB - lengthA;<br>      <span class="hljs-keyword">if</span> (lengthA&gt;lengthB)&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">while</span> (a &lt; sub)&#123;<br>              p1 = p1.next;<br>              a++;<br>          &#125;<br>      &#125;<br><br><br>      <span class="hljs-keyword">if</span> (lengthB&gt;lengthA)&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">while</span> (b&lt;sub)&#123;<br>              p2 = p2.next;<br>              b++;<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">while</span> (p1!=p2)&#123;<br>          p1 =p1.next;<br>          p2=p2.next;<br>      &#125;<br>      <span class="hljs-keyword">return</span> p1;<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行截图<br><img src="/images/gonggongjiedian-7.png" alt="img.png"></p><p>时间复杂度：两个链表遍历长度O(m+n)，判断sub谁小O(sub)，同步找到公共节点O(min(m,n))，总的O(m+n+min(m,n)+sub)；<br>空间复杂度：O(1)</p><p>总结: 相比于之前的代码这个还节省了内存。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其中有3个方法都是围绕着链表的长度来的，很明显，这道题目核心就是链表长度。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql面试题-1</title>
      <link href="/post/29c5c92c.html"/>
      <url>/post/29c5c92c.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Mysql的基础架构-Sql在Mysql里面的执行流程"><a href="#1-Mysql的基础架构-Sql在Mysql里面的执行流程" class="headerlink" title="1. Mysql的基础架构&#x2F;Sql在Mysql里面的执行流程"></a>1. Mysql的基础架构&#x2F;Sql在Mysql里面的执行流程</h1><p>有连接器，查询缓存，分析器，优化器，执行器，插件式存储引擎。<br><img src="/images/mysql-1.png" alt="img.png"><br>连接器：身份认证以及权限登录，管理链接吗，查询认证。<br>查询缓存：执行查询语句，如果缓存里面有数据就直接返回。（Mysql 8已经移除，不常用）<br>分析器：检查sql是否有问题，词法分析，语法分析。<br>优化器：按照mysql认为的最优解来执行，选择。<br>执行器：执行sql代码，但是执行前还是要检查用户权限。<br>存储引擎：存储数据，提供读写接口</p><h1 id="2-Mysql支持的存储引擎"><a href="#2-Mysql支持的存储引擎" class="headerlink" title="2. Mysql支持的存储引擎"></a>2. Mysql支持的存储引擎</h1><p>通过show engines查看，这里我的是Mysql 8<br><img src="/images/mysql-2.png" alt="img.png"><br>一般默认的是InnoDB，只有InnoDB支持事务性存储引擎，也就是支持事务。<br>Mysql 5这里是MyISAM </p><h1 id="3-Mysql的存储引擎架构"><a href="#3-Mysql的存储引擎架构" class="headerlink" title="3. Mysql的存储引擎架构"></a>3. Mysql的存储引擎架构</h1><p>mysql采用的是<strong>插件式架构</strong>，支持多种存储引擎。存储引擎是基于表的，而不是数据库。</p><h1 id="4-MylSAM和InnoDB的区别"><a href="#4-MylSAM和InnoDB的区别" class="headerlink" title="4. MylSAM和InnoDB的区别"></a>4. MylSAM和InnoDB的区别</h1><ol><li>InnoDB支持行级锁，MylSAM只支持表级锁</li><li>InnoDB支持事务，定义了四个隔离级别，MylSAM不支持</li><li>InnoDB支持MVCC，MylSAM不支持</li><li>InnoDB支持外键（一般不推荐）</li><li>InnoDB支持数据崩溃后能够安全恢复</li><li>InnoDB性能好。</li><li>虽然两者都是使用B+tree实现的，但是有差别，InnoDB数据文件本身就是索引，而MylSAM，索引文件，数据文件是分离的。</li></ol><h1 id="5-事务"><a href="#5-事务" class="headerlink" title="5. 事务"></a>5. 事务</h1><h2 id="5-1-什么是事务？"><a href="#5-1-什么是事务？" class="headerlink" title="5.1 什么是事务？"></a>5.1 什么是事务？</h2><p>逻辑上的一组操作，要么都成功，要么都失败。</p><h2 id="5-2-什么是ACID"><a href="#5-2-什么是ACID" class="headerlink" title="5.2 什么是ACID"></a>5.2 什么是ACID</h2><ol><li>原子性：事务是最小的执行单位，事物的原子性保证操作要么都成功，要么都失败。</li><li>一致性：执行事务前后，数据保持一致</li><li>隔离性：并发访问数据库，一个用户的事务是不会被其他事务干扰，各并发事务间是独立的。</li><li>持久性：一个事务提交，对数据库的改变是永久的，哪怕数据库崩溃后恢复。</li></ol><p>原子性，隔离性，持久性都是为了一致性（一直以来的误区，这四个并不是同一层面）<br><img src="/images/mysql-3.png" alt="img.png"></p><h2 id="5-3-并发带来的问题"><a href="#5-3-并发带来的问题" class="headerlink" title="5.3 并发带来的问题"></a>5.3 并发带来的问题</h2><ul><li>脏读：一个事务读取了数据，对数据进行操作修改，另一个事务读取了修改后的数据，但是第一个事务回滚，数据恢复原来的数据，但是第二个事务并不知道，读取的就是脏数据。</li><li>幻读：当一个事务读取了几行数据，另一个并发事务又添加了几条数据，第一个事务就多了些原本不存在的数据。</li><li>不可重复读：当一个事务多次读取一个数据，第二个事务读取数据并且进行操作修改，第一个事务两次读的数据就不一致。</li><li>丢失修改：在一个事务读取数据后，另一个事务也来读取数据，第一个事务对于数据进行操作后，第二个事务也对数据进行了操作，那么第一个事务就认为自己已经操作成功，但是实际上已经丢失了。</li></ul><h2 id="5-4-事物的并发控制有哪些？"><a href="#5-4-事物的并发控制有哪些？" class="headerlink" title="5.4 事物的并发控制有哪些？"></a>5.4 事物的并发控制有哪些？</h2><p>锁和MVCC，锁可以看作悲观控制模式，MVCC多版本并发，可以看作乐观控制的模式。<br>读写锁：</p><ol><li>共享锁（S锁）：读锁。事务读取记录的时候获取共享锁，允许多个事务获取。</li><li>排他锁（X锁）：写锁，当一个事务获取锁来进行对数据的修改写入，其他事务就不能获取这个锁</li></ol><p>MVCC多版本并发控制：隐藏字段，undo log，read view</p><ol><li>undo log：记录某行多个数据的版本</li><li>read view和隐藏字段：判断当前版本数据的可见性。</li></ol><h2 id="5-5-SQL定义了哪些事务隔离级别"><a href="#5-5-SQL定义了哪些事务隔离级别" class="headerlink" title="5.5 SQL定义了哪些事务隔离级别"></a>5.5 SQL定义了哪些事务隔离级别</h2><ol><li>READ_UNCOMMITTED(读取未提交)：允许读取尚未提交的数据，会导致脏读，幻读，不可重复读</li><li>READ_COMMITTED(读取已提交)：允许读取已经提交的数据，可以阻止脏读，但是不可以组织幻读和不可重复读</li><li>REPEATABLE-READ(可重复读)：对同一字段的多个读取结果都是一致的，除非事务进行修改，可以阻止脏读，不可重复读，但是不可以阻止幻读。</li><li>SERIALIZABLE(可串行化)：完全服从ACID的隔离级别，事务逐个执行，可以防止脏读，幻读，不可重复读</li></ol><h2 id="5-6-Mysql默认事务隔离级别"><a href="#5-6-Mysql默认事务隔离级别" class="headerlink" title="5.6 Mysql默认事务隔离级别"></a>5.6 Mysql默认事务隔离级别</h2><p>可重复读<br>SELECT @@transaction_isolation;<br><img src="/images/mysql-4.png" alt="img.png"></p><h2 id="5-7-Mysql隔离级别是基于锁实现的吗？"><a href="#5-7-Mysql隔离级别是基于锁实现的吗？" class="headerlink" title="5.7 Mysql隔离级别是基于锁实现的吗？"></a>5.7 Mysql隔离级别是基于锁实现的吗？</h2><p>基于锁和MVCC，只是最高级别可串行化，里面使用了锁，而MVCC主要用于读取已提交和可重复读。</p><h1 id="6-Mysql锁"><a href="#6-Mysql锁" class="headerlink" title="6 Mysql锁"></a>6 Mysql锁</h1><h2 id="6-1-表级锁和行级锁区别？"><a href="#6-1-表级锁和行级锁区别？" class="headerlink" title="6.1 表级锁和行级锁区别？"></a>6.1 表级锁和行级锁区别？</h2><p>表级锁：锁定粒度最大的锁，针对非索引字段加上的锁，对当前操作的整张表进行加锁，实现简单，资源消耗少，不会出现死锁，高并发效率低。InnoDB和MylSAM都支持。<br>行级锁：锁定粒度最小的锁，针对索引字段加上的锁，只针对当前操作的行记录加锁。减少了数据库的冲突，开销较大，可能死锁。与存储引擎有关。</p><h2 id="6-2-行级锁有什么使用事项？"><a href="#6-2-行级锁有什么使用事项？" class="headerlink" title="6.2 行级锁有什么使用事项？"></a>6.2 行级锁有什么使用事项？</h2><p>行级锁主要是针对有索引的字段加上的锁，而表级锁是针对非索引字段加上的锁。当我们执行update，delete语句的时候，如果where后面的字段没有命中唯一索引或者索引失效，就对表里面的所有数据都加上锁，走全表扫描。</p><h2 id="6-3-InnoDB有哪几类行锁？"><a href="#6-3-InnoDB有哪几类行锁？" class="headerlink" title="6.3 InnoDB有哪几类行锁？"></a>6.3 InnoDB有哪几类行锁？</h2><p>记录锁（Record Lock）：单个行记录上的锁, 只能锁住已经存在的记录，为避免插入新纪录，需要依赖间隙锁。<br>间隙锁（Gap Lock）：锁定一个范围不包括记录本身<br>临键锁（Next-Key Lock）：锁定一个范围，包括记录本身。解决幻读。</p><p>InnoDB默认的隔离级别是可重复读，行级锁默认使用临键锁，但是如果有操作是唯一索引，或者主键，将会采用降级为记录锁，仅锁住索引本身，而不是范围。</p><h2 id="6-4-共享锁和排他锁"><a href="#6-4-共享锁和排他锁" class="headerlink" title="6.4 共享锁和排他锁"></a>6.4 共享锁和排他锁</h2><p>共享锁（S锁）：读锁，当一个事务读取记录的时候，获取共享锁，其他事务也能获取共享锁。<br>排他锁（X锁）：写锁，当一个事务进行修改写入的时候获取锁，其他事务就不能获取锁。</p><h2 id="6-5-意向锁"><a href="#6-5-意向锁" class="headerlink" title="6.5 意向锁"></a>6.5 意向锁</h2><p>判断是否可以对某个表使用表锁，是表级锁<br>有两种：</p><ol><li>意向共享锁：事务有意向对表中的某些记录加上共享锁，加锁之前必须获取IS锁</li><li>意向排他锁：事务有意向对表中的某些记录加上排他锁，加锁之前必须获取IX锁。<br>意向锁是数据引擎自己维护的，用户无法手动操作意向锁</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法通关村第一关——链表经典问题之判断是否为回文序列</title>
      <link href="/post/f90e52df.html"/>
      <url>/post/f90e52df.html</url>
      
        <content type="html"><![CDATA[<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br><a href="https://leetcode.cn/problems/palindrome-linked-list/">力扣234</a></p><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="1. 分析"></a>1. 分析</h2><p><img src="/images/img-s1-1.png" alt="img.png"></p><h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><p>就是遍历链表，将元素写入数组，然后数组采用二分等等来比较。还有一种是将这些变成数字，然后使用数字的回文表示，但是由于这里是链表，考察的并不是其他的方法，就不做考虑。</p><h3 id="1-2-栈"><a href="#1-2-栈" class="headerlink" title="1.2 栈"></a>1.2 栈</h3><p>采用栈，将链表元素先全部入栈，出来后就是逆序的链表的值，然后依次比对是否一样，这里有个优化点，就是只需要比较一半，因为回文的另一半是一样的，不一样的肯定不是回文。<br><img src="/images/img_s1-2.png" alt="img_1.png"></p><h3 id="1-3-翻转链表"><a href="#1-3-翻转链表" class="headerlink" title="1.3 翻转链表"></a>1.3 翻转链表</h3><p>创建一个新的链表，然后使用反转链表，将元素依次插入，然后将新链表和原链表相应的值进行比较<br><img src="/images/img_s1-3.png" alt="img_2.png"></p><h3 id="1-4-快慢指针"><a href="#1-4-快慢指针" class="headerlink" title="1.4 快慢指针"></a>1.4 快慢指针</h3><p>可以将链表的后半部分反转，然后将前半部分和后半部分进行比较，比较难以想到。</p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h2><h3 id="2-1-栈"><a href="#2-1-栈" class="headerlink" title="2.1 栈"></a>2.1 栈</h3><p>思路主要是先将元素都入栈，然后使用栈的长度和链表长度比较，里面主要是比较是否元素相等，再一次遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<br>       Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>           stack.push(current.value);<br>           current = current.next;<br>       &#125;<br>       <span class="hljs-keyword">while</span> (head!=<span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">if</span> (head.value  != stack.pop())&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>           head = head.next;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度: O(n)，需要遍历两次链表，第一次入栈，第二次比较<br>空间复杂度: O(n)，链表长度n</p><p>运行<br><img src="/images/img_s1-4.png" alt="img_3.png"><br>解决速度并不是太好</p><h3 id="2-2-栈优化"><a href="#2-2-栈优化" class="headerlink" title="2.2 栈优化"></a>2.2 栈优化</h3><p>既然是回文数，那么另一半是对称的，只需要在出栈的时候比较一半的元素就可以了，需要使用一个计数器来比较，偶数个元素，正好一半，奇数个，中间往两边对称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(current.value);<br>            current = current.next;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> stack.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (count != size / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (head.value != stack.pop()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            head = head.next;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度:  O(n)，但是这个是l&#x2F;2个长度，所以还是n</p><p>运行<br><img src="/images/img_s1-5.png" alt="img_4.png"><br>可以看出有一点提升，但是不明显</p><h3 id="2-3-反转链表"><a href="#2-3-反转链表" class="headerlink" title="2.3 反转链表"></a>2.3 反转链表</h3><p>这个思路很简单，只需要创建一个新的链表，然后相应的指针是逆序而已，然后一一比较对应的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 反转链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">reversed</span> <span class="hljs-operator">=</span> reverseList(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-keyword">while</span> (reversed != <span class="hljs-literal">null</span> &amp;&amp; current != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (reversed.value != current.value) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            reversed = reversed.next;<br>            current = current.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反转链表，不影响原链表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">reversed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 只需要将当前节点的值给到一个空节点，然空节点代替原来的节点进行操作</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(current.value);<br>            newNode.next = reversed;<br>            reversed = newNode;<br>            current = current.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> reversed;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里一开始苦恼的问题是反转链表之后，原来的链表就不存在了，后面了解到了一种方法，就是使用新节点保存值来替代对原来节点的操作。</p><p>时间复杂度：O(n)，主要是两个部分，一个是反转链表遍历O(n) ，比较节点值是O(n&#x2F;2)<br>空间复杂度：O(n) 链表的长度</p><p>运行<br><img src="/images/img_s1-6.png" alt="img_5.png"><br>使用了部分空间换时间</p><h3 id="2-4-反转链表-快慢指针"><a href="#2-4-反转链表-快慢指针" class="headerlink" title="2.4 反转链表+快慢指针"></a>2.4 反转链表+快慢指针</h3><p>上面反转链表还是将所有元素数据都反转了，但是既然是回文数，那么就意味着只需要反转一半元素。先遍历一遍，得到长度，然后重新遍历，到达一半之后反转了，直接比较两个链表的长度即可。<br>这个比较难以想到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-comment">// 特殊情况，只有一个节点或者没有节点</span><br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-comment">// prepre反转好的头节点</span><br>    <span class="hljs-comment">// pre当前处理的节点</span><br>    <span class="hljs-comment">// slow向后移动</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head, prepre = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        pre = slow;<br>        <span class="hljs-comment">// 慢指针移动一步</span><br>        slow = slow.next;<br>        <span class="hljs-comment">// 快指针移动两步</span><br>        fast = fast.next.next;<br>        pre.next = prepre;<br>        prepre = pre;<br>    &#125;<br>    <span class="hljs-comment">// 快指针不为空，是奇数，慢指针后移一位</span><br>    <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-comment">// pre处理前半部分链表</span><br>    <span class="hljs-comment">// slow处理后半部分部分链表</span><br>    <span class="hljs-keyword">while</span>(pre != <span class="hljs-literal">null</span> &amp;&amp; slow != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span>(pre.value != slow.value) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        pre = pre.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n),只需要遍历一次链表<br>空间复杂度：O(1)使用了指针</p><p>运行<br><img src="/images/img_s1-7.png" alt="img_6.png"><br>这个方法是目前来说最快的，但是不理解这4个指针的话，甚至看不懂这个代码，快慢指针负责移动，剩余两个指针做链表反转一半，然后比对，这个还是需要在思索思索，还是有点绕在里面</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
            <tag> Java </tag>
            
            <tag> 回文数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法第一关——链表青铜挑战笔记</title>
      <link href="/post/cb83085.html"/>
      <url>/post/cb83085.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1. 单链表"></a>1. 单链表</h1><h2 id="1-单链表的建造"><a href="#1-单链表的建造" class="headerlink" title="1. 单链表的建造"></a>1. 单链表的建造</h2><p>链表有两个属性，一个就是当前的值val，还有一个就是记录当前节点的下一个节点位置，由此可以写出建造链表的相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    ListNode next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value, ListNode next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(ListNode next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-链表遍历"><a href="#2-链表遍历" class="headerlink" title="2. 链表遍历"></a>2. 链表遍历</h2><p>链表没有相关属性来记录当前的链表长度，所以只能经过遍历获取链表长度</p><p><img src="/images/img_2.png" alt="img_2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getListNodeLength</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-keyword">while</span> (listNode != <span class="hljs-literal">null</span>) &#123;<br>           length++;<br>           listNode = listNode.next;<br>       &#125;<br>       <span class="hljs-keyword">return</span> length;<br>   &#125;<br></code></pre></td></tr></table></figure><p>链表展示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-keyword">while</span> (listNode != <span class="hljs-literal">null</span>) &#123;<br>           System.out.print(listNode.value + <span class="hljs-string">&quot;=&gt;&quot;</span>);<br>           listNode = listNode.next;<br>       &#125;<br>       System.out.println(<span class="hljs-string">&quot;null&quot;</span>);<br>   &#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3. 插入元素"></a>3. 插入元素</h2><h3 id="3-1-头插法"><a href="#3-1-头插法" class="headerlink" title="3.1 头插法"></a>3.1 头插法</h3><p><img src="/images/img_4.png" alt="img_4.png"><br>头插法相对简单<br>新节点的下一个元素指向当前的头节点，然后头节点移动到新的节点处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">insertIntoNode</span><span class="hljs-params">(ListNode head, ListNode newNode)</span> &#123;<br>    newNode.next = head;<br>    head = newNode;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-尾插法"><a href="#3-2-尾插法" class="headerlink" title="3.2 尾插法"></a>3.2 尾插法</h3><p>在最后一个元素处后面插入元素，即最后一个元素的next指向插入元素，插入元素的下一个指向null<br><img src="/images/img_5.png" alt="img_5.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">insertIntoTail</span><span class="hljs-params">(ListNode head, ListNode newNode)</span> &#123;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>      <span class="hljs-keyword">while</span> (listNode.next != <span class="hljs-literal">null</span>) &#123;<br>          listNode = listNode.next;<br>      &#125;<br>      listNode.next = newNode;<br>      newNode.next = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">return</span> head;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-指定位置插入"><a href="#3-3-指定位置插入" class="headerlink" title="3.3 指定位置插入"></a>3.3 指定位置插入</h3><p>需要找到插入元素的位置的前一个元素，先将新建节点的next指向当前位置的下一个节点的位置，然后将当前节点的next指向新建节点</p><p>这两个顺序不能颠倒，如果颠倒了，当前节点就无法找到当前节点的下一个元素的位置，这时候连接已经断了，成为了两个链表<br><img src="/images/img_6.png" alt="img_6.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">insertIntoPosition</span><span class="hljs-params">(ListNode head, ListNode newNode, <span class="hljs-type">int</span> position)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span> (length &lt; position - <span class="hljs-number">1</span>) &#123;<br>           listNode = listNode.next;<br>           length++;<br>       &#125;<br>       newNode.next = listNode.next;<br>       listNode.next = newNode;<br>       <span class="hljs-keyword">return</span> head;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h3><p>以上3个方法较为独立，都是没有考虑到一些特殊情况，比如链表为空，插入元素的位置查过当前链表的界限，下面将会综合以上考虑完成较为完整的插入代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">insertIntoListNode</span><span class="hljs-params">(ListNode head, ListNode newNode, <span class="hljs-type">int</span> position)</span> &#123;<br>        <span class="hljs-comment">// 当前链表为空，插入元素则为第一个节点</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> newNode;<br>        &#125;<br>        <span class="hljs-comment">// 是否超过界限</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">listNodeLength</span> <span class="hljs-operator">=</span> getListNodeLength(head);<br>        <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">1</span> || position &gt; listNodeLength + <span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;元素越界&quot;</span>);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// 头节点</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) &#123;<br>            newNode.next = head;<br>            head = newNode;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 指定位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (count &lt; position - <span class="hljs-number">1</span>) &#123;<br>            node = node.next;<br>            count++;<br>        &#125;<br>        newNode.next = node.next;<br>        node.next = newNode;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4-删除元素"><a href="#4-删除元素" class="headerlink" title="4 删除元素"></a>4 删除元素</h2><h3 id="4-1-头删"><a href="#4-1-头删" class="headerlink" title="4.1 头删"></a>4.1 头删</h3><p>相对来说简单，只需要将头节点向后移动即可<br><img src="/images/img_7.png" alt="img_7.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">deleteHead</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>    listNode = listNode.next;<br>    head = listNode;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-尾删"><a href="#4-2-尾删" class="headerlink" title="4.2 尾删"></a>4.2 尾删</h3><p>主要需要找到尾部元素的前一个元素，将他的下一个节点指向null即可<br><img src="/images/img_8.png" alt="img_8.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">deleteTail</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (listNode.next.next != <span class="hljs-literal">null</span>) &#123;<br>            listNode = listNode.next;<br>        &#125;<br>        listNode.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-指定位置删除"><a href="#4-3-指定位置删除" class="headerlink" title="4.3 指定位置删除"></a>4.3 指定位置删除</h3><p><img src="/images/img_9.png" alt="img_9.png"><br>需要找到删除元素的前一个元素，先保留删除元素和前一个元素之间的联系，不能断开，否则无法找到后面的其他节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">deleteByPosition</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> position)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (count &lt; position - <span class="hljs-number">1</span>) &#123;<br>            count++;<br>            listNode = listNode.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">deleteNode</span> <span class="hljs-operator">=</span> listNode.next;<br>        listNode.next = deleteNode.next;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="综合删除"><a href="#综合删除" class="headerlink" title="综合删除"></a>综合删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">deletePosition</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> position)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-comment">// 链表为空</span><br>       <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br><br>       <span class="hljs-comment">// 判断界限</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">listNodeLength</span> <span class="hljs-operator">=</span> getListNodeLength(head);<br>       <span class="hljs-comment">// 这里不需要判断listNodeLength+1，因为下面已经记录了删除元素的前一个节点，和删除节点的下一个节点存不存在没有关系</span><br>       <span class="hljs-keyword">if</span> (position &gt; listNodeLength || position &lt; <span class="hljs-number">1</span>) &#123;<br>           System.out.println(<span class="hljs-string">&quot;超过界限&quot;</span>);<br>           <span class="hljs-keyword">return</span> head;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) &#123;<br>           listNode = listNode.next;<br>           head = listNode;<br>           <span class="hljs-keyword">return</span> head;<br>       &#125;<br><br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span> (count &lt; position - <span class="hljs-number">1</span>) &#123;<br>           preNode = preNode.next;<br>           count++;<br>       &#125;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">deleteNode</span> <span class="hljs-operator">=</span> preNode.next;<br>       preNode.next = deleteNode.next;<br>       <span class="hljs-keyword">return</span> head;<br><br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2. 双向链表"></a>2. 双向链表</h1><h2 id="1-双向链表的建立"><a href="#1-双向链表的建立" class="headerlink" title="1. 双向链表的建立"></a>1. 双向链表的建立</h2><p>单链表只能获取自己的后一个节点的元素，而双向链表里面有两个指针，可以获取前后节点<br><img src="/images/img_10.png" alt="img_10.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleListNode</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    DoubleListNode preNode;<br>    DoubleListNode nextNode;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value, DoubleListNode preNode, DoubleListNode nextNode)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.preNode = preNode;<br>        <span class="hljs-built_in">this</span>.nextNode = nextNode;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleListNode</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleListNode</span><span class="hljs-params">(DoubleListNode preNode)</span> &#123;<br>        <span class="hljs-built_in">this</span>.preNode = preNode;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleListNode</span><span class="hljs-params">(DoubleListNode preNode, DoubleListNode nextNode)</span> &#123;<br>        <span class="hljs-built_in">this</span>.preNode = preNode;<br>        <span class="hljs-built_in">this</span>.nextNode = nextNode;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 展示数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayNode</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;&#123;&quot;</span> + value + <span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>数据准备</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">doubleListNode1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleListNode</span>(<span class="hljs-number">1</span>);<br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">doubleListNode2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleListNode</span>(<span class="hljs-number">2</span>);<br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">doubleListNode3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleListNode</span>(<span class="hljs-number">3</span>);<br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">doubleListNode4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleListNode</span>(<span class="hljs-number">5</span>);<br>       doubleListNode1.nextNode = doubleListNode2;<br>       doubleListNode2.preNode = doubleListNode1;<br>       doubleListNode2.nextNode = doubleListNode3;<br>       doubleListNode3.preNode = doubleListNode2;<br>       doubleListNode3.nextNode = doubleListNode4;<br>       doubleListNode4.preNode = doubleListNode3;<br></code></pre></td></tr></table></figure><h2 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2. 遍历"></a>2. 遍历</h2><h3 id="2-1-头部遍历"><a href="#2-1-头部遍历" class="headerlink" title="2.1 头部遍历"></a>2.1 头部遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayDoubleNodeFromHead</span><span class="hljs-params">(DoubleListNode head)</span> &#123;<br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>       <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">// 展示</span><br>           current.displayNode();<br>           current = current.nextNode;<br>       &#125;<br>       System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-尾部遍历"><a href="#2-2-尾部遍历" class="headerlink" title="2.2 尾部遍历"></a>2.2 尾部遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayDoubleNodeFromTail</span><span class="hljs-params">(DoubleListNode tail)</span> &#123;<br>    <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>        current.displayNode();<br>        current = current.preNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面的tail记住选最后一个节点</p><h2 id="3-插入数据"><a href="#3-插入数据" class="headerlink" title="3 插入数据"></a>3 插入数据</h2><h3 id="3-1-头部插入"><a href="#3-1-头部插入" class="headerlink" title="3.1 头部插入"></a>3.1 头部插入</h3><p><img src="/images/img_12.png" alt="img_12.png"><br>只需要将新建节点的next指向原来的head，将原来的head的pre指向新建节点，head改变即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleListNode <span class="hljs-title function_">insetIntoNodeHead</span><span class="hljs-params">(DoubleListNode head, DoubleListNode newNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br>    newNode.nextNode = head;<br>    head.preNode = newNode;<br>    head = newNode;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-尾部插入"><a href="#3-2-尾部插入" class="headerlink" title="3.2 尾部插入"></a>3.2 尾部插入</h3><p><img src="/images/img_13.png" alt="img_13.png"><br>只需要将tail节点的next指向新建节点，新建节点的pre指向tail节点，tail改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleListNode <span class="hljs-title function_">insetIntoNodeTail</span><span class="hljs-params">(DoubleListNode tail, DoubleListNode newNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tail == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br>    tail.nextNode = newNode;<br>    newNode.preNode = tail;<br>    tail = newNode;<br>    <span class="hljs-keyword">return</span> tail;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-指定位置插入-1"><a href="#3-3-指定位置插入-1" class="headerlink" title="3.3 指定位置插入"></a>3.3 指定位置插入</h3><p><img src="/images/img_14.png" alt="img_14.png"></p><p>这个就有点麻烦，需要改动四个指针，还需要考虑第一个和最后一个节点的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleListNode <span class="hljs-title function_">insetIntoNodeByPosition</span><span class="hljs-params">(DoubleListNode head, DoubleListNode newNode, <span class="hljs-type">int</span> position)</span> &#123;<br>       <span class="hljs-comment">// 空节点</span><br>       <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> newNode;<br>       &#125;<br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br><br>       <span class="hljs-comment">// 头节点</span><br>       <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) &#123;<br>           newNode.nextNode = head;<br>           head.preNode = newNode;<br>           <span class="hljs-keyword">return</span> newNode;<br>       &#125;<br><br><br>       <span class="hljs-comment">// 计算处添加节点的前一个节点</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span> (count &lt; position - <span class="hljs-number">2</span> &amp;&amp; current.nextNode != <span class="hljs-literal">null</span>) &#123;<br>           current = current.nextNode;<br>           count++;<br>       &#125;<br><br>       <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> current.nextNode;<br>       <span class="hljs-keyword">if</span> (nextNode != <span class="hljs-literal">null</span>) &#123;<br>           nextNode.preNode = newNode;<br>           newNode.nextNode = nextNode;<br>       &#125;<br><br>       current.nextNode = newNode;<br>       newNode.preNode = current;<br><br>       <span class="hljs-keyword">return</span> head;<br>   &#125;<br></code></pre></td></tr></table></figure><p>注意这里需要将新的链表传递给展示的方法才能展示新的链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">doubleListNode</span> <span class="hljs-operator">=</span> insetIntoNodeByPosition(doubleListNode1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleListNode</span>(<span class="hljs-number">4</span>), <span class="hljs-number">4</span>);<br>displayDoubleNodeFromHead(doubleListNode);<br></code></pre></td></tr></table></figure><h2 id="4-删除元素-1"><a href="#4-删除元素-1" class="headerlink" title="4. 删除元素"></a>4. 删除元素</h2><h3 id="4-1-删除头节点"><a href="#4-1-删除头节点" class="headerlink" title="4.1 删除头节点"></a>4.1 删除头节点</h3><p><img src="/images/img_15.png" alt="img_15.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(DoubleListNode head, <span class="hljs-type">int</span> position)</span> &#123;<br>        <span class="hljs-comment">// 头节点不存在</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 删除头节点</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> current.nextNode;<br>            nextNode.preNode = <span class="hljs-literal">null</span>;<br>            head = nextNode;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br><span class="hljs-comment">// 找到指定位置的节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (count &lt; position &amp;&amp; current != <span class="hljs-literal">null</span>) &#123;<br>            current = current.nextNode;<br>            count++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">prevNode</span> <span class="hljs-operator">=</span> current.preNode;<br>            <span class="hljs-type">DoubleListNode</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> current.nextNode;<br><br>            <span class="hljs-keyword">if</span> (prevNode != <span class="hljs-literal">null</span>) &#123;<br>                prevNode.nextNode = nextNode;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (nextNode != <span class="hljs-literal">null</span>) &#123;<br>                nextNode.preNode = prevNode;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 当前节点是最后一个节点</span><br>                prevNode.nextNode = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>双向链表的插入和删除相对较为繁琐，但是步骤很简单，自己多画一些图就能理解。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/flybase1/AlgorithmPrtojects">https://github.com/flybase1/AlgorithmPrtojects</a></p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>里面部分代码还是可能有些问题，希望大家能够指出其中的错误，共同进步。<br>由于部分链接图片无法显示，可移步<a href="http://t.csdn.cn/bZbuS">http://t.csdn.cn/bZbuS</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Stable Diffusion</title>
      <link href="/post/5b798e2f.html"/>
      <url>/post/5b798e2f.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-为什么要使用Kaggle"><a href="#1-为什么要使用Kaggle" class="headerlink" title="1. 为什么要使用Kaggle"></a>1. 为什么要使用Kaggle</h2><p>优点：提供免费的GPU，每周有30个小时的免费使用，不使用的时候就关闭，完全足够使用<br>缺点：优点难以上手，原本是机器学习竞赛平台等等，需要特殊网络</p><h2 id="2-注册"><a href="#2-注册" class="headerlink" title="2. 注册"></a>2. 注册</h2><p><a href="https://www.kaggle.com/">https://www.kaggle.com/</a><br>这里可以选择自己需要的方式进行注册</p><h2 id="3-运行模型"><a href="#3-运行模型" class="headerlink" title="3. 运行模型"></a>3. 运行模型</h2><p>在主界面搜索zh-stable-diffusion-webui-kaggle<br>点击右上角Edit My Copy<br>选择右边Notebook options里面有个Get phone verified（手机验证，使用国内的手机可以接受验证码）<br>选择Notebook options的INTERNET，点击开启Internet on<br>点击Notebook options的ACCELERATOR，选择GPU T4✖2<br>点击中间的电源开机键<br>点击左边的三角运行<br>等待部署<br>最后应该能够看见Running on public URL: <a href="https://538e8529-d008-470d.gradio.live,点击地址运行即可/">https://538e8529-d008-470d.gradio.live，点击地址运行即可</a><br><img src="http://cdn.flycode.icu/img/202307152036274.png" alt="image-20230715203012967"></p><p>个人使用效果地址<br><a href="https://blog.csdn.net/qq_52843958/article/details/131743019">https://blog.csdn.net/qq_52843958/article/details/131743019</a></p><h2 id="4-谨记"><a href="#4-谨记" class="headerlink" title="4. 谨记"></a>4. 谨记</h2><p>不使用了就关闭</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI绘画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试题基础-5</title>
      <link href="/post/dc612634.html"/>
      <url>/post/dc612634.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是BIO-Block"><a href="#1-什么是BIO-Block" class="headerlink" title="1. 什么是BIO(Block)"></a>1. 什么是BIO(Block)</h2><p>同步阻塞模型，当应用程序调用一次read之后，会一直阻塞，直到内核完全将数据拷贝到用户空间<br>缺点：并发场景不适用。<br><a href="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/5acc17a26b49bf261766ab89eb804690.png&sign=d873806d567370a5adeee9111b49dfe7f0be99d2f86f0cd9e1bbcaf9e564475d">https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F5acc17a26b49bf261766ab89eb804690.png&amp;sign=d873806d567370a5adeee9111b49dfe7f0be99d2f86f0cd9e1bbcaf9e564475d</a></p><h2 id="2-什么是NIO（Non-block）"><a href="#2-什么是NIO（Non-block）" class="headerlink" title="2. 什么是NIO（Non-block）"></a>2. 什么是NIO（Non-block）</h2><p>同步非阻塞模型，返回调用read，让内核准备数据，等待数据从内核空间完全拷贝到用户空间这个时间，线程依然阻塞，直到内核完全把数据拷贝到用户空间。<br>优点：通过轮询避免阻塞<br>缺点：不停的调用模型，耗费CPU性能</p><h2 id="3-IO多路复用"><a href="#3-IO多路复用" class="headerlink" title="3. IO多路复用"></a>3. IO多路复用</h2><p>应用程序的线程首先发起select调用，询问内核是否准备成功ready，成功就发起read调用，等待数据从内核完全拷贝到用户空间，但是拷贝的过程还是阻塞的。<br>有带你：解决了NIO一直轮询耗费资源的情况。</p><h2 id="4-AIO"><a href="#4-AIO" class="headerlink" title="4. AIO"></a>4. AIO</h2><p>异步IO<br>应用调用之后会立即返回，而不是等待，直到任务成功发起回调</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试题基础-4</title>
      <link href="/post/ae0811d8.html"/>
      <url>/post/ae0811d8.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-ReentrantLock是什么？"><a href="#1-ReentrantLock是什么？" class="headerlink" title="1. ReentrantLock是什么？"></a>1. ReentrantLock是什么？</h2><p>   可重入独占式的锁，比synchronized更加灵活，增加了超时，轮询，中断，公平锁（先申请的先获取锁），非公平锁(随机或者有 相应的顺序)。</p><h2 id="2-ThreadLocal是什么？原理？"><a href="#2-ThreadLocal是什么？原理？" class="headerlink" title="2. ThreadLocal是什么？原理？"></a>2. ThreadLocal是什么？原理？</h2><p>可以让每个线程都有自己的本地变量<br>set源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br><span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>map.set(<span class="hljs-built_in">this</span>, value);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>createMap(t, value);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终的变量是存放了ThreadLocalMap里面，而不是ThreadLocal。每一个Thread都具备一个ThreadLocalMap，而ThreadLocalMap可以存放ThreadLocal为key，Object对象为Value的值。</p><h2 id="3-ThreadLocal内存泄漏"><a href="#3-ThreadLocal内存泄漏" class="headerlink" title="3. ThreadLocal内存泄漏"></a>3. ThreadLocal内存泄漏</h2><p>由于ThreadLocalMap里面的key是弱引用，而value是强引用，所以垃圾回收的时候会将key清除，而value保存，最终会导致一个key为null的Enrty，产生内存泄露。<br>解决方法：手动调用remove方法。</p><h2 id="4-什么是线程池？线程池的作用？如何创建线程池？"><a href="#4-什么是线程池？线程池的作用？如何创建线程池？" class="headerlink" title="4. 什么是线程池？线程池的作用？如何创建线程池？"></a>4. 什么是线程池？线程池的作用？如何创建线程池？</h2><p>管理一系列线程的资源池。当有任务需要处理，直接从线程池取出线程，当任务结束后，线程不会销毁，而是可以等待下一个任务。<br>好处：</p><ol><li>降低资源消耗：重复使用已经创建的线程</li><li>提高响应速度：任务不需要等待线程创建，直接执行。</li><li>提高线程的可管理性：统一分配，调优，监控</li></ol><p>创建线程池：</p><ol><li>ThreadPoolExecutor创建</li><li>Executor框架创建（不推荐）</li></ol><h2 id="5-为什么不推荐使用Executor创建线程池"><a href="#5-为什么不推荐使用Executor创建线程池" class="headerlink" title="5. 为什么不推荐使用Executor创建线程池"></a>5. 为什么不推荐使用Executor创建线程池</h2><p>FixedThreadPool 和SingleThreadExecutor：使用的时无界的LinkedBlockingQueue，队列长度时Integer最大值，可能会导致OOM。<br>CachedThreadPool：SynchronousQueue可能会创建多个请求，最大值是Integer的最大值，会造成OOM<br>ScheduledThreadPool和SingleThreadScheduledExecutor : 无界延迟队列。堆积请求OOM</p><h2 id="6-线程池重要参数"><a href="#6-线程池重要参数" class="headerlink" title="6. 线程池重要参数"></a>6. 线程池重要参数</h2><h2 id="7-线程池饱和策略"><a href="#7-线程池饱和策略" class="headerlink" title="7. 线程池饱和策略"></a>7. 线程池饱和策略</h2><ol><li>拒绝新任务的处理</li><li>调用自己的线程执行任务</li><li>丢弃任务</li><li>丢弃最早未被处理的任务</li></ol><h2 id="8-线程池处理任务的流程"><a href="#8-线程池处理任务的流程" class="headerlink" title="8. 线程池处理任务的流程"></a>8. 线程池处理任务的流程</h2><ol><li>任务进来后，判断当前运行的线程数是否小于核心线程数，如果小于，直接调用新的核心线程来处理任务</li><li>如果运行线程数已经等于核心线程数，接下来新的任务会放入工作队列里面，接下来判断任务队列是否满了，如果任务队列没有满，继续添加任务队列里面去。</li><li>如果任务队列满了，新建一个线程来处理任务。判断运行的线程数是否满足等于最大线程数，如果小于，继续从工作队列里面取出任务处理。</li><li>如果线程数等于最大线程数，并且任务队列也满了，接下来就是使用饱和策略，来拒绝任务或者丢去任务。</li></ol><h2 id="9-如何设置线程池大小"><a href="#9-如何设置线程池大小" class="headerlink" title="9. 如何设置线程池大小"></a>9. 如何设置线程池大小</h2><ol><li>CPU密集型：消耗CPU资源，一般是采取CPU核数+1</li><li>IO密集型：主要是设计网络传输，文件读取，一般是设置为2n</li></ol><h2 id="10-什么是AQS？原理是什么？什么是CLH锁？"><a href="#10-什么是AQS？原理是什么？什么是CLH锁？" class="headerlink" title="10. 什么是AQS？原理是什么？什么是CLH锁？"></a>10. 什么是AQS？原理是什么？什么是CLH锁？</h2><p>抽象队列同步器，是在locks里面，主要是构建锁和同步器。例如ReentrantLock等等。<br>原理：如果请求的共享资源空闲，那么当前请求资源的线程就设置为有效的工作线程，并且将共享资源设置为锁定状态。如果请求的资源被占用，需要一套线程阻塞以及被唤醒时锁的分配机制，AQS采用CLH队列所实现的，暂时获取不到锁的线程就加入队列中去。<br>CLH：虚拟的双向队列。AQS将每条请求共享资源的线程分装成一个CLH锁队列的节点来实现所得分配、CLH同步队列，一个节点表示一个线程，保存着现成的引用，当前节点状态，前驱后继。</p><h2 id="11-什么是Semaphore-应用场景？"><a href="#11-什么是Semaphore-应用场景？" class="headerlink" title="11. 什么是Semaphore?应用场景？"></a>11. 什么是Semaphore?应用场景？</h2><p>synchronized和reentrantLock都时一次只允许一个线程访问某个资源，semaphore可以同时控制多个线程访问资源。<br>场景：有明确访问数量限制的场景比如限流，但是一般推荐redis+lua限流</p><h2 id="12-Semaphore原理"><a href="#12-Semaphore原理" class="headerlink" title="12. Semaphore原理"></a>12. Semaphore原理</h2><p>共享锁的一种实现，默认构造的AQS的state值为permits，可以将permits的值理解为许可证的数量，只有拿到许可证的线程才能执行</p><h2 id="13-什么是CountDownLatch-原理是什么？"><a href="#13-什么是CountDownLatch-原理是什么？" class="headerlink" title="13. 什么是CountDownLatch?原理是什么？"></a>13. 什么是CountDownLatch?原理是什么？</h2><p>允许count值的数量的线程同时阻塞在一个地方，直到所有的线程的任务都执行完毕。但是这个count再初始化的时候只能执行一次，使用完毕后就不能使用？<br>原理：共享锁的实现，里面是AQS的state设置为count</p><h2 id="14-CountDownLatch应用场景？"><a href="#14-CountDownLatch应用场景？" class="headerlink" title="14. CountDownLatch应用场景？"></a>14. CountDownLatch应用场景？</h2><p>使用多线程读取多个文件处理的场景</p><h2 id="15-CyclicBarrier-是什么？"><a href="#15-CyclicBarrier-是什么？" class="headerlink" title="15. CyclicBarrier 是什么？"></a>15. CyclicBarrier 是什么？</h2><p>和CountDownLatch非常类似，可以实现线程之间的技术等待，功能更加复杂。主要是将所有的线程都放置在一个屏障外面阻塞，当最后一个线程到达才开启屏障，线程才能继续干活。<br>基于ReentrantLock(基于AQS），CountDownLatch基于AQS。</p><h2 id="16-并发3大特性"><a href="#16-并发3大特性" class="headerlink" title="16. 并发3大特性"></a>16. 并发3大特性</h2><ol><li>原子性：所有操作，要么都执行，要么都不执行。</li><li>可见性：当一个线程修改了共享变量的值，其余线程都能看见</li><li>有序性：volatile禁止指令排序，指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</li></ol><h2 id="17-什么是JMM？为什么需要JMM？"><a href="#17-什么是JMM？为什么需要JMM？" class="headerlink" title="17. 什么是JMM？为什么需要JMM？"></a>17. 什么是JMM？为什么需要JMM？</h2><p>JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试题基础-3</title>
      <link href="/post/e95b42b1.html"/>
      <url>/post/e95b42b1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程和进程是什么？之间的关系，区别，优缺点？"><a href="#1-线程和进程是什么？之间的关系，区别，优缺点？" class="headerlink" title="1. 线程和进程是什么？之间的关系，区别，优缺点？"></a>1. 线程和进程是什么？之间的关系，区别，优缺点？</h2><p><strong>进程</strong>：进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。<br><strong>线程</strong>：是一个比进程更小的执行单位 线程时进程划分为更小的运行单位。 线程和进程最大的不同在于进程之间基本上不会相互影响，但是线程不一样，同一个进程里面的线程可能会相互影响。<br>线程执行开销小，不利于资源的管理维护。<br>线程拥有自己的<strong>本地方法栈</strong>，<strong>虚拟机栈</strong>和<strong>程序计数器</strong>，共用<strong>方法区</strong>和<strong>堆</strong>。</p><h2 id="2-为什么要使用多线程？"><a href="#2-为什么要使用多线程？" class="headerlink" title="2. 为什么要使用多线程？"></a>2. 为什么要使用多线程？</h2><ol><li>计算机角度：充分利用多核cpu的功能</li><li>项目角度：提升系统的性能</li></ol><h2 id="3-说说线程的生命周期和状态"><a href="#3-说说线程的生命周期和状态" class="headerlink" title="3. 说说线程的生命周期和状态"></a>3. 说说线程的生命周期和状态</h2><ul><li>NEW：初始状态，未执行start()方法。</li><li>RUNNABLE:  运行状态，执行了start（）方法。</li><li>BLOCKED：阻塞状态，等待锁被释放。</li><li>WAITING：等待状态，等待通知。</li><li>TIME_WAITING:  超时等待状态，指定时间后直接返回。</li><li>TERMINATED：终止状态，表示程序已经运行完毕。<br><a href="https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w">https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w</a></li></ul><h2 id="4-什么是线程死锁？如何预防和避免死锁？"><a href="#4-什么是线程死锁？如何预防和避免死锁？" class="headerlink" title="4. 什么是线程死锁？如何预防和避免死锁？"></a>4. 什么是线程死锁？如何预防和避免死锁？</h2><p>线程死锁：多个线程处于阻塞状态，他们都在等待一个或者多个资源被释放，线程无限等待。 例如 线程1持有资源1，线程2持有资源2，它们都想获取对方的资源。<br><strong>产生条件</strong>：</p><ul><li>互斥条件：该资源任意时刻都被一个线程占有。</li><li>请求与保持：线程请求资源阻塞，对已有资源不释放</li><li>不剥夺条件：线程占有的资源未被使用完成释放前，不能被其他线程所强行剥夺</li><li>循环等待：若干线程之间循环等待资源</li></ul><p><strong>避免死锁</strong>：</p><ul><li>银行家算法等资源分配计算评估，进入安全状态</li></ul><h2 id="5-sleep和wait区别"><a href="#5-sleep和wait区别" class="headerlink" title="5. sleep和wait区别"></a>5. sleep和wait区别</h2><ol><li>sleep方法不能释放锁，而wait能释放锁。</li><li>sleep只是用于暂停当前线程运行，而wait是用于线程之间交互。</li><li>sleep调用后，线程能够自己唤醒，而wait必须要其他线程使用notify(),notifyAll(),进行唤醒。</li><li>sleep是Thread的本地方法，而wait是Object的本地方法。</li></ol><h2 id="6-可以直接调用Thread的run方法吗？"><a href="#6-可以直接调用Thread的run方法吗？" class="headerlink" title="6. 可以直接调用Thread的run方法吗？"></a>6. 可以直接调用Thread的run方法吗？</h2><p>new Thread()后，线程进入新建状态，当调用start方法，线程进入就绪状态，当分配到时间片后才开始执行，调用run方法，这才是多线程。而直接调用run方法，只是让当前线程在main线程下执行一个普通方法。</p><h2 id="7-volatile关键字"><a href="#7-volatile关键字" class="headerlink" title="7. volatile关键字"></a>7. volatile关键字</h2><ol><li>保证变量的可见性，这个变量是共享的且不稳定，每次都要从主存里面进行读取。</li><li>防止JVM重排序，使用内存屏障</li><li>不能保证对变量的操作时原子性</li></ol><h2 id="8-乐观锁和悲观锁的区别"><a href="#8-乐观锁和悲观锁的区别" class="headerlink" title="8. 乐观锁和悲观锁的区别"></a>8. 乐观锁和悲观锁的区别</h2><p><strong>悲观锁</strong>：认为每次共享资源总是会出现问题（数据修改），每次操作数据都会加上锁。共享资源每次只给一个线程使用，其他线程阻塞，用完后转换给其他线程。 问题：高并发，锁竞争造成线程阻塞；死锁。 场景：写比较多<br><strong>乐观锁</strong>：认为共享资源的访问一定是没有问题的，线程可以不停的执行，不需要加锁，只需要将最后提交的时候验证是否被其他线程修改了。 问题：没有锁，但是会有需要重试失败问题，影响性能。 场景：多读场景</p><h2 id="9-如何实现乐观锁"><a href="#9-如何实现乐观锁" class="headerlink" title="9. 如何实现乐观锁"></a>9. 如何实现乐观锁</h2><p>版本号机制：数据库增加字段version，进行比对version是否一样。<br>CAS算法：预期值与要更新的变量比较。（原子操作，一旦开始就不能打断）</p><h2 id="10-CAS算法"><a href="#10-CAS算法" class="headerlink" title="10. CAS算法"></a>10. CAS算法</h2><ul><li>E 预期的值</li><li>V 要更新的值</li><li>N 写入的新值 只有V&#x3D;E，CAS才会将N的值更新到V的值、不等就说明有线程参与操作，放弃。</li></ul><p>CAS在ConcurrentHashMap里面和synchronized保证并发安全<br>concurrent.atomic包中的类通过volatile+CAS 重试保证线程安全性</p><h2 id="11-乐观锁的问题"><a href="#11-乐观锁的问题" class="headerlink" title="11. 乐观锁的问题"></a>11. 乐观锁的问题</h2><ol><li>ABA：当要修改一个值是A的时候，其他线程然后改造成了B，但是在修改前又改成了A。解决方案是加上版本号&#x2F;时间戳</li><li>循环开销大：长时间使用CAS自旋来重试知道成功</li><li>只能保证一个共享变量的操作：AtomicReference使用对象进行CAS操作解决问题。</li></ol><h2 id="12-synchronized"><a href="#12-synchronized" class="headerlink" title="12. synchronized"></a>12. synchronized</h2><p>java的关键字，目的是解决多个线程之间访问资源的的同步性，可以保证被它修饰的方法或者代码块任意时刻只有一个线程执行。 使用：</p><ol><li>修饰实例方法（锁示例）</li><li>修饰静态方法（锁当前类）</li><li>修饰代码块（锁指定对象&#x2F;类） 不需要使用synchronized 关键字修饰构造方法，本身就是安全的。</li></ol><h2 id="13-synchronized底层原理"><a href="#13-synchronized底层原理" class="headerlink" title="13. synchronized底层原理"></a>13. synchronized底层原理</h2><p>同步语句块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSynchronized</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span> &#123;<br><span class="hljs-type">TestSynchronized</span> <span class="hljs-variable">testSynchronized</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">TestSynchronized</span>();<br>testSynchronized.method();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;synchronized 代码块&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javap -c -s -v -l TestSynchronized.class<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>descriptor: ()V<br>flags: ACC_PUBLIC<br>Code:<br>stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br><span class="hljs-number">0</span>: aload_0<br><span class="hljs-number">1</span>: dup<br><span class="hljs-number">2</span>: astore_1<br><span class="hljs-number">3</span>: monitorenter<br><span class="hljs-number">4</span>: getstatic     #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="hljs-number">7</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String synchronized 代码块</span><br><span class="hljs-number">9</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="hljs-number">12</span>: aload_1<br><span class="hljs-number">13</span>: monitorexit<br><span class="hljs-number">14</span>: goto          <span class="hljs-number">22</span><br><span class="hljs-number">17</span>: astore_2<br><span class="hljs-number">18</span>: aload_1<br><span class="hljs-number">19</span>: monitorexit<br><span class="hljs-number">20</span>: aload_2<br><span class="hljs-number">21</span>: athrow<br><span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>Exception table:<br>from    to  target type<br><span class="hljs-number">4</span>    <span class="hljs-number">14</span>    <span class="hljs-number">17</span>   any<br><span class="hljs-number">17</span>    <span class="hljs-number">20</span>    <span class="hljs-number">17</span>   any<br>LineNumberTable:<br>line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>line <span class="hljs-number">9</span>: <span class="hljs-number">4</span><br>line <span class="hljs-number">10</span>: <span class="hljs-number">12</span><br>line <span class="hljs-number">11</span>: <span class="hljs-number">22</span><br>LocalVariableTable:<br>Start  Length  Slot  Name   Signature<br><span class="hljs-number">0</span>      <span class="hljs-number">23</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   LTestSynchronized;<br>StackMapTable: number_of_entries = <span class="hljs-number">2</span><br>frame_type = <span class="hljs-number">255</span> <span class="hljs-comment">/* full_frame */</span><br>offset_delta = <span class="hljs-number">17</span><br>locals = [ <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSynchronized</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>/lang/Object ]<br>stack = [ <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>/lang/Throwable ]<br>frame_type = <span class="hljs-number">250</span> <span class="hljs-comment">/* chop */</span><br>offset_delta = <span class="hljs-number">4</span><br>&#125;<br>SourceFile: <span class="hljs-string">&quot;TestSynchronized.java&quot;</span><br></code></pre></td></tr></table></figure><p>开始-&gt;monitorenter-&gt;锁计数器是否为0-&gt;是，锁计数器+1，获取锁成功-&gt;结束<br>开始-&gt;monitorexit-&gt;是否为当前锁的拥有者-&gt;是，锁计数器-1，释放锁-&gt;结束<br>同步语句块使用的是monitorenter（开始位置）和monitorexit（结束位置）<br>但是同步方法使用的是ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。</p><h2 id="14-synchronized-底层优化（1-6）"><a href="#14-synchronized-底层优化（1-6）" class="headerlink" title="14. synchronized 底层优化（1.6）"></a>14. synchronized 底层优化（1.6）</h2><p>加入了自旋锁，适应性自旋锁，锁消除，轻量级锁等待<br>主要四种状态：轻量级锁，重量级锁，无锁状态，偏向锁状态<br>锁可以升级但是不可以降级，主要是提高获得锁和释放锁的效率。</p><h2 id="15-synchronized-和volatile区别"><a href="#15-synchronized-和volatile区别" class="headerlink" title="15. synchronized 和volatile区别"></a>15. synchronized 和volatile区别</h2><ol><li>volatile线程同步的轻量级实现，性能好。</li><li>volatile只能修饰变量，但是synchronized 可以修饰实例，静态，代码块方法</li><li>volatile实现了数据可见性，但是不能保证数据操作原子性。而synchronized 两者都实现。</li><li>volatile实现了多线程之间的可见性，synchronized 多个线程访问资源的同步性</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试题基础-2</title>
      <link href="/post/b4617fdb.html"/>
      <url>/post/b4617fdb.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-List，Set，Queue，Map区别"><a href="#1-List，Set，Queue，Map区别" class="headerlink" title="1. List，Set，Queue，Map区别"></a>1. List，Set，Queue，Map区别</h2><ul><li><p>List: 元素存储是有序的，可以重复的。</p></li><li><p>Set: 元素存储是无序的，不可以重复。</p></li><li><p>Queue：元素存取满足先进先出顺序，元素可重复，有序。</p></li><li><p>Map：key-value键值对，key是不可重复的，无序的，但是value可以重复，无序的</p></li></ul><h2 id="2-ArrayList和LinkedList区别"><a href="#2-ArrayList和LinkedList区别" class="headerlink" title="2. ArrayList和LinkedList区别"></a>2. ArrayList和LinkedList区别</h2><ul><li><p>线程安全：两者都不能保证</p></li><li><p>底层数据结构：ArrayList底层是动态数据，LinkedList底层是双向链表</p></li><li><p>随机访问：ArrayList底层数动态数组，可以根据元素的下标来获取元素对象，实现了RamdomAccess接口（标识），因为内存地址是连续的，而LinedList没有实现接口，无法随机访问。</p></li><li><p>插入删除：</p><ul><li><p>ArrayList底层是动态数组，插入和删除受到元素位置的影响，比如add方法是在尾部插入元素，时间复杂度是O(1)。如果是插入指定位置，时间复杂度是O（n）</p></li><li><p>LinedList是双向链表，无论是插入头部或者尾部，时间复杂度都是O(1),但是指定位置插入时间复杂度是O(n),需要找到插入元素的位置。</p></li></ul></li><li><p>内存空间占用： ArrayList的列表结尾会预留一定的空间，而LinedList空间主要耗费在记录元素的前驱后继和数据</p></li></ul><h2 id="3-ArrayList扩容机制"><a href="#3-ArrayList扩容机制" class="headerlink" title="3. ArrayList扩容机制"></a>3. ArrayList扩容机制</h2><ol><li>添加元素add方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <br>elementData[size++] = e;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>里面调用了ensureCapacityInternal方法</p><ol start="2"><li>ensureCapacityInternal</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>调用了calculateCapacity</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>ensureExplicitCapacity</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br><br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>grow</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br><span class="hljs-comment">// overflow-conscious code</span><br><span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>    newCapacity = minCapacity;<br><span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>    newCapacity = hugeCapacity(minCapacity);<br><span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><p>第一个元素添加进入ArrayList，elementData.length是0，执行了ensureCapacityInternal方法，所以目前的容量minCapacity是10，minCapacity-elementData.length&gt;0 满足条件执行grow方法</p></li><li><p>第二个元素进入，minCapacity&#x3D;2，elementData.length扩容为10，不会执行grow方法。</p></li><li><p>添加第11元素，minCapacity&#x3D;11，满足grow方法，进行扩容，intnewCapacity&#x3D;oldCapacity+(oldCapacity&gt;&gt;1);，扩容为1.5倍数</p></li></ul><h2 id="4-HashSet，LinkedHashSet，TreeSet区别"><a href="#4-HashSet，LinkedHashSet，TreeSet区别" class="headerlink" title="4. HashSet，LinkedHashSet，TreeSet区别"></a>4. HashSet，LinkedHashSet，TreeSet区别</h2><p>底层：都是set的实现方式</p><p>线程安全：都不安全</p><p>数据结构：HashSet底层是哈希表，LinkedHashSet底层是链表，TreeSet底层是红黑树</p><p>应用场景：HashSet适用于不需要保证元素的插入和取出的顺序。LinkedHashSet保证元素的存入和取出满足先进先出的顺序。 TreeSet满足需要进行自定义排序场景</p><h2 id="5-Queue和Deque区别"><a href="#5-Queue和Deque区别" class="headerlink" title="5. Queue和Deque区别"></a>5. Queue和Deque区别</h2><p>Queue：单端队列，满足先进先出，只能从一段插入元素，另一端删除元素。</p><p>Deque：双端队列，队列两端都可以插入删除元素。</p><h2 id="6-ArrayDeque和LinkedList区别"><a href="#6-ArrayDeque和LinkedList区别" class="headerlink" title="6. ArrayDeque和LinkedList区别"></a>6. ArrayDeque和LinkedList区别</h2><p>两者都能实现队列功能</p><p>底层数据结构：ArrayDeque底层是可变数组和指针。LinkedList底层是链表。</p><p>存储null数据：ArrayDeque不可以存储元素为null的。LinkedList可以。</p><p>内存占用：ArrayDeque可能会存在扩容，但是均摊过后时间复杂度为O(1).LinkedList不需要扩容，但是每次插入元素都需要申请新的堆空间，性能相对较慢。</p><h2 id="7-PriorityQueue"><a href="#7-PriorityQueue" class="headerlink" title="7. PriorityQueue"></a>7. PriorityQueue</h2><p>PriorityQueue与Queue的主要区别在于元素的出队顺序，优先级高的元素先出队列。</p><p>PriorityQueue使用二叉树的数据结构实现的，底层是基于可变长的数组来存储数据</p><p>PriorityQueue通过堆元素的上浮和下沉，实现了O(nlogn)时间复杂度插入元素和删除栈顶元素。</p><p>PriorityQueue非线程安全，不支持存储数据为null。</p><p>PriorityQueue默认是小根堆，但是可以接受Comparator构造参数，自定义排列大小。</p><h2 id="8-HashMap底层实现"><a href="#8-HashMap底层实现" class="headerlink" title="8. HashMap底层实现"></a>8. HashMap底层实现</h2><p>1.8 之前</p><p>数组+链表&#x3D;&gt;链表散列。</p><p>数组链表</p><p>HashMap通过key的hashcode，经过扰动函数计算出hash值，然后再进行(n-1)&amp;hash来的带元素元素存储的位置，如果当前位置存在元素，判断该元素的hash以及key是否相同，相同就直接覆盖，不同就采用拉链法解决冲突。</p><p>1.8</p><p>数组+链表+红黑树</p><p>当链表长度大于阈值（8）（将链表转换为红黑树之前会判断当前数组长度是否超过64，没超过就会继续执行扩容）是，会将链表转换为红黑树，减少搜索时间。重点关注treebin()方法</p><p>9ConcurrentHashMap</p><p>1.8 与1.7有很大区别，不再是Segment数组+HashEntry数组+链表，而是采用了Node数组+链表+红黑树。当链表达到一定程度转换为红黑树。   </p><p><img src="img_2.jpg"></p><p>1 初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 如果sizeCtl&lt;0 表示另一个线程执行CAS成功，正在进行初化</span><br>            <br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>            <span class="hljs-comment">// 让出CPU使用权</span><br>            <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过自旋和CAS完成操作</p><p>sizeCtl：</p><p>-1：表示正在初始化</p><p>-N:表示有N-1个线程扩容</p><p>0：初始table大小</p><p>&gt;0: tabl扩容阈值</p><p>2 put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">// 计算key的hash所在位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        <span class="hljs-comment">// f是目标位置元素</span><br>        <span class="hljs-comment">// fh目标位置元素hash值</span><br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 是否初始化</span><br>            tab = initTable();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 使用CAS自旋写入，成功break跳出</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">//链表</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        <span class="hljs-comment">// 红黑树</span><br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                              value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>●通过key计算出hashcode</p><p>●判断是否初始化</p><p>●通过key定位处Node，为空表示可以写入数据，利用CAS尝试写入，失败就自旋保证成功</p><p>●当前位置hashcode&#x3D;&#x3D;MOVED&#x3D;-1,需要扩容</p><p>●不满足,synchronized锁写入数据</p><p>●当数据大于TREEIFY_THRESHOLD执行树化方法，在 treeifyBin 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</p><p>3 get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br><span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br><span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;  (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>        <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>            <span class="hljs-keyword">return</span> e.val;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>            ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>            <span class="hljs-keyword">return</span> e.val;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>根据hash查找位置</p></li><li><p>查找指定位置，如果头节点就是需要找的，返回value</p></li><li><p>头节点hash小于0，表示正在扩容或者红黑数，查找</p></li><li><p>如果是链表，遍历。</p></li></ul><h2 id="10-HashMap和HashTable"><a href="#10-HashMap和HashTable" class="headerlink" title="10. HashMap和HashTable"></a>10. HashMap和HashTable</h2><ol><li><p>线程安全：HashMap线程不安全，HashTable线程安全，里面方法加了Synchronized锁</p></li><li><p>效率：由于HashTable里面加了锁，所以效率不高</p></li><li><p>底层：1.8之后HashMap采用数组+链表+红黑树，而HashTable没有这种结构</p></li><li><p>使用：HashMap常用，HashTable不怎么使用了</p></li><li><p>存值：HashMap可以存储key为null，value为null的值，但是HashTable不允许这样，报异常。</p></li><li><p>初始化：HashMap初始化容量是16，每次扩充都是2倍。HashTable默认是11，扩容是2n+1</p></li></ol><h2 id="11-HashTable和ConcurrentHashMap"><a href="#11-HashTable和ConcurrentHashMap" class="headerlink" title="11. HashTable和ConcurrentHashMap"></a>11. HashTable和ConcurrentHashMap</h2><ol><li><p>底层数据结构：1.8之前ConcurrentHashMap使用的是Segment数组+链表，1.8之后次啊用数组+链表+红黑树。HashTable底层数组+链表</p></li><li><p>实现线程方式：</p><ol><li><p>ConcurrentHasMap 1.8之前采用的Segment数组+链表，对桶数组进行了分割分段，每一把锁里面只锁一部分数据，避免多线程问题。</p></li><li><p>ConcurrentHashMap 1.8后采用Node数组+链表+红黑树，采用CAS自旋和synchronized进行写入数据。</p></li><li><p>HashTable：使用synchronized 来保证安全，因为都是使用的同一把锁，效率低下。</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试题基础-1</title>
      <link href="/post/d37fe596.html"/>
      <url>/post/d37fe596.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-JVM-JDK-JRE"><a href="#1-JVM-JDK-JRE" class="headerlink" title="1. JVM JDK JRE"></a>1. JVM JDK JRE</h2><p>JVM：运行java字节码的虚拟机。保证了可移植性。</p><p>JDK： 包含了所有的java sdk，提供给开发者使用，包含</p><ul><li><ul><li>JRE</li></ul></li><li>javac（编译java源码的编译器）</li><li>javap（反编译）</li><li>jdb（调试器）</li><li>javadoc（文档注释工具）</li><li>……</li></ul><p>JRE:  java运行时环境。</p><ul><li><ul><li>JVM</li></ul></li><li>Class Library（java基础类库）</li></ul><h2 id="2-java的基本数据类型"><a href="#2-java的基本数据类型" class="headerlink" title="2. java的基本数据类型"></a>2. java的基本数据类型</h2><p>数字类型：</p><ul><li><p>整数型</p></li><li><ul><li>byte,short,int,long</li></ul></li><li><p>浮点型</p></li><li><ul><li>double,float</li></ul></li></ul><p>字符型： char</p><p>布尔型：boolean</p><h2 id="3-基本类型和包装类型"><a href="#3-基本类型和包装类型" class="headerlink" title="3. 基本类型和包装类型"></a>3. 基本类型和包装类型</h2><ol><li><strong>用途</strong>:</li></ol><ul><li>包装类型可用于泛型。</li></ul><ol start="2"><li><strong>默认值</strong></li></ol><ul><li>基本数据类型都有自己的默认值</li><li>包装类型默认值时null</li></ul><ol start="3"><li><strong>存储方式</strong></li></ol><ul><li>包装类型属于对象，存放在java虚拟机的堆里面。</li><li>基本类型的局部变量存放在java虚拟机栈的局部变量表，而成员变量（未被statsic修饰）存放在java虚拟机的堆里面。</li></ul><ol start="4"><li><strong>内存空间</strong></li></ol><ul><li>基本数据类型占用内存小</li></ul><ol start="5"><li><strong>比较</strong></li></ol><ul><li>基本类型，&#x3D;&#x3D;表示值的比较</li><li>包装类型，&#x3D;&#x3D;表示内存地址的比较，判断相同使用equals</li></ul><h2 id="4-浮点数精度丢失"><a href="#4-浮点数精度丢失" class="headerlink" title="4. 浮点数精度丢失"></a>4. 浮点数精度丢失</h2><p>计算机底层是二进制的，宽度是有限的，不能表示一些长度位数过长的小数，帮小数的长度唱过一定范围的时候，计算机就会进行截取，导致数据丢失。</p><p>解决方案：BigDecimal</p><h2 id="5-抽象类和接口共同点和区别"><a href="#5-抽象类和接口共同点和区别" class="headerlink" title="5. 抽象类和接口共同点和区别"></a>5. 抽象类和接口共同点和区别</h2><p>共同点：</p><ol><li>都不能被实例化</li><li>都可以包含抽象方法</li></ol><p>不同点</p><ol><li>抽象类主要是代码复用，接口主要是对类的行为约束</li><li>一个类只能修饰一个类，但是可以实现多个接口</li><li>抽象类成员变量，可以子类重新定义赋值，但是接口类成员变量需要使用public static final修饰，不可以改变值，必须要有初始值</li></ol><h2 id="6-浅拷贝和深拷贝"><a href="#6-浅拷贝和深拷贝" class="headerlink" title="6. 浅拷贝和深拷贝"></a>6. 浅拷贝和深拷贝</h2><p>浅拷贝：会在堆上创建一个新对象。如果对象是引用类型，就会直接复制原对象的引用地址。如果不是引用类型，就会创建一个新对象，与原对象互不关联。</p><p>深拷贝：会在堆上创建一个新对象，完全复制原对象。两者不存在关联。</p><p><img src="http://cdn.flycode.icu/img/202307111641259.png"></p><h2 id="7-Object常见方法"><a href="#7-Object常见方法" class="headerlink" title="7. Object常见方法"></a>7. Object常见方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">toString()<br>clone()<br>equals(),hashcode()<br>wait(),wait(<span class="hljs-type">long</span> timeout),wait(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> <span class="hljs-title function_">nano</span><span class="hljs-params">(额外时间)</span>),notify(),notifyAll()<br>finalize()(垃圾回收时触发)<br>getClass()<br></code></pre></td></tr></table></figure><h2 id="8-HashCode-Equals"><a href="#8-HashCode-Equals" class="headerlink" title="8. HashCode Equals"></a>8. HashCode Equals</h2><p>HashCode：返回一个代表对象的哈希码的整数值</p><p>equals： 比较两个内容是否相同</p><p>&#x3D;&#x3D;: 基本类型比较值，引用类型比较内存地址</p><h2 id="9-String-StringBuffer-StringBuilder"><a href="#9-String-StringBuffer-StringBuilder" class="headerlink" title="9. String,StringBuffer,StringBuilder"></a>9. String,StringBuffer,StringBuilder</h2><p>String: 不可变对象，每次修改值都需要重新创建一个新对象,适用于少量数据。</p><p>StringBuilder: 可变对象，线程不安全，适用于单线程，大量数据，效率高。</p><p>StringBuffer: 可变对象，线程安全，适用于多线程，大量数据，效率低。</p><p>String不可变原因，底层使用final关键字修饰，使用字符数组保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">public final class String<br>    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    private final char value[];<br></code></pre></td></tr></table></figure><p>StringBuffer安全的原因，加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">capacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value.length;<br>    &#125;<br>......<br></code></pre></td></tr></table></figure><p>StringBuilder效率高</p><p>StringBuffer源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-literal">null</span>) &#123;<br>        toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(toStringCache, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>StringBuilder源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Create a copy, don&#x27;t share the array</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, <span class="hljs-number">0</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显StringBuilder每次copy，而StringBuffer有自己的缓存，缓存区有数据的时候，就直接读取，很明显优化了部分内容，但是只要数量足够大的时候，StringBuffer的锁不起作用的时候，StringBuilder效率高。</p><h2 id="10-字符串常量池"><a href="#10-字符串常量池" class="headerlink" title="10. 字符串常量池"></a>10. 字符串常量池</h2><p>jvm为了提交性能和减少内存消耗为String类型专门开辟的一块区域，避免字符串的重复创建。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先在堆上创建aa</span><br><span class="hljs-comment">// 然后字符串常量池保存aa引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa&quot;</span>;       <br><span class="hljs-comment">// 返回常量池引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa&quot;</span>;<br>System.out.println(a1 == a2); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>String a1 &#x3D; new String(“aa”);</p><p>1-2个字符串对象</p><ol><li>字符串常量池里面不存在”aa”引用，会先在堆上创建一个”aa”，然后在字符串常量池中保存”aa”引用。</li><li>字符串常量池里面存在”aa”引用，只会在堆上创建一个”aa”字符串对象</li></ol><p>intern作用</p><p>将指定的字符串的引用保存在字符串常量中。有字符串常量池保存了引用则返回引用，否则常量池创建引用，返回。</p><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”Java“</span><br><span class="hljs-comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br><span class="hljs-comment">// 会在堆中在单独创建一个字符串对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s3.intern();<br><span class="hljs-comment">// s1 和 s2 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s2); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// s3 和 s4 指向的是堆中不同的对象</span><br>System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// s1 和 s4 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s4); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="11-什么是反射机制？反射机制的优缺点"><a href="#11-什么是反射机制？反射机制的优缺点" class="headerlink" title="11. 什么是反射机制？反射机制的优缺点"></a>11. 什么是反射机制？反射机制的优缺点</h2><p>反射机制：运行时动态的获取类的内部信息，创建对象以及调用对象的属性和方法的机制。</p><p>优点：</p><ul><li>动态的获取类的内部信息，不需要在编译时就知道对象的内部信息。</li><li>动态的创建对象，不需要在编译时知道对象的类型。</li><li>动态的调用对象的属性以及方法，可以在运行时动态的改变对象的行为</li></ul><p>缺点：</p><ul><li>动态的，效率低</li><li>动态的，不安全，破环java封装。</li></ul><p>应用场景：</p><ul><li>动态代理：使用动态代理可以在运行时动态创建代理对象，不需要在编译的时候知道接口的实现。</li><li>单元测试：Junit单元测试可以使用反射机制在运行时动态的获取类和方法的实现，实现自动化测试。</li><li>配置加载文件：Spring使用反射机制来读取和解析配置文件，实现依赖注入，切面编程。</li><li>个人项目API接口：由于接口是在单独的模块，我不需要知道有哪些接口，我只需要使用反射机制来读取相关接口的信息，然后调用里面的方法。</li></ul><h2 id="12-代理模式"><a href="#12-代理模式" class="headerlink" title="12. 代理模式"></a>12. 代理模式</h2><p>使用代理对象来替代对真实对象的访问，这样可以在不修改对象的原目标的前提下，提供额外的操作，<strong>扩展目标对象的功能</strong>。</p><h3 id="12-1-动态代理"><a href="#12-1-动态代理" class="headerlink" title="12.1. 动态代理"></a>12.1. 动态代理</h3><p>jvm：动态代理是在运行时动态的生成类字节码文件，加载到jvm中去。</p><h4 id="12-1-1-JDK动态代理和CGLIB动态代理机制"><a href="#12-1-1-JDK动态代理和CGLIB动态代理机制" class="headerlink" title="12.1.1. JDK动态代理和CGLIB动态代理机制"></a>12.1.1. JDK动态代理和CGLIB动态代理机制</h4><p>实现方式：JDK动态代理是使用的反射实现的。CGLIB通过继承目标类。</p><p>依赖库：JDK动态代理是通过java自带的库。而CGLIB是依赖cglib库。</p><p>目标类限制：JDK动态代理要求目标类必须要实现接口。</p><p>对象类型：JDK动态代理只能实现接口的类或者直接代理接口，而CGLIB可<strong>以代理未实现任何接口的类。</strong>通过继承实现，生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理final类。</p><p>应用场景</p><p>JDK动态代理：接口代理</p><p>CGLIB动态代理：类代理</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo存在提交github后,xxx.gitHub.io不更新</title>
      <link href="/post/344c3b7c.html"/>
      <url>/post/344c3b7c.html</url>
      
        <content type="html"><![CDATA[<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>hexo clean<br>hexo g -d</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>缓存未及时更新</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
